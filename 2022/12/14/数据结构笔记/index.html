<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-corner-indicator.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":true,"color":"#000","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第一章  绪论算法+数据结构&#x3D;程序  数据结构：相互之间存在一定关系的数据元素的集合  数据的逻辑结构：数据元素之间逻辑关系的整体  分为集合（无关系），线性结构（一对一），树结构（一对多），图结构（多对多） 是用户视图，面向问题   数据的存储结构：数据及其逻辑结构在计算机（内存）中的表示  分为顺序和链状 是实现视图，面向计算机     算法：算法就是求解问题的方法和步骤。经过一系列">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构笔记">
<meta property="og:url" content="http://example.com/2022/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="FireEgg&#39;s Blog">
<meta property="og:description" content="第一章  绪论算法+数据结构&#x3D;程序  数据结构：相互之间存在一定关系的数据元素的集合  数据的逻辑结构：数据元素之间逻辑关系的整体  分为集合（无关系），线性结构（一对一），树结构（一对多），图结构（多对多） 是用户视图，面向问题   数据的存储结构：数据及其逻辑结构在计算机（内存）中的表示  分为顺序和链状 是实现视图，面向计算机     算法：算法就是求解问题的方法和步骤。经过一系列">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221210092354091.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221210092457834.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221210144624305.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221210144645247.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221210144838685.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211104439688.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211105948734.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211111118086.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211111517554.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211111728594.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211153711633.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211161702259.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211162527051.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211162539146.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211163043988.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211163053002.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211163456348.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211163529355.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211210851170.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211211423126.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221211222428900.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212093507734.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212094926628.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212111422704.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212125441760.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163630054.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163647086.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163704301.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163718989.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163748013.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163836044.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163856422.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212163801135.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212182913071.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212183008759.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212183338331.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212183850519.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212210952914.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212212600033.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212213744856.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212215718940.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212222126669.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212231312555.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212231631601.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212232058458.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212231822114.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212233855835.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212233347343.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212235033886.png">
<meta property="og:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221212235055690.png">
<meta property="article:published_time" content="2022-12-14T01:28:37.000Z">
<meta property="article:modified_time" content="2023-01-01T14:38:59.003Z">
<meta property="article:author" content="Fire Egg">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E7%AE%97%E6%B3%95/image-20221210092354091.png">


<link rel="canonical" href="http://example.com/2022/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/","path":"2022/12/14/数据结构笔记/","title":"数据结构笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构笔记 | FireEgg's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">FireEgg's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">第一章  绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">算法的基本特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BADT"><span class="nav-number">1.2.</span> <span class="nav-text">抽象数据类型ADT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.</span> <span class="nav-text">复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.1.</span> <span class="nav-text">常见复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">第二章 顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">双链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.3.</span> <span class="nav-text">循环链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">第三章 栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.1.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-number">3.1.1.</span> <span class="nav-text">顺序栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%A0%88"><span class="nav-number">3.1.2.</span> <span class="nav-text">链栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.2.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.2.1.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="nav-number">3.2.2.</span> <span class="nav-text">链队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">第四章 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">KMP算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.</span> <span class="nav-text">矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.1.</span> <span class="nav-text">普通矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.2.</span> <span class="nav-text">对称矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.3.</span> <span class="nav-text">对角矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="nav-number">4.2.4.</span> <span class="nav-text">稀疏矩阵</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">第五章 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%A0%91"><span class="nav-number">5.1.</span> <span class="nav-text">普通树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">5.1.2.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.3.</span> <span class="nav-text">表示方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">双亲表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">孩子表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">孩子兄弟表示法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97"><span class="nav-number">5.3.</span> <span class="nav-text">森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">5.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-2"><span class="nav-number">5.3.2.</span> <span class="nav-text">遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.4.</span> <span class="nav-text">树的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.4.1.</span> <span class="nav-text">树转换成二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.4.2.</span> <span class="nav-text">森林转换成二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91%E6%88%96%E6%A3%AE%E6%9E%97"><span class="nav-number">5.4.3.</span> <span class="nav-text">二叉树转换为树或森林</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%89"><span class="nav-number">5.5.</span> <span class="nav-text">最优二叉树（哈夫曼树）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE"><span class="nav-number">6.</span> <span class="nav-text">第六章 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="nav-number">6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-3"><span class="nav-number">6.2.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88DFS"><span class="nav-number">6.2.1.</span> <span class="nav-text">深度优先DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88BFS"><span class="nav-number">6.2.2.</span> <span class="nav-text">广度优先BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8"><span class="nav-number">6.3.</span> <span class="nav-text">存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">6.3.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">6.3.2.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">6.4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.1.</span> <span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.2.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">6.5.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.1.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.2.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E8%A1%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">6.6.</span> <span class="nav-text">拓补排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AOV%E7%BD%91"><span class="nav-number">6.6.1.</span> <span class="nav-text">AOV网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.2.</span> <span class="nav-text">排序算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">6.7.</span> <span class="nav-text">关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AOE%E7%BD%91"><span class="nav-number">6.7.1.</span> <span class="nav-text">AOE网</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="nav-number">7.</span> <span class="nav-text">第七章 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text">一些定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">7.2.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">7.3.</span> <span class="nav-text">折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-number">7.4.</span> <span class="nav-text">二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">7.4.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">7.4.2.</span> <span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.5.</span> <span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4"><span class="nav-number">7.5.1.</span> <span class="nav-text">平衡调整</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LL"><span class="nav-number">7.5.1.1.</span> <span class="nav-text">LL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RR"><span class="nav-number">7.5.1.2.</span> <span class="nav-text">RR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LR"><span class="nav-number">7.5.1.3.</span> <span class="nav-text">LR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RL"><span class="nav-number">7.5.1.4.</span> <span class="nav-text">RL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91"><span class="nav-number">7.6.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="nav-number">7.7.</span> <span class="nav-text">散列查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="nav-number">7.7.1.</span> <span class="nav-text">一些概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.7.2.</span> <span class="nav-text">设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="nav-number">7.7.2.1.</span> <span class="nav-text">直接定址法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="nav-number">7.7.2.2.</span> <span class="nav-text">平方取中法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="nav-number">7.7.2.3.</span> <span class="nav-text">除留余数法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="nav-number">7.7.3.</span> <span class="nav-text">开放定址法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">7.7.3.1.</span> <span class="nav-text">线性探测法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95-1"><span class="nav-number">7.7.3.2.</span> <span class="nav-text">线性探测法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="nav-number">7.7.3.3.</span> <span class="nav-text">拉链法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E6%95%A3%E5%88%97%E8%A1%A8%E6%AF%94%E8%BE%83"><span class="nav-number">7.7.4.</span> <span class="nav-text">开闭散列表比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">第八章 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5-1"><span class="nav-number">8.1.</span> <span class="nav-text">一些概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">排序方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.2.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.3.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.5.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.6.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%9A%E4%B9%89-1"><span class="nav-number">8.2.6.1.</span> <span class="nav-text">一些定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E5%8F%B7%E6%96%B9%E5%BC%8F"><span class="nav-number">8.2.6.2.</span> <span class="nav-text">编号方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95"><span class="nav-number">8.2.6.3.</span> <span class="nav-text">堆调整算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">8.2.6.4.</span> <span class="nav-text">堆排序算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.7.</span> <span class="nav-text">二路归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">8.2.7.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-number">8.2.7.2.</span> <span class="nav-text">非递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%9E%8D%E5%90%88"><span class="nav-number">8.2.7.3.</span> <span class="nav-text">融合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">8.3.</span> <span class="nav-text">各算法性能比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.3.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">8.3.2.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">8.3.3.</span> <span class="nav-text">稳定性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-number">8.3.4.</span> <span class="nav-text">迭代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.</span> <span class="nav-text">附录——数据结构的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">辗转相除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">9.2.</span> <span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8-1"><span class="nav-number">9.3.</span> <span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88-1"><span class="nav-number">9.4.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%A0%88-1"><span class="nav-number">9.5.</span> <span class="nav-text">链栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-1"><span class="nav-number">9.6.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97-1"><span class="nav-number">9.7.</span> <span class="nav-text">链队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">9.8.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-number">9.9.</span> <span class="nav-text">二叉链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">9.10.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8-1"><span class="nav-number">9.11.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E7%94%A8%E4%BA%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%EF%BC%89%E5%B8%A6%E6%9D%83%E5%9B%BE"><span class="nav-number">9.12.</span> <span class="nav-text">（用于最小生成树的）带权图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">9.13.</span> <span class="nav-text">常规查找算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-1"><span class="nav-number">9.14.</span> <span class="nav-text">二叉排序树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="nav-number">9.15.</span> <span class="nav-text">闭散列表的线性探测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%8B%89%E9%93%BE%E6%B3%95"><span class="nav-number">9.16.</span> <span class="nav-text">开散列表的拉链法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BC%97%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">9.17.</span> <span class="nav-text">一众排序算法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fire Egg"
      src="/images/avatar.JPG">
  <p class="site-author-name" itemprop="name">Fire Egg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/szlx560223" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;szlx560223" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/6538879" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;6538879" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.JPG">
      <meta itemprop="name" content="Fire Egg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FireEgg's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构笔记 | FireEgg's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-14 09:28:37" itemprop="dateCreated datePublished" datetime="2022-12-14T09:28:37+08:00">2022-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-01 22:38:59" itemprop="dateModified" datetime="2023-01-01T22:38:59+08:00">2023-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>49k</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章  绪论"></a>第一章  绪论</h2><p><strong>算法+数据结构&#x3D;程序</strong></p>
<ul>
<li><p>数据结构：相互之间存在一定<strong>关系</strong>的<strong>数据元素</strong>的集合</p>
<ul>
<li><p>数据的<strong>逻辑结构</strong>：数据元素之间<strong>逻辑关系</strong>的整体</p>
<ul>
<li>分为集合（无关系），线性结构（一对一），树结构（一对多），图结构（多对多）</li>
<li>是用户视图，面向问题</li>
</ul>
</li>
<li><p>数据的<strong>存储结构</strong>：<strong>数据及其逻辑结构</strong>在<strong>计算机</strong>（内存）中的表示</p>
<ul>
<li>分为顺序和链状</li>
<li>是实现视图，面向计算机</li>
</ul>
</li>
</ul>
</li>
<li><p>算法：算法就是求解问题的方法和步骤。经过一系列操作步骤能够输出，<strong>不一定会有输入</strong></p>
</li>
</ul>
<span id="more"></span>

<h3 id="算法的基本特性"><a href="#算法的基本特性" class="headerlink" title="算法的基本特性"></a><strong>算法的基本特性</strong></h3><ul>
<li>有穷性：算法的有穷性是指算法必须能在执行有限个步骤之后终止</li>
<li>确定性：算法的每一步骤必须有确切的定义</li>
<li>可行性：算法指令可以转换为程序语句并且执行</li>
</ul>
<p><strong>好的算法有</strong></p>
<ul>
<li>正确性：输出正确</li>
<li>健壮性：处理错误输入</li>
<li>可理解性：易于理解</li>
<li>抽象分级：模块化</li>
<li>高效性：复杂度低</li>
</ul>
<h3 id="抽象数据类型ADT"><a href="#抽象数据类型ADT" class="headerlink" title="抽象数据类型ADT"></a>抽象数据类型ADT</h3><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221210092354091.png" alt="ADT实现流程"></p>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221210092457834.png" alt="ADT模板"></p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：用T(n)表示问题规模</li>
<li>空间复杂度：用S(n)表示空间规模</li>
<li>都可以用O(n)表示</li>
</ul>
<h4 id="常见复杂度"><a href="#常见复杂度" class="headerlink" title="常见复杂度"></a>常见复杂度</h4><ul>
<li>O(1) 常数型</li>
<li>O(n) 线性型</li>
<li>O(n 2 ) 平方型</li>
<li>O(n 3 ) 立方型</li>
<li>O(2 n ) 指数型</li>
<li>O(log2 n ) 对数型</li>
<li>O(nlog2 n ) 二维型</li>
</ul>
<p><strong>一般以最坏或平均情况为标准</strong></p>
<h2 id="第二章-顺序表"><a href="#第二章-顺序表" class="headerlink" title="第二章 顺序表"></a>第二章 顺序表</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><ul>
<li><p>n（n≥0）个具有相同类型的数据元素的有限序列</p>
</li>
<li><p>特征</p>
<ul>
<li>有限个数</li>
<li>一个表的数据类型相同</li>
<li>一个表的类型任意</li>
<li>有序偶，前后关系明确</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>位置固定</li>
<li>容量固定</li>
</ul>
</li>
<li><p>时间复杂度</p>
<ul>
<li><strong>存取时间O(1)</strong>(按下标)</li>
<li>按值删除元素O(n)</li>
<li>按值查找元素O(n)</li>
<li>插入元素平均耗时n&#x2F;2，表头n，表尾1</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点： <ul>
<li>空间小</li>
<li>随机存取，速度快</li>
</ul>
</li>
<li>缺点： <ul>
<li>容量固定，难以扩充</li>
<li>插入和删除操作需要移动大量元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ul>
<li><p>特征</p>
<ul>
<li>位置零散灵活</li>
<li>容量不固定，自由增删</li>
</ul>
</li>
<li><p>时间复杂度</p>
<ul>
<li>按值存取O(n)</li>
<li>按值删除元素O(n)</li>
<li>按值查找元素O(n)</li>
<li>按值插入元素O(n)</li>
<li><strong>按指针插入元素O(1)</strong></li>
<li><strong>按指针删除元素O(1)</strong></li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点： <ul>
<li>灵活增删</li>
<li>容量灵活</li>
</ul>
</li>
<li>缺点： <ul>
<li>不能随机查找，查找较慢</li>
<li>占用空间较多</li>
</ul>
</li>
</ul>
<p>  <strong>查找多用顺序表，插入删除多用链表</strong></p>
</li>
</ul>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221210144624305.png" alt="p后插入"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> DulNode; </span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">p-&gt;next = s; </span><br></pre></td></tr></table></figure>



<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221210144645247.png" alt="p前插入"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> DulNode; </span><br><span class="line">s-&gt;prior = p-&gt;prior;</span><br><span class="line">s-&gt;next = p;</span><br><span class="line">p-&gt;prior-&gt;next = s; </span><br><span class="line">p-&gt;prior = s;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221210144838685.png" alt="双链表删除"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(p-&gt;prior)-&gt;next = p-&gt;next;</span><br><span class="line">(p-&gt;next)-&gt;prior = p-&gt;prior;</span><br></pre></td></tr></table></figure>

<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rear-&gt;next = first;</span><br><span class="line">first-&gt;prior = rear;</span><br></pre></td></tr></table></figure>

<h2 id="第三章-栈与队列"><a href="#第三章-栈与队列" class="headerlink" title="第三章 栈与队列"></a>第三章 栈与队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ul>
<li><strong>LIFO后进先出</strong></li>
<li><strong>出栈顺序不唯一</strong></li>
<li>判满：top &#x3D;&#x3D; StackSize - 1</li>
<li>时间复杂度<ul>
<li>出入栈：O(1)</li>
</ul>
</li>
</ul>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ul>
<li>不用判满</li>
<li>用<strong>头插法</strong>插入</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ul>
<li>假溢出：数组空间发生上溢，但数组的低端还有空闲空间<ul>
<li>解决办法：<strong>rear &#x3D; (rear + 1) % Size</strong>构造循环队列</li>
</ul>
</li>
<li>判空：<strong>rear &#x3D;&#x3D; front</strong></li>
<li>判满：**(rear+1) % Size &#x3D; front**（浪费一个空间）</li>
<li>时间复杂度<ul>
<li>出入队列：O(1)</li>
</ul>
</li>
</ul>
<h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><ul>
<li>时间复杂度<ul>
<li>入队:无尾结点：O(n)，有尾结点：O(1)</li>
<li>出队：O(1)</li>
</ul>
</li>
</ul>
<h2 id="第四章-字符串"><a href="#第四章-字符串" class="headerlink" title="第四章 字符串"></a>第四章 字符串</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul>
<li>高效的原因：<ul>
<li>主串的i不回溯</li>
<li>模式串<strong>会根据首尾重合的部分跳过</strong></li>
</ul>
</li>
</ul>
<p>T[0] ~ T[k-1] &#x3D; T[j-k] ~ T[j-1] </p>
<p>模式串举例：</p>
<table>
<thead>
<tr>
<th align="center">模式串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">next数组</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="普通矩阵"><a href="#普通矩阵" class="headerlink" title="普通矩阵"></a>普通矩阵</h4><ul>
<li>按行存储：第i行j列的元素aij&#x3D;整行数*每行的元素个数+本行aij前面的元素个数</li>
</ul>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><ul>
<li>aij &#x3D;aji，只存下三角</li>
<li>下三角：k &#x3D; i×(i-1)&#x2F;2+ j-1</li>
<li>上三角：k＝j×(j-1)&#x2F;2＋i -1</li>
</ul>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211104439688.png" alt="对角矩阵"></p>
<ul>
<li>只存非0元素</li>
<li>k&#x3D;2 + 3(i-2)+( j-i + 2) &#x3D; 2i + j-3</li>
</ul>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><ul>
<li>存三元组：(行数，列数，数据)，构造二维数组</li>
<li>十字链表：额外附带两个指针指向右侧和下侧</li>
</ul>
<h2 id="第五章-树"><a href="#第五章-树" class="headerlink" title="第五章 树"></a>第五章 树</h2><h3 id="普通树"><a href="#普通树" class="headerlink" title="普通树"></a>普通树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>结点不能属于多个子树，子树之间不能有关系（<strong>没有回路</strong>）</li>
<li>有序树、无序树：如果一棵树中结点的各子树从左到右是有次序的，称这棵树为 有序树；反之，称为无序树</li>
<li>结点的度：结点所拥有的<strong>子树的个数</strong></li>
<li>树的度：树中各结点度的<strong>最大值</strong></li>
<li>叶子结点：度为 0 的结点</li>
<li>分支结点：度不为 0 的结点</li>
<li>孩子：树中某结点子树的根结点称为这个结点的孩子结点</li>
<li>双亲：这个结点称为它孩子结点的双亲结点</li>
<li>兄弟：具有同一个双亲的孩子结点互称为兄弟</li>
<li>路径长度：一条路径上经过的<strong>边的个数</strong></li>
<li>祖先、子孙：如果有一条路径从结点 x 到结点 y， 则 x 称为 y 的祖先，而 y 称为 x 的子孙</li>
</ul>
<p><strong>对于一棵具有 n 个结点的树,其所有结点的度之和为n-1</strong></p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211105948734.png" alt="例子"></p>
<ul>
<li>前序遍历：根节点&gt;左子树&gt;右子树——ABDEHIFCG</li>
<li>后序遍历：左子树&gt;右子树&gt;根节点——DHIEFBGCA</li>
<li>层序遍历：一层一层依次遍历——ABCDEFGHI</li>
</ul>
<h4 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211111118086.png" alt="双亲表示法"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PNode</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>按层序遍历的顺序存储</li>
<li>时间复杂度<ul>
<li>查找双亲:O(1)</li>
<li>查找孩子:O(n)</li>
</ul>
</li>
</ul>
<h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211111517554.png" alt="孩子表示法"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CBNode</span> <span class="comment">// 表头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    CTNode *firstChild; <span class="comment">// 指向孩子链表的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTNode</span> <span class="comment">// 孩子结点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    CTNode *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>按层序遍历的顺序存储</li>
<li>时间复杂度<ul>
<li>查找双亲:O(n)</li>
<li>查找孩子:O(1)</li>
</ul>
</li>
</ul>
<h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211111728594.png" alt="孩子兄弟表示法"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TNode</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    TNode&lt;DataType&gt; *firstChild, *rightSib;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度<ul>
<li>查找兄弟:O(1)</li>
<li>查找孩子:O(n)<ul>
<li>已知孩子指针:O(1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><strong>二叉树度可以为0,1,2</strong>，<strong>度为2的树不一定是二叉树</strong>，因为二叉树子树是<strong>有序的</strong></li>
<li>左斜树：所有结点都只有左子树的二叉树</li>
<li>右斜树：所有结点都只有右子树的二叉树</li>
<li>满二叉树：满满当当</li>
<li>完全二叉树 ：满二叉树的最后一层从后往前去掉数个节点<ul>
<li>叶子结点只能出现在<strong>最下两层</strong>且最下 层的叶子结点都集中在二叉树的<strong>左面</strong></li>
<li>最多有一个度为1的节点，只能是左孩子</li>
<li>倒数第二层是满二叉树</li>
<li>同样节点数的树中完全二叉树深度最小</li>
</ul>
</li>
</ul>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>总节点树为n，叶子结点数n0，度为2的节点树为n2<ul>
<li>n＝n0＋n1＋n2</li>
<li>n＝n1＋2n2＋1</li>
<li>n0 ＝n2＋1</li>
</ul>
</li>
<li>第 i 层上最多有2^i-1个结点</li>
<li>一棵深度为 k 的二叉树中，最多有 2^k-1个结点</li>
<li>具有 n 个结点的完全二叉树的深度为 (int)(log2n) +1</li>
<li>对一棵具有 n 个结点的完全二叉树中从 1 开始按层序 编号，对于任意的序号为 i的结点有：<ul>
<li>如果 i＞1，则结点 i 的双亲结点的序号为 i&#x2F;2，否则结点 i 无双亲结点</li>
<li>如果 2i≤n，则结点 i 的左孩子的序号为 2i，否则结点 i 无左孩子</li>
<li>如果 2i+1≤n，则结点 i 的右孩子的序号为2i+1，否则结点 i 无右孩子</li>
</ul>
</li>
</ul>
<h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211153711633.png" alt="例子"></p>
<ul>
<li>前序遍历：根节点&gt;左子树&gt;右子树——ABDGCEF</li>
<li>中序遍历：左子树&gt;根节点&gt;右子树——DGBAECF</li>
<li>后序遍历：左子树&gt;右子树&gt;根节点——GDBEFCA</li>
<li>层序遍历：一层一层依次遍历——ABCDEFG<ul>
<li>时间复杂度:O(n)</li>
</ul>
</li>
</ul>
<h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li>n棵互不相交的树的集合</li>
<li>树删去根节点就是森林</li>
</ul>
<h4 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211161702259.png" alt="例子"></p>
<ul>
<li>前序遍历：AB CDEF GHIJ</li>
<li>后序遍历：BA DEFC HJIG</li>
</ul>
<h3 id="树的转换"><a href="#树的转换" class="headerlink" title="树的转换"></a>树的转换</h3><h4 id="树转换成二叉树"><a href="#树转换成二叉树" class="headerlink" title="树转换成二叉树"></a>树转换成二叉树</h4><ol>
<li>加线——树中所有<strong>相邻兄弟之间加一条连线</strong></li>
<li>去线——对树中的每个结点，<strong>只保留它与第 一个孩子结点之间的连线</strong>，删去它与其它孩子结点 之间的连线。 </li>
<li>层次调整</li>
</ol>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211162527051.png" alt="操作"></p>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211162539146.png" alt="结果"></p>
<h4 id="森林转换成二叉树"><a href="#森林转换成二叉树" class="headerlink" title="森林转换成二叉树"></a>森林转换成二叉树</h4><ol>
<li>将森林中的每棵树转换为二叉树 </li>
<li>将每棵树的根结点视为兄弟，在所有根结点之间加上连线 </li>
<li>层次调整</li>
</ol>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211163043988.png" alt="操作"></p>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211163053002.png" alt="结果"></p>
<h4 id="二叉树转换为树或森林"><a href="#二叉树转换为树或森林" class="headerlink" title="二叉树转换为树或森林"></a>二叉树转换为树或森林</h4><ol>
<li>加线——若某结点x是其双亲y的左孩子，则把结点x的右孩子、右孩子 的右孩子、……，都与结点y用线连起来；</li>
<li>去线——删去原二叉树中所有的双亲结点与右孩子结点的连线；</li>
<li>层次调整</li>
</ol>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211163456348.png" alt="操作"></p>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211163529355.png" alt="结果"></p>
<h3 id="最优二叉树（哈夫曼树）"><a href="#最优二叉树（哈夫曼树）" class="headerlink" title="最优二叉树（哈夫曼树）"></a>最优二叉树（哈夫曼树）</h3><ul>
<li>叶子带有权值</li>
<li>权值越大的叶子结点越靠近根结点<ul>
<li>压缩中越常用的字越靠前，编码越短</li>
</ul>
</li>
<li>只有度为 0 和度为 2 的结点，不存在度为 1 的结点</li>
<li>前缀编码：在一组编码中，任一编码都不是其它任何编码的前缀</li>
</ul>
<h2 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li>图：n(n&gt;0&amp;&amp;n&lt;Inf.)个顶点和m(m&gt;&#x3D;0)个边构成，表示为G &#x3D; (V，E)</li>
<li>无向边、无向图：没有方向</li>
<li>有向边、有向图：有方向</li>
<li>权：对边赋予的有意义的数值 </li>
<li>带权图 （网图 ）：边上带权的图</li>
<li>邻接、邻接点：ab两点有边连着，b是a的邻接点（<strong>有向图中须是a指向b</strong>）</li>
<li>完全图：每两个点都有一条边（<strong>有向图中是互指的两条边</strong>）</li>
<li>度：连着的边数</li>
<li>入度、出度：有向图中<strong>被指着</strong>和<strong>指出去</strong>的边数</li>
<li>路径、回路：顶点序列，如abcde；回路是个环，如abcda</li>
<li>简单路径（简单回路）：序列中顶点不重复出现的路径</li>
<li>路径长度：路径里边的个数（<strong>带权图中是边上权值的和</strong>）</li>
<li>子图：原图的一部分</li>
<li>连通图：在<strong>无向图</strong>中，如果任意两个顶点都是连通的， 则称该无向图是连通图</li>
<li>连通分量：非连通图的极大连通子图（含有极大顶点数+依附于这些顶点的所有边）</li>
<li>强连通图：在<strong>有向图</strong>中，如果任意两个顶点都是强连通 的，则称该有向图是强连通图</li>
<li>强连通分量：非强连通图的极大连通子图</li>
</ul>
<h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><h4 id="深度优先DFS"><a href="#深度优先DFS" class="headerlink" title="深度优先DFS"></a>深度优先DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MGraph&lt;DataType&gt;::<span class="built_in">DFSTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        <span class="keyword">if</span> (arc[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">DFSTraverse</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先BFS"><a href="#广度优先BFS" class="headerlink" title="广度优先BFS"></a>广度优先BFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MGraph&lt;DataType&gt;::<span class="built_in">BFSTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        visited[j] = <span class="number">0</span>;</span><br><span class="line">    front = rear = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    <span class="keyword">while</span> (front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        v = Q[++front];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arc[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211210851170.png" alt="邻接矩阵"></p>
<ul>
<li>一维数组：存储图中顶点的信息</li>
<li>二维数组：存储图中各顶点之间的邻接关系</li>
</ul>
<p>空间复杂度:O(n^2)</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211211423126.png" alt="邻接表"></p>
<ul>
<li>顶点表：所有边表的头指针和存储顶点信息的一维数组</li>
<li>边表（邻接表）：顶点 v 的所有邻接点链成的单链表</li>
</ul>
<p>空间复杂度:O(n+e)(e是边数)</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul>
<li>寻求最短路径使得能够遍历所有顶点</li>
</ul>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph&lt;DataType&gt; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lowcost[MaxSize]; <span class="comment">// 最短边数组</span></span><br><span class="line">    <span class="type">int</span> adjvex[MaxSize];  <span class="comment">// 最短边邻接的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++) <span class="comment">// 初始化辅助数组shortEdge</span></span><br><span class="line">    &#123;</span><br><span class="line">        lowcost[i] = G-&gt;arc[v][i]; <span class="comment">// 到达i的最短路径设置为v到i的距离（可能不存在）</span></span><br><span class="line">        adjvex[i] = v;             <span class="comment">// 初始化，没有意义</span></span><br><span class="line">    &#125;</span><br><span class="line">    lowcost[v] = <span class="number">0</span>; <span class="comment">// 开始前，把自己的点的最短边距设成0</span></span><br><span class="line">    <span class="comment">// 正式开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G.vertexNum; i++) <span class="comment">// 自己找完了，剩下的找vertexNum-1轮就够</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">MinEdge</span>(lowcost, G.vertexNum); <span class="comment">// 寻找最短边的邻接点k</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; adjvex[k] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; lowcost[k] &lt;&lt; endl;</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;                       <span class="comment">// 已经包括顶点k，最短距离设置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vertexNum; j++) <span class="comment">// 以k为起点遍历他的所有边</span></span><br><span class="line">            <span class="keyword">if</span> (G.arc[k][j] &lt; lowcost[j])     <span class="comment">// 如果从k到j有比lowcost里记录的更短（有更短的距离能到j）</span></span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = G.arc[k][j]; <span class="comment">// 更新lowcost</span></span><br><span class="line">                adjvex[j] = k;            <span class="comment">// 把自己设置成目标顶点的邻接点</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用<strong>邻接矩阵</strong>作为存储结构</li>
<li>时间复杂度：O(n^2 )</li>
</ul>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221211222428900.png" alt="Prim步骤"></p>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxVertex = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxEdge = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from, to;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> EdgeGraph&lt;DataType&gt;::<span class="built_in">Kruskal</span>(EdgeGraph&lt;DataType&gt; G)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, num = <span class="number">0</span>, vex1, vex2;</span><br><span class="line">    <span class="type">int</span> parent[vertexNum]; <span class="comment">// 顶点的双亲</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = <span class="number">-1</span>; <span class="comment">// 初始化，所有节点都是独立的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (num = <span class="number">0</span>, i = <span class="number">0</span>; num &lt; G-&gt;vertexNum; i++) <span class="comment">// 对于每一条边（从小到大）</span></span><br><span class="line">    &#123;</span><br><span class="line">        vex1 = <span class="built_in">FindRoot</span>(parent, G-&gt;edge[i].from);</span><br><span class="line">        vex2 = <span class="built_in">FindRoot</span>(parent, G-&gt;edge[i].to);</span><br><span class="line">        <span class="keyword">if</span> (vex1 != vex2) <span class="comment">// 没有同一个根节点，不在同一组里</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)%d &quot;</span>, G-&gt;edge[i].from, G-&gt;edge[i].to, G-&gt;edge[i].weight);</span><br><span class="line">            parent[vex2] = vex1; <span class="comment">// 设置终点的双亲节点为起点，加入同一组</span></span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用<strong>边集数组</strong>作为存储结构</li>
<li>时间复杂度：O(e*log2 e )</li>
</ul>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212093507734.png" alt="Kruskal步骤"></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(MGraph&lt;DataType&gt; G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dist[MaxSize];                    <span class="comment">// 到达对应顶点的最小距离</span></span><br><span class="line">    string path[MaxSize];                 <span class="comment">// 路径</span></span><br><span class="line">    <span class="function">string <span class="title">vertex</span><span class="params">(G.vertex)</span></span>;              <span class="comment">// 存放对应顶点的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++) <span class="comment">// 对于每一个顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = G.arc[v][i]; <span class="comment">// 第一轮，初始化到达对应顶点的距离（是目标点到各顶点的距离）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[i] != <span class="number">255</span>) <span class="comment">// 如果距离小于255（是通路）</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[i] += vertex[v]; <span class="comment">// 起点是v</span></span><br><span class="line">            path[i] += vertex[i]; <span class="comment">// 路径囊括进来的第一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i] = <span class="string">&quot;&quot;</span>; <span class="comment">// 否则置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>; <span class="comment">// 到自己的距离为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">1</span>; num &lt; G.vertexNum; num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">255</span>; <span class="comment">// 最短的边</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;     <span class="comment">// 未到达区域里路径最短的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++)</span><br><span class="line">        &#123;                                          <span class="comment">// 寻找最短边和下一个目标点</span></span><br><span class="line">            <span class="keyword">if</span> ((dist[i] != <span class="number">0</span>) &amp;&amp; (dist[i] &lt; min)) <span class="comment">// 未到达且是通路</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; path[k] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dist[k] &lt;&lt; <span class="string">&quot;;&quot;</span> &lt;&lt; endl; <span class="comment">// 找到了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &gt; dist[k] + G.arc[k][i]) <span class="comment">// 以找到的目标点为基础向外辐射，如果经过他后到达别的顶点的距离更短</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[i] = dist[k] + G.arc[k][i]; <span class="comment">// 更新到对应点的最短距离为过目标点再到对应点</span></span><br><span class="line">                <span class="comment">// 更新路径字符串</span></span><br><span class="line">                path[i] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                path[i] += path[k];</span><br><span class="line">                path[i] += vertex[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dist[k] = <span class="number">0</span>; <span class="comment">// 目标点到达自身的距离为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用<strong>邻接矩阵</strong>存储</li>
<li>时间复杂度：O(n^2 )</li>
</ul>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212094926628.png" alt="Dijkstra步骤"></p>
<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><ul>
<li>采用<strong>邻接矩阵</strong>存储</li>
<li>时间复杂度：O(n^3 )</li>
</ul>
<p>略</p>
<h3 id="拓补排序"><a href="#拓补排序" class="headerlink" title="拓补排序"></a>拓补排序</h3><h4 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h4><ul>
<li>全称：Activity On Vertex Network</li>
</ul>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212111422704.png" alt="例子"></p>
<ul>
<li>拓扑排序：<strong>没有前驱的在前</strong>，说明优先级高</li>
<li>例如：v0 v1 v2 v3 v4 v5 v6</li>
</ul>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ul>
<li>采用邻接表储存，<strong>相比邻接表多出一个入度域</strong>，记录入度数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> in; <span class="comment">// 顶点的入度，用在拓补排序</span></span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode *firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt;::<span class="built_in">TopSort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> S[MaxSize], top = <span class="number">-1</span>; <span class="comment">// 一个栈</span></span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++)<span class="comment">//初始化，第一轮</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (adjlist[i].in == <span class="number">0</span>)</span><br><span class="line">            S[++top] = i;<span class="comment">//没有入度的顶点入栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)<span class="comment">//栈不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = S[top--];<span class="comment">//取栈顶</span></span><br><span class="line">        count++;<span class="comment">//有多少个顶点被排序</span></span><br><span class="line">        cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">        p = adjlist[j].first;<span class="comment">//出栈顶点指向的后继节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = p-&gt;adjvex;<span class="comment">//被指向的后继节点</span></span><br><span class="line">            adjlist[k].in--;<span class="comment">//他的前驱节点出栈了（拿走了），后继节点入度-1</span></span><br><span class="line">            <span class="keyword">if</span> (adjlist[k].in == <span class="number">0</span>)<span class="comment">//如果这个后继节点的入度为0</span></span><br><span class="line">                S[++top] = k;<span class="comment">//入栈</span></span><br><span class="line">            p = p-&gt;next;<span class="comment">//查询出栈元素的下一个后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; vertexNum)<span class="comment">//循环一遍，所有能被拿掉元素都被拿掉，如果拿掉的个数比总顶点个数少</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有回路&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><h4 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h4><p>全称：Activity On Edge Network(带权AOV图)</p>
<p>以下图为例</p>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212125441760.png" alt="例子"></p>
<p>求：</p>
<p><strong>1.事件的最早发生时间 ve[n]</strong> </p>
<ul>
<li>ve[0] &#x3D; 0</li>
<li>ve[k] &#x3D; max{ve[ j ] + len&lt;vj,vk&gt;}(&lt;vj,vk&gt;∈能到达vk的有向边)</li>
</ul>
<p>ve &#x3D; {0,4,6,10}</p>
<p><strong>2.事件的最迟发生时间 vl[n]</strong> </p>
<ul>
<li>vl[n-1] &#x3D; ve[n-1]</li>
<li>vl[k] &#x3D; min{vl[ j ]-len&lt;vj,vk&gt;}(&lt;vj,vk&gt;∈能到达vk的有向边)</li>
</ul>
<p>vl &#x3D; {0,4,6,10}</p>
<p><strong>3.活动的最早开始时间 ae[e]</strong> </p>
<ul>
<li>ae[i] &#x3D; ve[k] (i是活动编号，k是活动的出发事件)</li>
</ul>
<p>ae&#x3D;{0,0,4,6,4}</p>
<p><strong>4.活动的最晚开始时间 al[e]</strong></p>
<ul>
<li>al[i] &#x3D; vl[j] - len&lt;vk,vj&gt;(i是活动编号，j是活动的结束事件)</li>
</ul>
<p>al&#x3D;{0,3,4,6,4}</p>
<h2 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h2><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><ul>
<li><strong>关键码</strong>：可以标识一个记录的某个数据项</li>
<li>键值：关键码的值</li>
<li>主关键码：可以唯一标识一个记录的关键码 </li>
<li>次关键码：不能唯一标识一个记录的关键码</li>
<li>查找：在相同类型的记录构成的集合中找出满足给定条件的记录</li>
<li><strong>静态查找</strong> ：不涉及插入和删除操作的查找</li>
<li>动态查找 ：涉及插入和删除操作的查找</li>
<li>查找结构 ：面向查找操作的数据结构 ，即查找基于的数据结构</li>
<li><strong>平均查找长度</strong>：查找算法进行的关键码比较次数的数学期望值，<strong>用来衡量查找性能</strong></li>
</ul>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SeqSearch</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n, <span class="type">int</span> k)</span> <span class="comment">// 从数组下标1开始存放待查元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = n;</span><br><span class="line">    r[<span class="number">0</span>] = k; <span class="comment">// 下标0用作监视哨，算法会在0的时候出循环，省去判断数组越界</span></span><br><span class="line">    <span class="keyword">while</span> (r[i] != k)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 返回0就是没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均查找长度:O(n)</p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n, <span class="type">int</span> k)</span> <span class="comment">// 从数组下标1开始存放待查集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>, high = n; <span class="comment">// 设置待查区间</span></span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) <span class="comment">// 这个区间里还有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; r[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>; <span class="comment">// 比mid小，区间肯定在1~mid-1中间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; r[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">// 比mid大，区间肯定在mid+1~n中间</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 找到了，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="type">int</span> data[MaxSize + <span class="number">1</span>]; <span class="comment">// 外部数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch2</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; data[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(low, mid - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; data[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(mid + <span class="number">1</span>, high, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">/*查找成功，返回序号*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均查找长度:O(log2 n),但是要从<strong>小到大排序</strong></p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p><strong>重点掌握插入与删除</strong>，完整代码见结尾</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><strong>比根节点大的往右，小的往左</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiNode&lt;<span class="type">int</span>&gt; *<span class="title">BiSortTree::InsertBST</span><span class="params">(BiNode&lt;<span class="type">int</span>&gt; *bt, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BiNode&lt;<span class="type">int</span>&gt; *s = <span class="keyword">new</span> BiNode&lt;<span class="type">int</span>&gt;;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        bt = s;</span><br><span class="line">        <span class="keyword">return</span> bt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;data &gt; x)</span><br><span class="line">        bt-&gt;lchild = <span class="built_in">InsertBST</span>(bt-&gt;lchild, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bt-&gt;rchild = <span class="built_in">InsertBST</span>(bt-&gt;rchild, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li><strong>设待删除结点为p，其双亲结点为f，且 p 是 f 的左孩子</strong></li>
</ul>
<p>1.被删除的结点是叶子结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p-&gt;lchild == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;rchild == <span class="literal">NULL</span>))<span class="comment">// p为叶子</span></span><br><span class="line">&#123;                     </span><br><span class="line">    f-&gt;lchild = <span class="literal">NULL</span>; <span class="comment">// 将双亲结点中相应指针域的值改为空</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163630054.png" alt="before"><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163647086.png" alt="after"></p>
<p>2.被删除的结点只有左子树或者只有右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将双亲结点中相应指针域指向被删除结点的左子树（或右子树）*/</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">&#123; <span class="comment">// p只有左子树</span></span><br><span class="line">    f-&gt;lchild = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">&#123; <span class="comment">// p只有右子树</span></span><br><span class="line">    f-&gt;lchild = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163704301.png" alt="before"><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163718989.png" alt="after"></p>
<p>3.被删除的结点既有左子树也有右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查找左子树的最右下结点*/</span></span><br><span class="line">BiNode&lt;<span class="type">int</span>&gt; *par = p, *s = p-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span> (s-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">//一直找左子树里最大的</span></span><br><span class="line">&#123;</span><br><span class="line">    par = s;</span><br><span class="line">    s = s-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;data = s-&gt;data;<span class="comment">//把他的数据替换到待删节点</span></span><br><span class="line"><span class="keyword">if</span> (par == p)<span class="comment">//如果左子树中的最大值结点是被删结点的孩子</span></span><br><span class="line">    par-&gt;lchild = s-&gt;lchild;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    par-&gt;rchild = s-&gt;lchild;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163748013.png" alt="before"><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163836044.png" alt="after"></p>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163856422.png" alt="before"><img src="/images/%E7%AE%97%E6%B3%95/image-20221212163801135.png" alt="after"></p>
<p><strong>平均查找长度:O(n)~O(log2 n)</strong></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树：根结点的左子树和右子树的深度最多相差1,根结点的左子树和右子树也都是平衡二叉树的<strong>二叉排序树</strong>（可能为空）</p>
<p>平衡因子：该结点的左子树的深度减去右子树的深度。<strong>在平衡二叉树中， 结点的平衡因子是1、0 或 -1</strong></p>
<h4 id="平衡调整"><a href="#平衡调整" class="headerlink" title="平衡调整"></a>平衡调整</h4><h5 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212182913071.png" alt="LL"></p>
<ul>
<li>右翻，现根节点原来的右子树递给原根节点作左子树</li>
</ul>
<h5 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212183008759.png" alt="RR"></p>
<ul>
<li>左翻，现根节点原来的左子树递给原根节点作右子树</li>
</ul>
<h5 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212183338331.png" alt="LR"></p>
<p>左子树先左翻，根节点再右翻，新来的节点看着插</p>
<h5 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212183850519.png" alt="RL"></p>
<p>右子树先右翻，根节点再左翻，新来的节点看着插</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>不考，略</p>
<h3 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h3><h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><ul>
<li>散列表：采用散列技术存储查找集合的<strong>连续存储空间</strong>。</li>
<li>散列函数：将关键码映射为散列表中适当存储位置的函数，可自定。</li>
<li>散列地址：由散列函数所得的<strong>存储地址</strong>。</li>
</ul>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><p><strong>H(key)&#x3D;a * key + b</strong></p>
<p>适用于：事先知道关键码，关键码集合不是很大且连续性较好</p>
<h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p><strong>H(key)&#x3D;mid(n^2)&#x3D;mid(abcdef)&#x3D;cd</strong></p>
<p>适用于：事先不知道关键码的分布且关键码的位数不是很大</p>
<h5 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h5><p><strong>H(key)&#x3D;key (mod) p</strong></p>
<p>适用于：最简单、最常用，不要求事先知道关键码的分布</p>
<h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>若没有冲突就存入，有冲突就以一定算法找一个空的</p>
<h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p>依次找，直到没有冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> HashTable1 ::<span class="built_in">Search</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j = k%MaxSize; <span class="comment">// 计算散列地址</span></span><br><span class="line">    i = j;           <span class="comment">// 设置比较的起始位置</span></span><br><span class="line">    <span class="keyword">while</span> (ht[i] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] == k)</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 查找成功</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = (i + <span class="number">1</span>) % MaxSize; <span class="comment">// 向后探测一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线性探测法-1"><a href="#线性探测法-1" class="headerlink" title="线性探测法"></a>线性探测法</h5><ul>
<li>有冲突时，将i++替换为i+&#x3D;n^2,n&lt;&#x3D;m&#x2F;2</li>
</ul>
<h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>把数组换成单链表头指针数组，没有冲突就直接插，否则使用头插法插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> HashTable2 ::<span class="built_in">Insert</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = k % MaxSize;</span><br><span class="line">    Node&lt;<span class="type">int</span>&gt; *p = ht[j];</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;<span class="type">int</span>&gt; *q = <span class="keyword">new</span> Node&lt;<span class="type">int</span>&gt;;</span><br><span class="line">        q-&gt;data = k;</span><br><span class="line">        q-&gt;next = ht[j];</span><br><span class="line">        ht[j] = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开闭散列表比较"><a href="#开闭散列表比较" class="headerlink" title="开闭散列表比较"></a>开闭散列表比较</h4><ul>
<li><p>开散列表</p>
<ul>
<li>空间<ul>
<li>+没有记录个数的限制</li>
<li>-子表过长会降低查找效率</li>
<li>-指针的结构性开销</li>
</ul>
</li>
<li>时间<ul>
<li>+不会产生堆积现象，效率较高</li>
<li>+适用于静态查找和动态查找</li>
</ul>
</li>
</ul>
</li>
<li><p>闭散列表</p>
<ul>
<li><p>空间</p>
<ul>
<li>-受数组空间限制</li>
<li>+存储效率较高</li>
</ul>
</li>
<li><p>时间</p>
<ul>
<li>-有堆积现象，降低查找效率</li>
<li>-仅适用于静态查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h2><h3 id="一些概念-1"><a href="#一些概念-1" class="headerlink" title="一些概念"></a>一些概念</h3><ul>
<li>排序：给定一组记录的集合和与其对应的关键码并把它们按关键码排成特定序列</li>
<li>趟：在排序过程中，将待排序的记录序列扫描一遍称为一趟</li>
<li>排序算法的稳定性：关键码相同的两个元素在排序前后<strong>前后位置不变</strong></li>
</ul>
<p><strong>默认升序，关键码和数据一一对应，顺序存储，下标从1开始</strong></p>
<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212210952914.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; length; i++)<span class="comment">//约定俗成，从1开始，但第一趟只有一个元素，不用比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        data[<span class="number">0</span>] = data[i];<span class="comment">//0是暂存区</span></span><br><span class="line">        j = i - <span class="number">1</span>;<span class="comment">//和最大的元素比较</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; data[<span class="number">0</span>] &lt; data[j])<span class="comment">//如果j&gt;0且小于最大的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            data[j + <span class="number">1</span>] = data[j];<span class="comment">//元素后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        data[j + <span class="number">1</span>] = data[<span class="number">0</span>];<span class="comment">//把暂存的元素放到腾出来的位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对待排序元素直接插入到已排序序列中</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212212600033.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> <span class="comment">// n是长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = n / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d = d / <span class="number">2</span>) <span class="comment">// 以增量为d进行直接插入排序，d一般从长度的一半开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d + <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 第一组只包含每个子序列的第一个元素，不需要排序，从第二组开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            r[<span class="number">0</span>] = r[i]; <span class="comment">// 0号单元作为暂存单元</span></span><br><span class="line">            <span class="type">int</span> j = i - d;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; r[<span class="number">0</span>] &lt; r[j])<span class="comment">// 插入排序</span></span><br><span class="line">            &#123; </span><br><span class="line">                j = j - d;</span><br><span class="line">                r[j + d] = r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            r[j + d] = r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将待排序序列<strong>分割成若干个子序列</strong>，在子序列内分别进行直接插入排序，待序列基本有序时，对全体进行直接插入排序</li>
<li>时间复杂度：O(nlog2 n)~O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212213744856.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j, exchange, bound;</span><br><span class="line">    exchange = length; <span class="comment">// 第一趟起泡排序的区间是[1~length]</span></span><br><span class="line">    <span class="keyword">while</span> (exchange != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bound = exchange;</span><br><span class="line">        exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; bound; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &gt; data[j + <span class="number">1</span>])<span class="comment">//后面的大于前面的</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//前后交换</span></span><br><span class="line">                data[<span class="number">0</span>] = data[j];</span><br><span class="line">                data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">                data[j + <span class="number">1</span>] = data[<span class="number">0</span>];</span><br><span class="line">                exchange = j; <span class="comment">// 记载每一次记录交换的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 一趟起泡排序的区间是[1~bound]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>相邻待排序元素若大小相反则交换位置，与普通冒泡排序相比<strong>设置一个标记记录最后一次交换所在的位置</strong></li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212215718940.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = first, j = last;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; data[i] &lt;= data[j]) <span class="comment">// 使左边的比右边小</span></span><br><span class="line">        &#123;</span><br><span class="line">            j--; <span class="comment">/*右侧扫描*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            data[<span class="number">0</span>] = data[i];</span><br><span class="line">            data[i] = data[j];</span><br><span class="line">            data[j] = data[<span class="number">0</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; data[i] &lt;= data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++; <span class="comment">/*左侧扫描*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            data[<span class="number">0</span>] = data[i];</span><br><span class="line">            data[i] = data[j];</span><br><span class="line">            data[j] = data[<span class="number">0</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 得到的是中间点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> first, <span class="type">int</span> last)</span><span class="comment">//从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">Partition</span>(data, first, last);</span><br><span class="line">        <span class="built_in">QuickSort</span>(data, first, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(data, pivot + <span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>递归</strong>以中间为界把小的元素放左边，大的元素放右边</li>
<li>时间复杂度：O(nlog2n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212222126669.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> <span class="comment">// n是长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index, j, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 约定俗成，从1开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// 在未排序区里找最小的</span></span><br><span class="line">            <span class="keyword">if</span> (r[j] &lt; r[index])</span><br><span class="line">                index = j;</span><br><span class="line">        <span class="keyword">if</span> (index != i) <span class="comment">// 如果有则与未交换区的第一个元素交换</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = r[i];</span><br><span class="line">            r[i] = r[index];</span><br><span class="line">            r[index] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把未排序序列里最小的移到序列左边直至结束</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="一些定义-1"><a href="#一些定义-1" class="headerlink" title="一些定义"></a>一些定义</h5><ul>
<li>小根堆：每个结点的值都<strong>小于</strong>等于其左右孩子结点的完全二叉树，堆顶最小</li>
<li>大根堆：每个结点的值都<strong>大于</strong>等于其左右孩子结点的完全二叉树，堆顶最大</li>
<li>堆调整：在一棵完全二叉树中，根结点的左右子树均是堆，调整根结点使整个完全二叉树成为一个堆的过程。</li>
</ul>
<h5 id="编号方式"><a href="#编号方式" class="headerlink" title="编号方式"></a>编号方式</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212231312555.png" alt="编号方式"></p>
<h5 id="堆调整算法"><a href="#堆调整算法" class="headerlink" title="堆调整算法"></a>堆调整算法</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212231631601.png" alt="步骤"></p>
<p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212232058458.png" alt="调整顺序"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sift</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> k, <span class="type">int</span> last)</span> <span class="comment">// 筛选法调整堆的算法，last是根节点编号，最后一个编号为m</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    i = k;</span><br><span class="line">    j = <span class="number">2</span> * i; <span class="comment">// i指向被筛选结点，j指向结点i的左孩子;</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= last)<span class="comment">//还没有进行到叶子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; last &amp;&amp; r[j] &lt; r[j + <span class="number">1</span>])<span class="comment">// j指向左右孩子的较大者</span></span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (r[i] &gt; r[j])<span class="comment">//已经是堆</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//r[0]暂存，交换ij</span></span><br><span class="line">            r[<span class="number">0</span>] = r[i];</span><br><span class="line">            r[i] = r[j];</span><br><span class="line">            r[j] = r[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//被调整结点位于结点j的位置</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212231822114.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span><span class="comment">//约定俗成，从1开始，n是长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">Sift</span>(r, i, n); <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r[<span class="number">0</span>] = r[<span class="number">1</span>];</span><br><span class="line">        r[<span class="number">1</span>] = r[n - i + <span class="number">1</span>];</span><br><span class="line">        r[n - i + <span class="number">1</span>] = r[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Sift</span>(r, <span class="number">1</span>, n - i); <span class="comment">// 重建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把最大的元素调整到根节点后交换</li>
<li>时间复杂度：O(nlog2n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212233855835.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort1</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort1</span>(first, mid);</span><br><span class="line">        <span class="built_in">MergeSort1</span>(mid + <span class="number">1</span>, last);</span><br><span class="line">        <span class="built_in">Merge</span>(first, mid, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212233347343.png" alt="步骤"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergePass</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">2</span> * h &lt;= length) <span class="comment">// 有两个长度为h的子序列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(i, i + h - <span class="number">1</span>, i + <span class="number">2</span> * h - <span class="number">1</span>);</span><br><span class="line">        i = i + <span class="number">2</span> * h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + h &lt; length) <span class="comment">// 两个子序列一个长度小于h</span></span><br><span class="line">        <span class="built_in">Merge</span>(i, i + h - <span class="number">1</span>, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>; <span class="comment">// 初始时子序列长度为1</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MergePass</span>(h); <span class="comment">// 一趟归并排序</span></span><br><span class="line">        h = <span class="number">2</span> * h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> first1, <span class="type">int</span> last1, <span class="type">int</span> last2)</span><span class="comment">//起始点，第一个终点，第二个终点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[length];<span class="comment">//暂存数组</span></span><br><span class="line">    <span class="type">int</span> i = first1, j = last1 + <span class="number">1</span>, k = first1;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= last1 &amp;&amp; j &lt;= last2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &lt;= data[j])<span class="comment">//谁小先放谁</span></span><br><span class="line">            temp[k++] = data[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= last1)<span class="comment">//谁没走完就把剩下的放进去</span></span><br><span class="line">        temp[k++] = data[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= last2)</span><br><span class="line">        temp[k++] = data[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = first1; i &lt;= last2; i++)<span class="comment">//暂存数组数据同步</span></span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不断划分，最后交替检测合并</li>
<li>时间复杂度：O(nlog2n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<h3 id="各算法性能比较"><a href="#各算法性能比较" class="headerlink" title="各算法性能比较"></a>各算法性能比较</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212235033886.png" alt="时间复杂度"></p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p><img src="/images/%E7%AE%97%E6%B3%95/image-20221212235055690.png" alt="空间复杂度"></p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul>
<li>稳定：包括直接插入排序、起泡排序和归并排序</li>
<li>不稳定：包括希尔排序、简单选择排序、快速排序和堆排序</li>
</ul>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><ul>
<li>简单算法：包括直接插入排序、简单选择排序和起泡排序</li>
<li>改进算法，较复杂：包括希尔排序、堆排序、快速排序和归并排序</li>
</ul>
<h2 id="附录——数据结构的实现"><a href="#附录——数据结构的实现" class="headerlink" title="附录——数据结构的实现"></a>附录——数据结构的实现</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GCD1</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span><span class="comment">//非递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = m % n;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m = n;</span><br><span class="line">        n = r;</span><br><span class="line">        r = m % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>();</span><br><span class="line">    <span class="built_in">SeqList</span>(DataType a[], <span class="type">int</span> n);</span><br><span class="line">    ~<span class="built_in">SeqList</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DataType <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, DataType x)</span></span>;</span><br><span class="line">    <span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">SeqList&lt;DataType&gt;::<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">SeqList&lt;DataType&gt;::<span class="built_in">SeqList</span>(DataType a[], <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; MaxSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;参数非法&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        data[i] = a[i];</span><br><span class="line">    length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;DataType&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;DataType&gt;::<span class="built_in">Length</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType SeqList&lt;DataType&gt;::<span class="built_in">Get</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> &amp;&amp; i &gt; length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;查找位置非法&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;DataType&gt;::<span class="built_in">Locate</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="keyword">if</span> (data[i] == x)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回其序号i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;DataType&gt;::<span class="built_in">Insert</span>(<span class="type">int</span> i, DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == MaxSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;上溢&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;插入位置错误&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = length; j &gt;= i; j--)</span><br><span class="line">        data[j] = data[j - <span class="number">1</span>]; <span class="comment">// 第j个元素存在数组下标为j-1处</span></span><br><span class="line">    data[i - <span class="number">1</span>] = x;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>();</span><br><span class="line">    <span class="built_in">LinkList</span>(T a[], <span class="type">int</span> n);</span><br><span class="line">    ~<span class="built_in">LinkList</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, T x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">MiddleElement</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt; *first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkList&lt;T&gt;::<span class="built_in">LinkList</span>(T a[], <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*   // 尾插法</span></span><br><span class="line"><span class="comment">        first = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">        Node&lt;T&gt; *r = first;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            Node&lt;T&gt; *s = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">            s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">            r-&gt;next = s;</span></span><br><span class="line"><span class="comment">            r = s;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        r-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        first = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">        first-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 初始化一个空链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;DataType&gt; *s = <span class="literal">NULL</span>;</span><br><span class="line">            s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">            s-&gt;data = a[i];</span><br><span class="line">            s-&gt;next = first-&gt;next;</span><br><span class="line">            first-&gt;next = s; <span class="comment">// 将结点s插入到头结点之后</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkList&lt;T&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *q = first;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    p = first-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T LinkList&lt;T&gt;::<span class="built_in">Get</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = first-&gt;next;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; count &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;查找位置异常&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">Insert</span>(<span class="type">int</span> i, T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = first;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; count &lt; i - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;插入位置异常&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    p = first;</span><br><span class="line">    j = <span class="number">0</span>;                         <span class="comment">// 工作指针p初始化</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) <span class="comment">// 查找第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;删除位置异常&quot;</span>; <span class="comment">// 结点p不存在或结点p的后继结点不存在</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *q;</span><br><span class="line">        T x;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        x = q-&gt;data;       <span class="comment">// 暂存被删结点</span></span><br><span class="line">        p-&gt;next = q-&gt;next; <span class="comment">// 摘链</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt; *LinkList&lt;T&gt;::<span class="built_in">MiddleElement</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = first;</span><br><span class="line">    Node&lt;T&gt; *q = first;</span><br><span class="line">    <span class="keyword">while</span> (q)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rerverse</span><span class="params">(Node&lt;T&gt; *first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node&lt;T&gt; *p, *u;</span><br><span class="line">    p = first-&gt;next;</span><br><span class="line">    first-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        u = p-&gt;next;</span><br><span class="line">        p-&gt;next = first-&gt;next;</span><br><span class="line">        first-&gt;next = p;</span><br><span class="line">        p = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">Node&lt;T&gt; *<span class="title">Copy</span><span class="params">(Node&lt;T&gt; *first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node&lt;T&gt; *p, *r, *head, *s;</span><br><span class="line">    head = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    p = first-&gt;next;</span><br><span class="line">    r = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        s-&gt;data = p-&gt;data;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> StackSize = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqStack</span>();            <span class="comment">// 构造函数，栈的初始化</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>();           <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(DataType x)</span></span>; <span class="comment">// 将元素x入栈</span></span><br><span class="line">    <span class="function">DataType <span class="title">Pop</span><span class="params">()</span></span>;        <span class="comment">// 将栈顶元素弹出</span></span><br><span class="line">    <span class="function">DataType <span class="title">GetTop</span><span class="params">()</span></span>;     <span class="comment">// 取栈顶元素（并不删除）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Empty</span><span class="params">()</span></span>;           <span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType data[StackSize]; <span class="comment">// 存放栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> top;                  <span class="comment">// 栈顶指针，指示栈顶元素在数组中的下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">SeqStack&lt;DataType&gt;::<span class="built_in">SeqStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">SeqStack&lt;DataType&gt;::~<span class="built_in">SeqStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;DataType&gt;::<span class="built_in">Push</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == StackSize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;上溢&quot;</span>;</span><br><span class="line">    top++;</span><br><span class="line">    data[top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType SeqStack&lt;DataType&gt;::<span class="built_in">Pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DataType x;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;下溢&quot;</span>;</span><br><span class="line">    x = data[top--];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType SeqStack&lt;DataType&gt;::<span class="built_in">GetTop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqStack&lt;DataType&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链栈-1"><a href="#链栈-1" class="headerlink" title="链栈"></a>链栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*构造函数*/</span></span><br><span class="line">    <span class="built_in">LinkStack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        top = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*析构函数*/</span></span><br><span class="line">    ~<span class="built_in">LinkStack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*遍历移除节点*/</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;T&gt; *n = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*入栈*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node&lt;T&gt; *n = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        n-&gt;Data = data;</span><br><span class="line">        n-&gt;next = top;</span><br><span class="line">        top = n;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*出栈*/</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;No element&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;T&gt; *n = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            T data = n-&gt;Data;</span><br><span class="line">            <span class="keyword">delete</span> n;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取栈顶元素*/</span></span><br><span class="line">    <span class="function">T <span class="title">getTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;No element&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> top-&gt;Data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*是否为空*/</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!count)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*遍历所有元素*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;All elements:&quot;</span>;</span><br><span class="line">        Node&lt;T&gt; *n = top;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; n-&gt;Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            n = n-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取元素数量*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*逆置栈*/</span></span><br><span class="line">    <span class="function">LinkStack&lt;T&gt; *<span class="title">Reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkStack&lt;T&gt; *ls = <span class="keyword">new</span> LinkStack&lt;T&gt;;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ls-&gt;<span class="built_in">push</span>(<span class="built_in">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; *top;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列-1"><a href="#循环队列-1" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> QueueSize = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CirQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CirQueue</span>();</span><br><span class="line">    ~<span class="built_in">CirQueue</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(DataType x)</span></span>;</span><br><span class="line">    <span class="function">DataType <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DataType <span class="title">GetQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType data[QueueSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">CirQueue&lt;DataType&gt;::<span class="built_in">CirQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    front = rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">int</span> CirQueue&lt;DataType&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear == front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> CirQueue&lt;DataType&gt;::<span class="built_in">EnQueue</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((rear + <span class="number">1</span>) % QueueSize == front)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;上溢&quot;</span>;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % QueueSize; <span class="comment">// 队尾指针在循环意义下加1</span></span><br><span class="line">    data[rear] = x;                <span class="comment">// 在队尾处插入元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">DataType CirQueue&lt;DataType&gt;::<span class="built_in">DeQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear == front)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;下溢&quot;</span>;</span><br><span class="line">    front = (front + <span class="number">1</span>) % QueueSize; <span class="comment">// 队头指针在循环意义下加1</span></span><br><span class="line">    <span class="keyword">return</span> data[front];              <span class="comment">// 读取并返回出队前的队头元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链队列-1"><a href="#链队列-1" class="headerlink" title="链队列"></a>链队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkQueue</span>();              <span class="comment">// 构造函数，初始化一个空的链队列</span></span><br><span class="line">    ~<span class="built_in">LinkQueue</span>();             <span class="comment">// 析构函数，释放链队列中各结点的存储空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(DataType x)</span></span>; <span class="comment">// 将元素x入队</span></span><br><span class="line">    <span class="function">DataType <span class="title">DeQueue</span><span class="params">()</span></span>;       <span class="comment">// 将队头元素出队</span></span><br><span class="line">    <span class="function">DataType <span class="title">GetQueue</span><span class="params">()</span></span>;      <span class="comment">// 取链队列的队头元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Empty</span><span class="params">()</span></span>;              <span class="comment">// 判断链队列是否为空</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;DataType&gt; *front, *rear; <span class="comment">// 队头和队尾指针，分别指向头结点和终端结点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">LinkQueue&lt;DataType&gt;::<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    front = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">    front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rear = front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">LinkQueue&lt;DataType&gt;::~<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (front != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;DataType&gt; *q = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkQueue&lt;DataType&gt;::<span class="built_in">EnQueue</span>(DataType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;DataType&gt; *s;</span><br><span class="line">    s = <span class="keyword">new</span> Node&lt;DataType&gt;;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rear-&gt;next = s;</span><br><span class="line">    rear = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType LinkQueue&lt;DataType&gt;::<span class="built_in">DeQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear == front)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;下溢&quot;</span>;</span><br><span class="line">    Node&lt;DataType&gt; *p = front-&gt;next;</span><br><span class="line">    DataType x = p-&gt;data;</span><br><span class="line">    front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        rear = front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType LinkQueue&lt;DataType&gt;::<span class="built_in">GetQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front != rear)</span><br><span class="line">        <span class="keyword">return</span> front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">int</span> LinkQueue&lt;DataType&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 假定树的元素类型为char型</span></span><br><span class="line">    TNode *firstchild, *rightsib;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tree</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Tree</span>() &#123; <span class="built_in">Release</span>(root); &#125; <span class="comment">// 析构函数，释放各结点的存储空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">()</span> </span>&#123; <span class="built_in">PreOrder</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">()</span> </span>&#123; <span class="built_in">PostOrder</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Depth</span>(root); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TNode *root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TNode *bt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TNode *bt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(TNode *bt)</span></span>; <span class="comment">// 析构函数的调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(TNode *bt)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Tree::<span class="built_in">Tree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    TNode *Q[Max] = &#123;<span class="literal">NULL</span>&#125;; <span class="comment">// TNode型的数组指针</span></span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">&#x27;#&#x27;</span>, ch2 = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    TNode *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入根结点：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch1;</span><br><span class="line">    p = <span class="keyword">new</span> TNode;</span><br><span class="line">    p-&gt;data = ch1;</span><br><span class="line">    p-&gt;firstchild = p-&gt;rightsib = <span class="literal">NULL</span>;</span><br><span class="line">    root = p;      <span class="comment">// 建立根结点</span></span><br><span class="line">    Q[++rear] = p; <span class="comment">// 根结点入队</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入结点对，以空格分隔：&quot;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdin); <span class="comment">// 清空键盘缓冲区</span></span><br><span class="line">    ch1 = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    ch2 = <span class="built_in">getchar</span>();                 <span class="comment">// 中间getchar注释掉中间的空格 ch1是父结点 ch2是孩子结点</span></span><br><span class="line">    <span class="keyword">while</span> (ch1 != <span class="string">&#x27;#&#x27;</span> || ch2 != <span class="string">&#x27;#&#x27;</span>) <span class="comment">// 输入结束的条件是有序对（# #）</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> TNode;</span><br><span class="line">        p-&gt;data = ch2;</span><br><span class="line">        p-&gt;firstchild = p-&gt;rightsib = <span class="literal">NULL</span>;</span><br><span class="line">        Q[++rear] = p;        <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">while</span> (front != rear) <span class="comment">// 当队列非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = Q[front + <span class="number">1</span>];   <span class="comment">// 取队头元素，存储为q</span></span><br><span class="line">            <span class="keyword">if</span> (q-&gt;data != ch1) <span class="comment">// 当队头元素不是有序对的第一个字符</span></span><br><span class="line">                front++;        <span class="comment">// 出队</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (q-&gt;firstchild == <span class="literal">NULL</span>)</span><br><span class="line">                    q-&gt;firstchild = p; <span class="comment">// 设置结点p是结点q的第一个孩子</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q = q-&gt;firstchild;</span><br><span class="line">                    <span class="keyword">while</span> (q-&gt;rightsib != <span class="literal">NULL</span>) <span class="comment">// 查找结点q的最右兄弟</span></span><br><span class="line">                        q = q-&gt;rightsib;</span><br><span class="line">                    q-&gt;rightsib = p; <span class="comment">// 设置结点p为结点q的右兄弟</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入结点对，以空格分隔：&quot;</span>;</span><br><span class="line">        <span class="built_in">fflush</span>(stdin);</span><br><span class="line">        ch1 = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        ch2 = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::Release</span><span class="params">(TNode *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 递归调用的结束条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;firstchild); <span class="comment">// 后序递归释放bt的第一棵子树</span></span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;rightsib);   <span class="comment">// 后序递归释放bt的右兄弟子树</span></span><br><span class="line">        <span class="keyword">delete</span> bt;               <span class="comment">// 释放根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::PreOrder</span><span class="params">(TNode *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 递归调用的结束条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bt-&gt;data;         <span class="comment">// 访问根结点的数据域</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(bt-&gt;firstchild); <span class="comment">// 前序递归遍历root的第一棵子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(bt-&gt;rightsib);   <span class="comment">// 前序递归遍历root的右兄弟子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::PostOrder</span><span class="params">(TNode *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 递归调用的结束条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(bt-&gt;firstchild); <span class="comment">// 前序递归遍历root的第一棵子树</span></span><br><span class="line">        cout &lt;&lt; bt-&gt;data;          <span class="comment">// 访问根结点的数据域</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(bt-&gt;rightsib);   <span class="comment">// 前序递归遍历root的右兄弟子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Tree::Depth</span><span class="params">(TNode *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> LDepth, RDepth;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LDepth = <span class="built_in">Depth</span>(bt-&gt;firstchild);</span><br><span class="line">        RDepth = <span class="built_in">Depth</span>(bt-&gt;rightsib);</span><br><span class="line">        <span class="comment">// return LDepth&gt;=RDepth?LDepth+1:RDepth;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(LDepth + <span class="number">1</span>, RDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiNode</span> <span class="comment">// 二叉树的结点结构</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    BiNode&lt;DataType&gt; *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// CountLeaf1: 方法一求叶子个数统计</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BiTree</span>() &#123; root = <span class="built_in">Creat</span>(root); &#125;                        <span class="comment">// 构造函数，建立一棵二叉树</span></span><br><span class="line">    ~<span class="built_in">BiTree</span>() &#123; <span class="built_in">Release</span>(root); &#125;                            <span class="comment">// 析构函数，释放各结点的存储空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">()</span> </span>&#123; <span class="built_in">PreOrder</span>(root); &#125;                     <span class="comment">// 前序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">()</span> </span>&#123; <span class="built_in">InOrder</span>(root); &#125;                       <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">()</span> </span>&#123; <span class="built_in">PostOrder</span>(root); &#125;                   <span class="comment">// 后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LeverOrder</span><span class="params">()</span></span>;                                      <span class="comment">// 层序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CountLeaf1</span><span class="params">()</span> </span>&#123; <span class="built_in">CountLeaf1</span>(root); &#125;                 <span class="comment">// 方法一 递归</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CountLeaf2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">CountLeaf2</span>(root) &lt;&lt; endl; &#125; <span class="comment">// 方法二 非递归</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BiNode&lt;<span class="type">char</span>&gt; *root;                    <span class="comment">// 指向根结点的头指针</span></span><br><span class="line">    <span class="function">BiNode&lt;<span class="type">char</span>&gt; *<span class="title">Creat</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>; <span class="comment">// 构造函数调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>;        <span class="comment">// 析构函数调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>;       <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>;        <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>;      <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LeverOrder</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>;     <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CountLeaf1</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CountLeaf2</span><span class="params">(BiNode&lt;<span class="type">char</span>&gt; *bt)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">BiNode&lt;<span class="type">char</span>&gt; *BiTree&lt;DataType&gt;::<span class="built_in">Creat</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入创建一棵二叉树的结点数据&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt = <span class="keyword">new</span> BiNode&lt;<span class="type">char</span>&gt;; <span class="comment">// 生成一个结点</span></span><br><span class="line">        bt-&gt;data = ch;</span><br><span class="line">        bt-&gt;lchild = <span class="built_in">Creat</span>(bt-&gt;lchild); <span class="comment">// 递归建立左子树</span></span><br><span class="line">        bt-&gt;rchild = <span class="built_in">Creat</span>(bt-&gt;rchild); <span class="comment">// 递归建立右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;::<span class="built_in">Release</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;lchild); <span class="comment">// 释放左子树</span></span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;rchild); <span class="comment">// 释放右子树</span></span><br><span class="line">        <span class="keyword">delete</span> bt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;::<span class="built_in">PreOrder</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bt-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrder</span>(bt-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrder</span>(bt-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;::<span class="built_in">InOrder</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 递归调用的结束条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;lchild);     <span class="comment">// 中序递归遍历root的左子树</span></span><br><span class="line">        cout &lt;&lt; bt-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问根结点的数据域</span></span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;rchild);     <span class="comment">// 中序递归遍历root的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;::<span class="built_in">PostOrder</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 递归调用的结束条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(bt-&gt;lchild);   <span class="comment">// 后序递归遍历root的左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(bt-&gt;rchild);   <span class="comment">// 后序递归遍历root的右子树</span></span><br><span class="line">        cout &lt;&lt; bt-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问根结点的数据域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;::<span class="built_in">LeverOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">// 采用顺序队列，并假定不会发生上溢</span></span><br><span class="line">    BiNode&lt;<span class="type">char</span>&gt; *Q[MaxSize], *q;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q[rear++] = root;</span><br><span class="line">        <span class="keyword">while</span> (front != rear)</span><br><span class="line">        &#123;</span><br><span class="line">            q = Q[front++];</span><br><span class="line">            cout &lt;&lt; q-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">                Q[rear++] = q-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                Q[rear++] = q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;::<span class="built_in">CountLeaf1</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="built_in">CountLeaf1</span>(bt-&gt;lchild);</span><br><span class="line">        <span class="built_in">CountLeaf1</span>(bt-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">int</span> BiTree&lt;DataType&gt;::<span class="built_in">CountLeaf2</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line">    BiNode&lt;<span class="type">char</span>&gt; *S[MaxSize];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bt != <span class="literal">NULL</span> || top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                count++;</span><br><span class="line">            S[++top] = bt;</span><br><span class="line">            bt = bt-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bt = S[top--];</span><br><span class="line">            bt = bt-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;::<span class="built_in">LeverOrder</span>(BiNode&lt;<span class="type">char</span>&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    BiNode&lt;<span class="type">char</span>&gt; *Q[<span class="number">100</span>], *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Q[++rear] = bt;</span><br><span class="line">    <span class="keyword">while</span> (front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        q = Q[++front];</span><br><span class="line">        cout &lt;&lt; q-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            Q[++rear] = q-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            Q[++rear] = q-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lowcost, adjvex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MGraph</span>(DataType a[], <span class="type">int</span> n, <span class="type">int</span> e); <span class="comment">// 构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line">    ~<span class="built_in">MGraph</span>() &#123;&#125;                        <span class="comment">// 析构函数为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>;            <span class="comment">// 深度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>;            <span class="comment">// 广度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(MGraph&lt;DataType&gt; G, <span class="type">int</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(MGraph&lt;DataType&gt; G, <span class="type">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType vertex[MaxSize];  <span class="comment">// 存放图中顶点的数组</span></span><br><span class="line">    <span class="type">int</span> arc[MaxSize][MaxSize]; <span class="comment">// 存放图中边的数组</span></span><br><span class="line">    <span class="type">int</span> vertexNum, arcNum;     <span class="comment">// 图的顶点数和边数</span></span><br><span class="line">    <span class="type">int</span> front, rear, Q[MaxSize];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">MGraph&lt;DataType&gt;::<span class="built_in">MGraph</span>(DataType a[], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    arcNum = e;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arc[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; arcNum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入边的两个顶点的序号：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        arc[i][j] = <span class="number">1</span>;</span><br><span class="line">        arc[j][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;DataType&gt;::<span class="built_in">DFSTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        <span class="keyword">if</span> (arc[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">DFSTraverse</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;DataType&gt;::<span class="built_in">BFSTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        visited[j] = <span class="number">0</span>;</span><br><span class="line">    front = rear = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    <span class="keyword">while</span> (front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        v = Q[++front];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arc[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinEdge</span><span class="params">(<span class="type">int</span> lowcost[], <span class="type">int</span> vNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; vNum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowcost[v] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index = v;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = v + <span class="number">1</span>; v &lt; vNum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowcost[v] &gt; <span class="number">0</span> &amp;&amp; lowcost[v] &lt; lowcost[index])</span><br><span class="line">            index = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;DataType&gt;::<span class="built_in">Prim</span>(MGraph&lt;DataType&gt; G, <span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lowcost[MaxSize];                 <span class="comment">// 最短边数组</span></span><br><span class="line">    <span class="type">int</span> adjvex[MaxSize];                  <span class="comment">// 最短边邻接的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++) <span class="comment">// 初始化辅助数组shortEdge</span></span><br><span class="line">    &#123;</span><br><span class="line">        lowcost[i] = G-&gt;arc[v][i]; <span class="comment">// 到达i的最短路径设置为v到i的距离（可能不存在）</span></span><br><span class="line">        adjvex[i] = v;             <span class="comment">// 初始化，没有意义</span></span><br><span class="line">    &#125;</span><br><span class="line">    lowcost[v] = <span class="number">0</span>; <span class="comment">// 开始前，把自己的点的最短边距设成0</span></span><br><span class="line">    <span class="comment">// 正式开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; G.vertexNum; i++) <span class="comment">// 自己找完了，剩下的找vertexNum-1轮就够</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">MinEdge</span>(lowcost, G.vertexNum); <span class="comment">// 寻找最短边的邻接点k</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; adjvex[k] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; lowcost[k] &lt;&lt; endl;</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;                       <span class="comment">// 已经包括顶点k，最短距离设置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vertexNum; j++) <span class="comment">// 以k为起点遍历他的所有边</span></span><br><span class="line">            <span class="keyword">if</span> (G.arc[k][j] &lt; lowcost[j])     <span class="comment">// 如果从k到j有比lowcost里记录的更短（有更短的距离能到j）</span></span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = G.arc[k][j]; <span class="comment">// 更新lowcost</span></span><br><span class="line">                adjvex[j] = k;            <span class="comment">// 把自己设置成目标顶点的邻接点</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;DataType&gt;::<span class="built_in">Dijkstra</span>(MGraph&lt;DataType&gt; G, <span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dist[MaxSize];                    <span class="comment">// 到达对应顶点的最小距离</span></span><br><span class="line">    string path[MaxSize];                 <span class="comment">// 路径</span></span><br><span class="line">    <span class="function">string <span class="title">vertex</span><span class="params">(G.vertex)</span></span>;              <span class="comment">// 存放对应顶点的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++) <span class="comment">// 对于每一个顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = G.arc[v][i]; <span class="comment">// 第一轮，初始化到达对应顶点的距离（是目标点到各顶点的距离）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[i] != <span class="number">255</span>) <span class="comment">// 如果距离小于255（是通路）</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[i] += vertex[v]; <span class="comment">// 起点是v</span></span><br><span class="line">            path[i] += vertex[i]; <span class="comment">// 路径囊括进来的第一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i] = <span class="string">&quot;&quot;</span>; <span class="comment">// 否则置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[v] = <span class="number">0</span>; <span class="comment">// 到自己的距离为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">1</span>; num &lt; G.vertexNum; num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">255</span>; <span class="comment">// 最短的边</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;     <span class="comment">// 未到达区域里路径最短的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++)</span><br><span class="line">        &#123;                                          <span class="comment">// 寻找最短边和下一个目标点</span></span><br><span class="line">            <span class="keyword">if</span> ((dist[i] != <span class="number">0</span>) &amp;&amp; (dist[i] &lt; min)) <span class="comment">// 未到达且是通路</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; path[k] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dist[k] &lt;&lt; <span class="string">&quot;;&quot;</span> &lt;&lt; endl; <span class="comment">// 找到了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vertexNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &gt; dist[k] + G.arc[k][i]) <span class="comment">// 以找到的目标点为基础向外辐射，如果经过他后到达别的顶点的距离更短</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[i] = dist[k] + G.arc[k][i]; <span class="comment">// 更新到对应点的最短距离为过目标点再到对应点</span></span><br><span class="line">                <span class="comment">// 更新路径字符串</span></span><br><span class="line">                path[i] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                path[i] += path[k];</span><br><span class="line">                path[i] += vertex[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dist[k] = <span class="number">0</span>; <span class="comment">// 目标点到达自身的距离为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">// 顶点的数组下标</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 权值</span></span><br><span class="line">    EdgeNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> in; <span class="comment">// 顶点的入度，用在拓补排序</span></span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode *firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ALGraph</span>(DataType a[], <span class="type">int</span> n, <span class="type">int</span> e);</span><br><span class="line">    ~<span class="built_in">ALGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TopSort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VertexNode&lt;DataType&gt; adjlist[MaxSize];</span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt;::<span class="built_in">ALGraph</span>(DataType a[], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    EdgeNode *s = <span class="literal">NULL</span>;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">// 输入顶点信息，初始化顶点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">// 依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j; <span class="comment">// 输入边所依附的两个顶点的编号</span></span><br><span class="line">        s = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        s-&gt;adjvex = j;                  <span class="comment">// 生成一个边表结点s</span></span><br><span class="line">        s-&gt;next = adjlist[i].firstEdge; <span class="comment">// 将结点s插入到第i个边表的表头</span></span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt;::~<span class="built_in">ALGraph</span>()</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = q = adjlist[i].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt;::<span class="built_in">DFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    p = adjlist[v].firstEdge;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        j = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[j] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">DFTraverse</span>(j);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt;::<span class="built_in">BFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, j, Q[MaxSize];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    <span class="keyword">while</span> (front != rear)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        p = adjlist[w].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            j = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt;::<span class="built_in">TopSort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> S[MaxSize], top = <span class="number">-1</span>; <span class="comment">// 一个栈</span></span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">// 初始化，第一轮</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (adjlist[i].in == <span class="number">0</span>)</span><br><span class="line">            S[++top] = i; <span class="comment">// 没有入度的顶点入栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>) <span class="comment">// 栈不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = S[top--]; <span class="comment">// 取栈顶</span></span><br><span class="line">        count++;      <span class="comment">// 有多少个顶点被排序</span></span><br><span class="line">        cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">        p = adjlist[j].first; <span class="comment">// 出栈顶点指向的后继节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = p-&gt;adjvex;          <span class="comment">// 被指向的后继节点</span></span><br><span class="line">            adjlist[k].in--;        <span class="comment">// 他的前驱节点出栈了（拿走了），后继节点入度-1</span></span><br><span class="line">            <span class="keyword">if</span> (adjlist[k].in == <span class="number">0</span>) <span class="comment">// 如果这个后继节点的入度为0</span></span><br><span class="line">                S[++top] = k;       <span class="comment">// 入栈</span></span><br><span class="line">            p = p-&gt;next;            <span class="comment">// 查询出栈元素的下一个后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; vertexNum) <span class="comment">// 循环一遍，所有能被拿掉元素都被拿掉，如果拿掉的个数比总顶点个数少</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有回路&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 获取度数</span></span><br><span class="line"><span class="comment">void GetAdjvex()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    EdgeNode *p = adjlist[v].firstEdge;</span></span><br><span class="line"><span class="comment">    count = 0;</span></span><br><span class="line"><span class="comment">    while (p != NULL)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        count++;</span></span><br><span class="line"><span class="comment">        p = p-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 获取邻接的顶点</span></span><br><span class="line"><span class="comment">void GetAdjvex()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    EdgeNode *p = adjlist[v].firstEdge;</span></span><br><span class="line"><span class="comment">    while (p != NULL)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        j = p-&gt;adjvex; // j是v的邻接点</span></span><br><span class="line"><span class="comment">        p = p-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（用于最小生成树的）带权图"><a href="#（用于最小生成树的）带权图" class="headerlink" title="（用于最小生成树的）带权图"></a>（用于最小生成树的）带权图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxVertex = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxEdge = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from, to;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EdgeGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EdgeGraph</span>(DataType a[], <span class="type">int</span> n, <span class="type">int</span> e);</span><br><span class="line">    ~<span class="built_in">EdgeGraph</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(EdgeGraph&lt;DataType&gt; G)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindRoot</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> v)</span></span>;</span><br><span class="line">    DataType vertex[MaxVertex];</span><br><span class="line">    EdgeType edge[MaxEdge];</span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">EdgeGraph&lt;DataType&gt;::<span class="built_in">EdgeGraph</span>(DataType a[], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, l;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">// 输入顶点信息，初始化顶点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">// 按从小到大的顺序依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j &gt;&gt; l;</span><br><span class="line">        edge[k].from = i;</span><br><span class="line">        edge[k].to = j;</span><br><span class="line">        edge[k].weight = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindRoot</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = v;</span><br><span class="line">    <span class="keyword">while</span> (parent[t] &gt; <span class="number">-1</span>)</span><br><span class="line">        t = parent[t];</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> EdgeGraph&lt;DataType&gt;::<span class="built_in">Kruskal</span>(EdgeGraph&lt;DataType&gt; G)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, num = <span class="number">0</span>, vex1, vex2;</span><br><span class="line">    <span class="type">int</span> parent[vertexNum]; <span class="comment">// 顶点的双亲</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = <span class="number">-1</span>; <span class="comment">// 初始化，所有节点都是独立的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (num = <span class="number">0</span>, i = <span class="number">0</span>; num &lt; G-&gt;vertexNum; i++) <span class="comment">// 对于每一条边（从小到大）</span></span><br><span class="line">    &#123;</span><br><span class="line">        vex1 = <span class="built_in">FindRoot</span>(parent, G-&gt;edge[i].from);</span><br><span class="line">        vex2 = <span class="built_in">FindRoot</span>(parent, G-&gt;edge[i].to);</span><br><span class="line">        <span class="keyword">if</span> (vex1 != vex2) <span class="comment">// 没有同一个根节点，不在同一组里</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)%d &quot;</span>, G-&gt;edge[i].from, G-&gt;edge[i].to, G-&gt;edge[i].weight);</span><br><span class="line">            parent[vex2] = vex1; <span class="comment">// 设置终点的双亲节点为起点，加入同一组</span></span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常规查找算法"><a href="#常规查找算法" class="headerlink" title="常规查找算法"></a>常规查找算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SeqSearch</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n, <span class="type">int</span> k)</span> <span class="comment">// 从数组下标1开始存放待查元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = n;</span><br><span class="line">    r[<span class="number">0</span>] = k; <span class="comment">// 下标0用作监视哨，算法会在0的时候出循环，省去判断数组越界</span></span><br><span class="line">    <span class="keyword">while</span> (r[i] != k)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 返回0就是没找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 折半查找</span></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n, <span class="type">int</span> k)</span> <span class="comment">// 从数组下标1开始存放待查集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>, high = n; <span class="comment">// 设置待查区间</span></span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) <span class="comment">// 这个区间里还有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; r[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>; <span class="comment">// 比mid小，区间肯定在1~mid-1中间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; r[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">// 比mid大，区间肯定在mid+1~n中间</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 找到了，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="type">int</span> data[MaxSize + <span class="number">1</span>]; <span class="comment">// 外部数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch2</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; data[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(low, mid - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; data[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(mid + <span class="number">1</span>, high, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">/*查找成功，返回序号*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树-1"><a href="#二叉排序树-1" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BiSortTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BiSortTree</span>(<span class="type">int</span> a[], <span class="type">int</span> n);</span><br><span class="line">    ~<span class="built_in">BiSortTree</span>() &#123; <span class="built_in">Release</span>(root); &#125;</span><br><span class="line">    <span class="function">BiNode&lt;<span class="type">int</span>&gt; *<span class="title">InsertBST</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">InsertBST</span>(root, x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeleteBST</span><span class="params">(BiNode&lt;<span class="type">int</span>&gt; *p, BiNode&lt;<span class="type">int</span>&gt; *f)</span></span>;</span><br><span class="line">    <span class="function">BiNode&lt;<span class="type">int</span>&gt; *<span class="title">SearchBST</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">SearchBST</span>(root, k); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BiNode&lt;<span class="type">int</span>&gt; *<span class="title">InsertBST</span><span class="params">(BiNode&lt;<span class="type">int</span>&gt; *bt, <span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function">BiNode&lt;<span class="type">int</span>&gt; *<span class="title">SearchBST</span><span class="params">(BiNode&lt;<span class="type">int</span>&gt; *bt, <span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;<span class="type">int</span>&gt; *bt)</span></span>;</span><br><span class="line">    BiNode&lt;<span class="type">int</span>&gt; *root;</span><br><span class="line">&#125;;</span><br><span class="line">BiNode&lt;<span class="type">int</span>&gt; *BiSortTree ::<span class="built_in">SearchBST</span>(BiNode&lt;<span class="type">int</span>&gt; *bt, <span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (bt-&gt;data == k)</span><br><span class="line">        <span class="keyword">return</span> bt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;data &gt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(bt-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(bt-&gt;rchild, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiNode&lt;<span class="type">int</span>&gt; *<span class="title">BiSortTree::InsertBST</span><span class="params">(BiNode&lt;<span class="type">int</span>&gt; *bt, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BiNode&lt;<span class="type">int</span>&gt; *s = <span class="keyword">new</span> BiNode&lt;<span class="type">int</span>&gt;;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        bt = s;</span><br><span class="line">        <span class="keyword">return</span> bt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;data &gt; x)</span><br><span class="line">        bt-&gt;lchild = <span class="built_in">InsertBST</span>(bt-&gt;lchild, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bt-&gt;rchild = <span class="built_in">InsertBST</span>(bt-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line">BiSortTree::<span class="built_in">BiSortTree</span>(<span class="type">int</span> a[], <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        root = <span class="built_in">InsertBST</span>(root, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiSortTree::DeleteBST</span><span class="params">(BiNode&lt;<span class="type">int</span>&gt; *p, BiNode&lt;<span class="type">int</span>&gt; *f)</span> <span class="comment">// 双亲是f,待删是p,p是f的左孩子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;lchild == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;rchild == <span class="literal">NULL</span>)) <span class="comment">// p为叶子</span></span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;lchild = <span class="literal">NULL</span>; <span class="comment">// 将双亲结点中相应指针域的值改为空</span></span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将双亲结点中相应指针域指向被删除结点的左子树（或右子树）*/</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// p只有左子树</span></span><br><span class="line">        f-&gt;lchild = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// p只有右子树</span></span><br><span class="line">        f-&gt;lchild = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*查找左子树的最右下结点*/</span></span><br><span class="line">    BiNode&lt;<span class="type">int</span>&gt; *par = p, *s = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;rchild != <span class="literal">NULL</span>) <span class="comment">// 一直找左子树里最大的</span></span><br><span class="line">    &#123;</span><br><span class="line">        par = s;</span><br><span class="line">        s = s-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data = s-&gt;data; <span class="comment">// 把他的数据替换到待删节点</span></span><br><span class="line">    <span class="keyword">if</span> (par == p)      <span class="comment">// 如果左子树中的最大值结点是被删结点的孩子</span></span><br><span class="line">        par-&gt;lchild = s-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par-&gt;rchild = s-&gt;lchild;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭散列表的线性探测"><a href="#闭散列表的线性探测" class="headerlink" title="闭散列表的线性探测"></a>闭散列表的线性探测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">HashSearch</span><span class="params">(<span class="type">int</span> ht[], <span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> &amp;j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    j = k % m; <span class="comment">// 计算散列地址</span></span><br><span class="line">    <span class="keyword">if</span> (ht[j] == k)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 没发生冲突，比较一次成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ht[j] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ht[j] = k;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;                <span class="comment">// 查找不成功，插入</span></span><br><span class="line">    i = (j + <span class="number">1</span>) % m; <span class="comment">// 设置探测的其实下标</span></span><br><span class="line">    <span class="keyword">while</span> (ht[i] != <span class="number">0</span> &amp;&amp; i != j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] == k) <span class="comment">// 比较若干次，成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = (i + <span class="number">1</span>) % m; <span class="comment">// 向后探测一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;溢出&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 查找不成功，插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        ht[i] = k;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable1</span>();</span><br><span class="line">    ~<span class="built_in">HashTable1</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ht[MaxSize];</span><br><span class="line">&#125;;</span><br><span class="line">HashTable1 ::<span class="built_in">HashTable1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        ht[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">HashTable1 ::~<span class="built_in">HashTable1</span>() &#123;&#125;</span><br><span class="line"><span class="type">int</span> HashTable1 ::<span class="built_in">Search</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j = k % MaxSize; <span class="comment">// 计算散列地址</span></span><br><span class="line">    i = j;                  <span class="comment">// 设置比较的起始位置</span></span><br><span class="line">    <span class="keyword">while</span> (ht[i] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ht[i] == k)</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 查找成功</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = (i + <span class="number">1</span>) % MaxSize; <span class="comment">// 向后探测一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开散列表的拉链法"><a href="#开散列表的拉链法" class="headerlink" title="开散列表的拉链法"></a>开散列表的拉链法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable2</span>();</span><br><span class="line">    ~<span class="built_in">HashTable2</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function">Node&lt;<span class="type">int</span>&gt; *<span class="title">Search</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;<span class="type">int</span>&gt; *ht[MaxSize];</span><br><span class="line">&#125;;</span><br><span class="line">HashTable2 ::~<span class="built_in">HashTable2</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;<span class="type">int</span>&gt; *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = q = ht[i];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> HashTable2 ::<span class="built_in">Insert</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = k % MaxSize;</span><br><span class="line">    Node&lt;<span class="type">int</span>&gt; *p = ht[j];</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;<span class="type">int</span>&gt; *q = <span class="keyword">new</span> Node&lt;<span class="type">int</span>&gt;;</span><br><span class="line">        q-&gt;data = k;</span><br><span class="line">        q-&gt;next = ht[j];</span><br><span class="line">        ht[j] = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;<span class="type">int</span>&gt; *HashTable2 ::<span class="built_in">Search</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = k % MaxSize;</span><br><span class="line">    Node&lt;<span class="type">int</span>&gt; *p = ht[j];</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == k)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> HashTable2 ::<span class="built_in">Delete</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = k % MaxSize;</span><br><span class="line">    Node&lt;<span class="type">int</span>&gt; *p = ht[j], *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;data != k))</span><br><span class="line">    &#123;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">            ht[j] = p-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一众排序算法"><a href="#一众排序算法" class="headerlink" title="一众排序算法"></a>一众排序算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; length; i++) <span class="comment">// 约定俗成，从1开始，但第一趟只有一个元素，不用比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        data[<span class="number">0</span>] = data[i];                 <span class="comment">// 0是暂存区</span></span><br><span class="line">        j = i - <span class="number">1</span>;                         <span class="comment">// 和最大的元素比较</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; data[<span class="number">0</span>] &lt; data[j]) <span class="comment">// 如果j&gt;0且小于最大的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            data[j + <span class="number">1</span>] = data[j]; <span class="comment">// 元素后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        data[j + <span class="number">1</span>] = data[<span class="number">0</span>]; <span class="comment">// 把暂存的元素放到腾出来的位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> <span class="comment">// n是长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = n / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d = d / <span class="number">2</span>) <span class="comment">// 以增量为d进行直接插入排序，d一般从长度的一半开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d + <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 第一组只包含每个子序列的第一个元素，不需要排序，从第二组开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            r[<span class="number">0</span>] = r[i]; <span class="comment">// 0号单元作为暂存单元</span></span><br><span class="line">            <span class="type">int</span> j = i - d;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; r[<span class="number">0</span>] &lt; r[j]) <span class="comment">// 插入排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = j - d;</span><br><span class="line">                r[j + d] = r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            r[j + d] = r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j, exchange, bound;</span><br><span class="line">    exchange = length; <span class="comment">// 第一趟起泡排序的区间是[1~length]</span></span><br><span class="line">    <span class="keyword">while</span> (exchange != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bound = exchange;</span><br><span class="line">        exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; bound; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &gt; data[j + <span class="number">1</span>]) <span class="comment">// 后面的大于前面的</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 前后交换</span></span><br><span class="line">                data[<span class="number">0</span>] = data[j];</span><br><span class="line">                data[j] = data[j + <span class="number">1</span>];</span><br><span class="line">                data[j + <span class="number">1</span>] = data[<span class="number">0</span>];</span><br><span class="line">                exchange = j; <span class="comment">// 记载每一次记录交换的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 一趟起泡排序的区间是[1~bound]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = first, j = last;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; data[i] &lt;= data[j]) <span class="comment">// 使左边的比右边小</span></span><br><span class="line">        &#123;</span><br><span class="line">            j--; <span class="comment">/*右侧扫描*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            data[<span class="number">0</span>] = data[i];</span><br><span class="line">            data[i] = data[j];</span><br><span class="line">            data[j] = data[<span class="number">0</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; data[i] &lt;= data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++; <span class="comment">/*左侧扫描*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            data[<span class="number">0</span>] = data[i];</span><br><span class="line">            data[i] = data[j];</span><br><span class="line">            data[j] = data[<span class="number">0</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 得到的是中间点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> first, <span class="type">int</span> last)</span> <span class="comment">// 约定俗成，从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">Partition</span>(data, first, last);</span><br><span class="line">        <span class="built_in">QuickSort</span>(data, first, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(data, pivot + <span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> <span class="comment">// n是长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index, j, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 约定俗成，从1开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// 在未排序区里找最小的</span></span><br><span class="line">            <span class="keyword">if</span> (r[j] &lt; r[index])</span><br><span class="line">                index = j;</span><br><span class="line">        <span class="keyword">if</span> (index != i) <span class="comment">// 如果有则与未交换区的第一个元素交换</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = r[i];</span><br><span class="line">            r[i] = r[index];</span><br><span class="line">            r[index] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sift</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> k, <span class="type">int</span> last)</span> <span class="comment">// 筛选法调整堆的算法，last是根节点编号，最后一个编号为m</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    i = k;</span><br><span class="line">    j = <span class="number">2</span> * i;        <span class="comment">// i指向被筛选结点，j指向结点i的左孩子;</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= last) <span class="comment">// 还没有进行到叶子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; last &amp;&amp; r[j] &lt; r[j + <span class="number">1</span>]) <span class="comment">// j指向左右孩子的较大者</span></span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (r[i] &gt; r[j]) <span class="comment">// 已经是堆</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// r[0]暂存，交换ij</span></span><br><span class="line">            r[<span class="number">0</span>] = r[i];</span><br><span class="line">            r[i] = r[j];</span><br><span class="line">            r[j] = r[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 被调整结点位于结点j的位置</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> <span class="comment">// 约定俗成，从1开始，n是长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">Sift</span>(r, i, n); <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r[<span class="number">0</span>] = r[<span class="number">1</span>];</span><br><span class="line">        r[<span class="number">1</span>] = r[n - i + <span class="number">1</span>];</span><br><span class="line">        r[n - i + <span class="number">1</span>] = r[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Sift</span>(r, <span class="number">1</span>, n - i); <span class="comment">// 重建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二路归并</span></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> first1, <span class="type">int</span> last1, <span class="type">int</span> last2)</span><span class="comment">//起始点，第一个终点，第二个终点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[length];<span class="comment">//暂存数组</span></span><br><span class="line">    <span class="type">int</span> i = first1, j = last1 + <span class="number">1</span>, k = first1;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= last1 &amp;&amp; j &lt;= last2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &lt;= data[j])<span class="comment">//谁小先放谁</span></span><br><span class="line">            temp[k++] = data[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= last1)<span class="comment">//谁没走完就把剩下的放进去</span></span><br><span class="line">        temp[k++] = data[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= last2)</span><br><span class="line">        temp[k++] = data[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = first1; i &lt;= last2; i++)<span class="comment">//暂存数组数据同步</span></span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort1</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort1</span>(first, mid);</span><br><span class="line">        <span class="built_in">MergeSort1</span>(mid + <span class="number">1</span>, last);</span><br><span class="line">        <span class="built_in">Merge</span>(first, mid, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergePass</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">2</span> * h &lt;= length) <span class="comment">// 有两个长度为h的子序列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Merge</span>(i, i + h - <span class="number">1</span>, i + <span class="number">2</span> * h - <span class="number">1</span>);</span><br><span class="line">        i = i + <span class="number">2</span> * h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + h &lt; length) <span class="comment">// 两个子序列一个长度小于h</span></span><br><span class="line">        <span class="built_in">Merge</span>(i, i + h - <span class="number">1</span>, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>; <span class="comment">// 初始时子序列长度为1</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MergePass</span>(h); <span class="comment">// 一趟归并排序</span></span><br><span class="line">        h = <span class="number">2</span> * h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<center>END</center>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/22/Go%E7%AC%94%E8%AE%B0/" rel="prev" title="Go笔记">
                  <i class="fa fa-chevron-left"></i> Go笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/19/%E5%85%AB%E8%82%A1_%E5%8D%9A%E5%AE%A2/" rel="next" title="个人八股整理——Unity游戏客户端">
                  个人八股整理——Unity游戏客户端 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fire Egg</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">235k</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
