<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-corner-indicator.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":true,"color":"#000","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言 本博客为个人整理，资料全数来源于互联网，囊括的知识点全数来源于牛客网的面经">
<meta property="og:type" content="article">
<meta property="og:title" content="个人八股整理——Unity游戏客户端">
<meta property="og:url" content="http://example.com/2024/05/19/%E5%85%AB%E8%82%A1_%E5%8D%9A%E5%AE%A2/index.html">
<meta property="og:site_name" content="FireEgg&#39;s Blog">
<meta property="og:description" content="前言 本博客为个人整理，资料全数来源于互联网，囊括的知识点全数来源于牛客网的面经">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTgwMTk=,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTgwMTk=,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTgwMTk=,size_16,color_FFFFFF,t_70-17141882211862.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/5f3132d640804c61bd8a969298a9c501.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/375880a888ba49d8b0c875e0660f41dd.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzAxNjI4,size_16,color_FFFFFF,t_70#pic_center.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbnNpb256,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240315003204318.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/bd3133148d8948c2bedda3e32163ce1c.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240326094342997.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240326094541191.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240326094611967.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/sort.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/v2-0aa7d503f23b86b14da16c3950696026_1440w.image">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/3972e5eb357943538773f4b2fa4f7591.jpeg">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MzQ3MzEz,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421135901412.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/v2-dd8ec43772f9025f42762bf9aa98d287_720w.webp">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/f1e2ebbae1aa1e972d02b0f7432566b8.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240327111347249.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240327100613019.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240327144436944.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240327144454345.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421114446660.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421114511663.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/SouthEast.jpeg">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/v2-900262432b5e6140f5cc4849c2cb07bb_720w.webp">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAYmFuZ3NoYW8xOTg5,size_20,color_FFFFFF,t_70,g_se,x_16.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/70.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/a420b296934a4d389c1bce542fba3929.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/62e8935571b6422a9044663ad2f24e7b.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NjU5Mg==,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240327225929341.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330205429385.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330210653926.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330211958286.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330212100375.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330212223439.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330212326112.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330215039592.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330215645807.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20230330234445873.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240327233657183.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421103853404.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/v2-bc3859883c4469f524a9add59e02264e_720w.webp">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/v2-c0e39c006e20d5f7d6859dc916c57daf_720w.webp">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421105431523.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421105516965.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421105527015.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421105601069.png">
<meta property="og:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/image-20240421105654487.png">
<meta property="article:published_time" content="2024-05-19T15:32:39.000Z">
<meta property="article:modified_time" content="2024-05-23T13:09:43.981Z">
<meta property="article:author" content="Fire Egg">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTgwMTk=,size_16,color_FFFFFF,t_70.png">


<link rel="canonical" href="http://example.com/2024/05/19/%E5%85%AB%E8%82%A1_%E5%8D%9A%E5%AE%A2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/05/19/%E5%85%AB%E8%82%A1_%E5%8D%9A%E5%AE%A2/","path":"2024/05/19/八股_博客/","title":"个人八股整理——Unity游戏客户端"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>个人八股整理——Unity游戏客户端 | FireEgg's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">FireEgg's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c"><span class="nav-number">2.</span> <span class="nav-text">c++</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%846%E4%B8%AA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">默认的6个成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">2.3.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">指针和引用的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.4.1.</span> <span class="nav-text">引用作为函数返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8C-amp"><span class="nav-number">2.4.2.</span> <span class="nav-text">*和&amp;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">2.5.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88"><span class="nav-number">2.5.1.</span> <span class="nav-text">智能指针和野指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RAII"><span class="nav-number">2.5.2.</span> <span class="nav-text">RAII</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">2.5.3.</span> <span class="nav-text">四种智能指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88-%E3%80%81%E2%80%93"><span class="nav-number">2.5.4.</span> <span class="nav-text">指针++、–</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="nav-number">2.5.5.</span> <span class="nav-text">指针解引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#void"><span class="nav-number">2.5.6.</span> <span class="nav-text">void*</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">2.5.7.</span> <span class="nav-text">函数指针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.1.</span> <span class="nav-text">移动、复制构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.6.2.</span> <span class="nav-text">构造析构顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="nav-number">2.7.</span> <span class="nav-text">左值右值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#std-move"><span class="nav-number">2.7.1.</span> <span class="nav-text">std::move()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.8.</span> <span class="nav-text">c++新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#auto-%E5%92%8C-decltype-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.9.</span> <span class="nav-text">auto 和 decltype 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E3%80%81%E5%BA%95%E5%B1%82const"><span class="nav-number">2.10.</span> <span class="nav-text">顶层、底层const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.11.</span> <span class="nav-text">const和define的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%EF%BC%9F%EF%BC%89"><span class="nav-number">2.12.</span> <span class="nav-text">const实现原理（？）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E4%BD%9C%E7%94%A8"><span class="nav-number">2.13.</span> <span class="nav-text">const作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#const-int-%E5%92%8C-int-const"><span class="nav-number">2.13.1.</span> <span class="nav-text">const int* 和 int* const</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.14.</span> <span class="nav-text">static的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.15.</span> <span class="nav-text">static初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.16.</span> <span class="nav-text">const初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.17.</span> <span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.18.</span> <span class="nav-text">内存分配模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">2.18.1.</span> <span class="nav-text">栈内存与堆内存的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.18.1.1.</span> <span class="nav-text">堆内存慢的原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.18.1.2.</span> <span class="nav-text">栈内存快的原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.18.1.3.</span> <span class="nav-text">栈内存不支持动态扩容的原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">2.18.1.4.</span> <span class="nav-text">函数调用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.18.2.</span> <span class="nav-text">栈回溯</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86"><span class="nav-number">2.19.</span> <span class="nav-text">栈和堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="nav-number">2.19.1.</span> <span class="nav-text">栈溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.19.2.</span> <span class="nav-text">栈溢出保护</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">2.20.</span> <span class="nav-text">内存对齐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-x2F-free-amp-nbsp-%E5%92%8Cnew-x2F-delete%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.21.</span> <span class="nav-text">malloc&#x2F;free&amp;nbsp;和new&#x2F;delete的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.21.1.</span> <span class="nav-text">new关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#placement-new"><span class="nav-number">2.21.2.</span> <span class="nav-text">placement new</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#alloc-x2F-allocate-x2F-deallocate"><span class="nav-number">2.21.3.</span> <span class="nav-text">alloc&#x2F;allocate&#x2F;deallocate</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%B5%85%E5%A4%8D%E5%88%B6"><span class="nav-number">2.22.</span> <span class="nav-text">深浅复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2cast"><span class="nav-number">2.23.</span> <span class="nav-text">强制类型转换cast</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RTTI"><span class="nav-number">2.23.1.</span> <span class="nav-text">RTTI</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">2.24.</span> <span class="nav-text">内存碎片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">2.25.</span> <span class="nav-text">泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E6%A8%A1%E6%9D%BF%E5%92%8C-C-%E6%B3%9B%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.25.1.</span> <span class="nav-text">C++ 模板和 C# 泛型之间的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E4%B8%8E%E8%90%83%E5%8F%96"><span class="nav-number">2.25.2.</span> <span class="nav-text">模板特化与萃取</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">2.26.</span> <span class="nav-text">值传递和引用传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#struct%E5%92%8Cunion%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.27.</span> <span class="nav-text">struct和union的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.28.</span> <span class="nav-text">编译步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E9%9D%99%E9%93%BE%E6%8E%A5"><span class="nav-number">2.29.</span> <span class="nav-text">动静链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">2.30.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#include-lt-gt-%E5%92%8C-include-%E2%80%9C%E2%80%9D%E5%8C%BA%E5%88%AB"><span class="nav-number">2.31.</span> <span class="nav-text">#include&lt;&gt;和#include “”区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E6%AE%B5"><span class="nav-number">2.32.</span> <span class="nav-text">位段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extern"><span class="nav-number">2.33.</span> <span class="nav-text">extern</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8C%E5%87%BD%E6%95%B0"><span class="nav-number">2.33.1.</span> <span class="nav-text">调用C函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile"><span class="nav-number">2.34.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="nav-number">2.35.</span> <span class="nav-text">二义性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">2.36.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E7%B1%BB-x2F-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.37.</span> <span class="nav-text">空类&#x2F;结构体的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.38.</span> <span class="nav-text">lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sort-%E5%87%BD%E6%95%B0comparator"><span class="nav-number">2.38.1.</span> <span class="nav-text">sort 函数comparator</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nullptr%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.39.</span> <span class="nav-text">nullptr和null的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-1"><span class="nav-number">3.</span> <span class="nav-text">c#</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8EC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">与C++的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">3.2.</span> <span class="nav-text">面向对象的三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">静态构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string"><span class="nav-number">3.4.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#string%E5%86%85%E5%AE%B9%E7%9B%B8%E5%90%8C%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8"><span class="nav-number">3.4.1.</span> <span class="nav-text">string内容相同是否是同一个引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC"><span class="nav-number">3.5.</span> <span class="nav-text">GC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c-2"><span class="nav-number">3.5.1.</span> <span class="nav-text">c#</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unity"><span class="nav-number">3.5.2.</span> <span class="nav-text">unity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E4%BA%86-GC-%E8%BF%98%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="nav-number">3.5.3.</span> <span class="nav-text">有了 GC 还会不会发生内存泄漏？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90"><span class="nav-number">3.5.4.</span> <span class="nav-text">非托管资源</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="nav-number">3.6.</span> <span class="nav-text">装箱拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">3.7.</span> <span class="nav-text">修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%83%E9%99%90"><span class="nav-number">3.7.1.</span> <span class="nav-text">权限</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82ref-%E4%B8%8E-out"><span class="nav-number">3.7.2.</span> <span class="nav-text">形参ref 与 out</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8Bin-%E4%B8%8E-out"><span class="nav-number">3.7.3.</span> <span class="nav-text">泛型in 与 out</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.8.</span> <span class="nav-text">结构体和类的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">3.9.</span> <span class="nav-text">接口和抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%E4%B8%8E%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="nav-number">3.10.</span> <span class="nav-text">不安全代码与非托管代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A7%94%E6%89%98"><span class="nav-number">3.11.</span> <span class="nav-text">委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#New%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.12.</span> <span class="nav-text">New的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">3.13.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F"><span class="nav-number">3.14.</span> <span class="nav-text">重载、重写、隐藏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E3%80%81readonly%E4%B8%8Econst"><span class="nav-number">3.15.</span> <span class="nav-text">static、readonly与const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.16.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.17.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="nav-number">3.18.</span> <span class="nav-text">扩展方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">3.19.</span> <span class="nav-text">异步编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.20.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashTable%E5%92%8CDictionary%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.21.</span> <span class="nav-text">HashTable和Dictionary的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Stack%E6%A0%88%E5%92%8CQueue%E9%98%9F%E5%88%97"><span class="nav-number">4.1.</span> <span class="nav-text">Stack栈和Queue队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">4.2.</span> <span class="nav-text">链表和数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.3.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8List"><span class="nav-number">4.4.</span> <span class="nav-text">列表List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E5%85%B8Dictionary"><span class="nav-number">4.5.</span> <span class="nav-text">字典Dictionary</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-number">4.5.1.</span> <span class="nav-text">哈希冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.2.</span> <span class="nav-text">哈希构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">4.6.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E4%B8%AD%E7%9A%84STL%E5%AE%B9%E5%99%A8"><span class="nav-number">4.7.</span> <span class="nav-text">c++中的STL容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#vector"><span class="nav-number">4.7.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deque"><span class="nav-number">4.7.2.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#list"><span class="nav-number">4.7.3.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stack"><span class="nav-number">4.7.4.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#queue"><span class="nav-number">4.7.5.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#priority-queue"><span class="nav-number">4.7.6.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#set"><span class="nav-number">4.7.7.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map"><span class="nav-number">4.7.8.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hash-map"><span class="nav-number">4.7.9.</span> <span class="nav-text">hash_map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unordered-map"><span class="nav-number">4.7.10.</span> <span class="nav-text">unordered_map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map%E3%80%81hash-map%E3%80%81unordered-map%E6%AF%94%E8%BE%83"><span class="nav-number">4.7.11.</span> <span class="nav-text">map、hash_map、unordered_map比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.7.12.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B"><span class="nav-number">5.1.</span> <span class="nav-text">单例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82"><span class="nav-number">5.2.</span> <span class="nav-text">工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-number">5.3.</span> <span class="nav-text">观察者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">5.4.</span> <span class="nav-text">状态机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E6%A0%91"><span class="nav-number">5.5.</span> <span class="nav-text">行为树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-number">5.6.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-number">5.7.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC"><span class="nav-number">5.8.</span> <span class="nav-text">MVC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ECS"><span class="nav-number">5.9.</span> <span class="nav-text">ECS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="nav-number">6.1.</span> <span class="nav-text">如何判断链表中是否有环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">6.2.1.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">6.3.</span> <span class="nav-text">判断二叉平衡树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-number">6.4.</span> <span class="nav-text">二叉树的非递归遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL%E7%9A%84sort"><span class="nav-number">6.5.</span> <span class="nav-text">STL的sort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.</span> <span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unity"><span class="nav-number">7.</span> <span class="nav-text">Unity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.</span> <span class="nav-text">生命周期函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unity%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="nav-number">7.2.</span> <span class="nav-text">unity编译原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%89%B9"><span class="nav-number">7.3.</span> <span class="nav-text">合批</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TextMeshpro%E5%92%8Ctext%E5%8C%BA%E5%88%AB"><span class="nav-number">7.4.</span> <span class="nav-text">TextMeshpro和text区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#image%E5%92%8Csprite%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.5.</span> <span class="nav-text">image和sprite的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#image%E5%92%8Crawimage%E5%8C%BA%E5%88%AB"><span class="nav-number">7.6.</span> <span class="nav-text">image和rawimage区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mask%E5%92%8Crectmask2d%E5%8C%BA%E5%88%AB"><span class="nav-number">7.7.</span> <span class="nav-text">mask和rectmask2d区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ui%E6%A1%86%E6%9E%B6"><span class="nav-number">7.8.</span> <span class="nav-text">ui框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E9%9B%86"><span class="nav-number">7.9.</span> <span class="nav-text">图集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F"><span class="nav-number">7.9.1.</span> <span class="nav-text">压缩方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Animation%E5%92%8CAnimator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.10.</span> <span class="nav-text">Animation和Animator 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ugui%E4%BC%98%E5%8C%96"><span class="nav-number">7.11.</span> <span class="nav-text">ugui优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Astar%E7%AE%97%E6%B3%95"><span class="nav-number">7.12.</span> <span class="nav-text">Astar算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="nav-number">7.13.</span> <span class="nav-text">资源加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Protobuf"><span class="nav-number">7.14.</span> <span class="nav-text">Protobuf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="nav-number">7.15.</span> <span class="nav-text">摄像机渲染顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E5%8F%82%E6%95%B0"><span class="nav-number">7.16.</span> <span class="nav-text">摄像机参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9A%E4%BD%93"><span class="nav-number">7.17.</span> <span class="nav-text">刚体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GUID%E5%92%8CMeta"><span class="nav-number">7.18.</span> <span class="nav-text">GUID和Meta</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">7.19.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">7.20.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-number">7.21.</span> <span class="nav-text">对象池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="nav-number">7.22.</span> <span class="nav-text">射线检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Area-Of-Interest"><span class="nav-number">7.23.</span> <span class="nav-text">Area Of Interest</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">8.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.1.</span> <span class="nav-text">TCP&#x2F;IP四层网络模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">计算机五层网络模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.3.</span> <span class="nav-text">OSI七层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.4.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5"><span class="nav-number">8.5.</span> <span class="nav-text">TCP的三握四挥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%B3%E5%AE%9A"><span class="nav-number">8.6.</span> <span class="nav-text">TCP为什么稳定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">8.7.</span> <span class="nav-text">TCP 拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85"><span class="nav-number">8.8.</span> <span class="nav-text">TCP粘包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A5%E6%96%87%E5%A4%B4"><span class="nav-number">8.9.</span> <span class="nav-text">报文头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0UDP"><span class="nav-number">8.10.</span> <span class="nav-text">可靠UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#KCP"><span class="nav-number">8.10.1.</span> <span class="nav-text">KCP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E5%85%B3"><span class="nav-number">8.11.</span> <span class="nav-text">网关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MTU"><span class="nav-number">8.12.</span> <span class="nav-text">MTU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket"><span class="nav-number">8.13.</span> <span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">8.14.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">8.15.</span> <span class="nav-text">HTTP长连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%9A%84%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2"><span class="nav-number">8.16.</span> <span class="nav-text">HTTP的版本历史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">8.17.</span> <span class="nav-text">从浏览器地址栏输入url到页面显示的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">8.17.1.</span> <span class="nav-text">DNS解析过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#https%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86%E7%9A%84"><span class="nav-number">8.17.2.</span> <span class="nav-text">https如何加密的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">9.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">线程和协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">9.3.</span> <span class="nav-text">线程的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">9.4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">9.4.1.</span> <span class="nav-text">死锁避免</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.5.</span> <span class="nav-text">进程间通信的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95"><span class="nav-number">9.6.</span> <span class="nav-text">线程间通信方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">9.7.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A3%E5%8A%BF%E6%83%85%E5%86%B5"><span class="nav-number">9.8.</span> <span class="nav-text">多线程劣势情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">9.9.</span> <span class="nav-text">锁与原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="nav-number">9.10.</span> <span class="nav-text">缺页中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">计算机组成原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#int%E6%9C%80%E5%B0%8F%E5%80%BC-%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="nav-number">10.1.</span> <span class="nav-text">int最小值, 最大值的二进制表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="nav-number">10.2.</span> <span class="nav-text">有符号整数和无符号整数的右移操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF"><span class="nav-number">10.3.</span> <span class="nav-text">大端小端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CacheLine"><span class="nav-number">10.4.</span> <span class="nav-text">CacheLine</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E5%AD%A6"><span class="nav-number">11.</span> <span class="nav-text">图形学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E4%B9%98%E5%8F%89%E4%B9%98"><span class="nav-number">11.1.</span> <span class="nav-text">点乘叉乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drawcall"><span class="nav-number">11.2.</span> <span class="nav-text">drawcall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%BB%BC%E8%BF%B0"><span class="nav-number">11.3.</span> <span class="nav-text">渲染管线综述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GPU%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">11.4.</span> <span class="nav-text">GPU流水线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mvp%E7%9F%A9%E9%98%B5"><span class="nav-number">11.5.</span> <span class="nav-text">mvp矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E9%98%9F%E5%88%97"><span class="nav-number">11.6.</span> <span class="nav-text">渲染队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">11.7.</span> <span class="nav-text">几何着色器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93"><span class="nav-number">11.8.</span> <span class="nav-text">延迟渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%94%E9%99%A4"><span class="nav-number">11.9.</span> <span class="nav-text">剔除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PBR"><span class="nav-number">11.10.</span> <span class="nav-text">PBR</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PBR%E9%AB%98%E5%85%89"><span class="nav-number">11.10.1.</span> <span class="nav-text">PBR高光</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BRDF%E5%87%BD%E6%95%B0"><span class="nav-number">11.11.</span> <span class="nav-text">BRDF函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA"><span class="nav-number">11.12.</span> <span class="nav-text">路径追踪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AB%E5%8F%89%E6%A0%91%E3%80%81BVH"><span class="nav-number">11.13.</span> <span class="nav-text">八叉树、BVH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%97%E9%94%AF%E9%BD%BF%E6%8A%80%E6%9C%AF"><span class="nav-number">11.14.</span> <span class="nav-text">常见的抗锯齿技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="nav-number">11.15.</span> <span class="nav-text">投影矩阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-number">12.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E6%89%87%E5%BD%A2%E8%8C%83%E5%9B%B4%E5%86%85"><span class="nav-number">12.1.</span> <span class="nav-text">判断点是否在扇形范围内</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E7%82%B9%E5%9C%A8%E5%90%91%E9%87%8F%E4%B8%8A%E7%9A%84%E6%8A%95%E5%BD%B1"><span class="nav-number">12.2.</span> <span class="nav-text">求点在向量上的投影</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3D%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%B0%84%E7%BA%BF%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%BA%A4%E5%8F%89%E6%A3%80%E6%B8%AC%E7%AE%97%E6%B3%95"><span class="nav-number">12.3.</span> <span class="nav-text">3D空间中射线与三角形的交叉检測算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-number">12.4.</span> <span class="nav-text">判断矩形是否相交</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">13.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Git%E5%92%8Csvn%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.1.</span> <span class="nav-text">Git和svn的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E9%BC%A0%E8%AF%95%E6%AF%92"><span class="nav-number">13.2.</span> <span class="nav-text">小鼠试毒</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fire Egg"
      src="/images/avatar.JPG">
  <p class="site-author-name" itemprop="name">Fire Egg</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/szlx560223" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;szlx560223" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/6538879" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;6538879" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/19/%E5%85%AB%E8%82%A1_%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.JPG">
      <meta itemprop="name" content="Fire Egg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FireEgg's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="个人八股整理——Unity游戏客户端 | FireEgg's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          个人八股整理——Unity游戏客户端
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-19 23:32:39" itemprop="dateCreated datePublished" datetime="2024-05-19T23:32:39+08:00">2024-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-23 21:09:43" itemprop="dateModified" datetime="2024-05-23T21:09:43+08:00">2024-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>90k</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>本博客为个人整理，资料全数来源于互联网，囊括的知识点全数来源于牛客网的面经</li>
</ul>
<span id="more"></span>

<h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/118196343">https://blog.csdn.net/weixin_43798887/article/details/118196343</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/118369498">https://blog.csdn.net/weixin_43798887/article/details/118369498</a></p>
<p>虚函数：<strong>即被virtual修饰的类成员函数称为虚函数。</strong> 一旦定义了虚函数，该<strong>基类的派生类中同名函数也自动成为了虚函数</strong>。 虚函数只能是类中的一个成员函数，不能是静态成员或普通函数。</p>
<p>每个虚函数都会有一个与之对应的<strong>虚函数表</strong>，该虚函数表的实质是一个<strong>指针数组</strong>，存放的是每一个对象的<strong>虚函数入口地址</strong>。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生<strong>动态绑定</strong>，将父类指针绑定到实例化的对象实现<strong>多态</strong>。 </p>
<ul>
<li><p>虚函数表是基于<strong>类</strong>的</p>
</li>
<li><p>虚函数表存放于只读数据区（常量区）</p>
</li>
<li><p>虚函数指针每个实例有一个（其实也就是对象的引用的“地址”），指针内容同一个类的实例内容相同（同一张表）</p>
</li>
<li><p>即使没有重载虚函数，虚函数表也是独立的，只不过会指向父类虚函数表的内容</p>
</li>
<li><p>向上转型保留原类型虚函数指针内容（B-&gt;A,调用函数仍然是B的）</p>
</li>
</ul>
<p>虚函数指针在<strong>构造函数前、初始化列表之前</strong>赋值</p>
<p>有纯虚函数的类是抽象类，除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>
<p><strong>哪些函数不能成为虚函数？</strong></p>
<ol>
<li><p>内联函数：我们都知道内联函数只是在函数调用点将其展开，它不能产生函数符号，所以不能往虚表中存放，自然就不能成为虚函数。</p>
</li>
<li><p>静态函数：定义为静态函数的函数，这个函数只和类有关系，它不完全依赖于对象调用，所以也不能成为虚函数。</p>
</li>
<li><p><strong>构造函数</strong>：虚函数是基于对象的，构造函数是用来产生对象的，若构造函数是虚函数，则需要对象来调用，但是此时构造函数没有执行，就没有对象存在，产生矛盾，所以构造函数不能是虚函数。</p>
</li>
<li><p>友元函数：友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p>
</li>
<li><p>普通函数：普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。</p>
</li>
</ol>
<p><strong>哪些函数可以成为虚函数呢？</strong></p>
<ol>
<li><p>普通的成员方法</p>
</li>
<li><p><strong>析构函数</strong>，因为析构函数是为了释放对象的，所以之前我们的对象已经生成，而且析构函数可以取地址，所以可以成为虚函数。</p>
</li>
</ol>
<p>当我们定义了一个基类指针，然后在堆上new了一个派生类的对象,让这个指针指向堆上开辟的这块内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">10</span>);<span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<p>如果基类的析构函数没有写成虚函数，delete这个基类指针，就不能释放掉堆上的派生类对象。因为delete p会调用基类的析构。所以我们就要把基类的析构函数写成虚函数。写成虚函数后，当delete的时候，先会去基类调用析构函数，一看基类的析构函数是虚函数，就会自动的到派生类中调用派生类的析构函数。这时候派生类的对象就能释放了。</p>
<p><strong>动态多态</strong>一般由虚函数实现。C++程序在编译时，遇到<strong>virtual</strong>关键字，会在生成一个对应此类的<strong>虚函数表</strong>，把虚函数存放到虚函数表中，类中只存放一个虚函数表指针，当对象调用此函数时，可以通过虚函数表指针进行访问。派生类在生成虚函数表的时候，会参考父类虚函数表，如果子类中有的虚函数，不管是新增还是重写父类虚函数，都优先写入自己的虚函数表，其他虚函数和普通成员函数一样，都会根据继承权限从基类继承下来。</p>
<p><strong>不要在构造函数中调用虚函数</strong>，因为子类实例化时会调用父类的构造函数，子类的虚函数表指针还没初始化，此时执行虚函数并不会调用重写的虚函数，</p>
<h4 id="默认的6个成员函数"><a href="#默认的6个成员函数" class="headerlink" title="默认的6个成员函数"></a>默认的6个成员函数</h4><ul>
<li>构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>赋值运算符重载</li>
</ul>
<p>这四个一般自己写</p>
<ul>
<li>取地址操作符重载</li>
<li>const修饰的取地址操作符重载</li>
</ul>
<p>这两个一般用默认的就行</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在<strong>同一作用域类</strong>，一组函数的<strong>函数名相同</strong>，<strong>参数列表不同（参数个数不同&#x2F;参数类型不同）</strong>，<strong>返回值可同可不同</strong></p>
<p>编译器在编译.cpp文件中当前使用的作用域里的同名函数时，根据函数形参的类型和顺序会对函数进行重命名（不同的编译器在编译时对函数的重命名标准不一样）但是总的来说，他们都把文件中的同一个函数名进行了重命名；</p>
<ul>
<li><p>在vs编译器中：</p>
<ul>
<li>根据返回值类型（不起决定性作用）+形参类型和顺序（起决定性作用）的规则重命名并记录在map文件中。</li>
</ul>
</li>
<li><p>在linux g++ 编译器中：</p>
<ul>
<li>根据函数名字的字符数+形参类型和顺序的规则重命名记录在符号表中；从而产生不同的函数名，当外面的函数被调用时，便是根据这个记录的结果去寻找符合要求的函数名,进行调用；</li>
</ul>
</li>
</ul>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ul>
<li>引用<strong>不能为空</strong>，即不存在对空对象的引用，指针可以为空，指向空对象。</li>
<li>引用<strong>必须初始化</strong>，指定对哪个对象的引用，指针不需要。</li>
<li>引用初始化后<strong>不能改变</strong>，指针可以改变所指对象的值。</li>
<li>引用<strong>没有const</strong>，指针有const</li>
<li>引用访问对象是<strong>直接访问</strong>，指针访问对象是间接访问。</li>
<li>指针可以有多级，但是引用只能是一级</li>
<li>引用的大小是所<strong>引用对象的大小</strong>，指针的大小是<strong>指针本身大小</strong>，通常是<strong>4&#x2F;8字节</strong>。</li>
<li>引用和指针的+自增运算符意义不同（一整块vs一个内存地址）。</li>
</ul>
<p>指针是指向内存地址的实体，引用是内存块的别名，<strong>底层是const指针</strong></p>
<h5 id="引用作为函数返回值"><a href="#引用作为函数返回值" class="headerlink" title="引用作为函数返回值"></a>引用作为函数返回值</h5><ul>
<li><p><strong>不能返回局部变量的引用</strong>。离开作用域变量会被销毁，指向的东西不存在了。</p>
</li>
<li><p><strong>不能返回函数内部new分配的内存的引用</strong>。如果外部没有变量接住返回值会造成内存泄漏</p>
</li>
<li><p><strong>可以返回类成员的引用</strong>，但最好是const。</p>
</li>
<li><p>若返回栈变量</p>
<ul>
<li>不能成为其他引用的初始值 </li>
<li>不能作为左值使用</li>
</ul>
</li>
<li><p>若返回静态变量或全局变量：</p>
<ul>
<li>可以成为其他引用的初始值</li>
<li>可作为右值使用，也可作为左值使用</li>
</ul>
</li>
</ul>
<h5 id="和-amp"><a href="#和-amp" class="headerlink" title="*和&amp;"></a>*和&amp;</h5><ul>
<li><ul>
<li><ul>
<li>表示这是一个指针(声明变量时的等号左边)</li>
<li>作为运算符来取值(赋值等号左边)。</li>
</ul>
</li>
</ul>
</li>
<li>&amp;<ul>
<li>表示这是一个引用</li>
<li>作为取地址运算符</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;B = <span class="number">0x00000004</span>;  <span class="comment">//B本身的地址</span></span><br><span class="line">B= <span class="number">0x00000008</span>;  <span class="comment">//存放的地址</span></span><br><span class="line">*B = <span class="string">&quot;something&quot;</span>;  <span class="comment">//存放地址中的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>指针作为参数</strong>： 传递变量的指针。形参是指针变量，实参是一个变量的地址，调用函数时，形参(指针变量)指向实参变量单元。这种通过形参指针可以改变实参的值。</p>
<p><strong>引用（地址）作为参</strong>数：形参是引用变量，和实参是一个变量，调用函数时，形参(引用变量)指向实参变量<br>单元。这种通过形参引用可以改变实参的值。</p>
<p><strong>引用参数和指针参数的区别</strong>：指针作为参数时，实参在定义的时候就是一个指针变量，形参类型也是一个指针类型，而引用作为参数的时候，实参不是指针变量，因为形参是地址，所以形参类型是引用类型，表示传进来的参数不用拷贝，直接用原来地址中的那份。</p>
<ol>
<li>语法和使用方式：<ul>
<li>指针作为参数：指针参数使用指针符号（*）声明，在函数参数列表中需要使用解引用运算符（*）来访问指针所指向的对象。</li>
<li>引用作为参数：引用参数使用引用符号（&amp;）声明，在函数参数列表中直接使用变量名，无需使用解引用运算符（*）。</li>
</ul>
</li>
<li>空值（null）处理：<ul>
<li>指针作为参数：指针参数可以接受 null 值，表示指向空对象或无效对象。</li>
<li>引用作为参数：引用参数必须绑定到一个已存在的对象，不能为 null。</li>
</ul>
</li>
<li>参数修改：<ul>
<li>指针作为参数：指针参数可以通过解引用或重新分配内存来修改指针所指向的对象。</li>
<li>引用作为参数：引用参数可以直接修改原始变量的值，而不需要通过解引用或重新分配内存来修改。</li>
</ul>
</li>
<li>传递方式：<ul>
<li>指针作为参数：指针参数可以通过按值传递（pass-by-value）或按指针传递（pass-by-pointer）来使用。前者传递的是指针的副本，后者传递的是指针本身。</li>
<li>引用作为参数：引用参数在函数调用时使用的是按引用传递（pass-by-reference），即传递的是原始对象的别名，对参数的修改会影响原始对象。</li>
</ul>
</li>
<li>空间需求：<ul>
<li>指针作为参数：指针参数需要额外的内存空间来存储指针本身。</li>
<li>引用作为参数：引用参数不需要额外的内存空间，它只是原始对象的别名。</li>
</ul>
</li>
</ol>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><h5 id="智能指针和野指针"><a href="#智能指针和野指针" class="headerlink" title="智能指针和野指针"></a>智能指针和野指针</h5><ul>
<li><p>智能指针：在构造的时候<strong>分配内存</strong>，当离开作用域的时候，自动<strong>释放分配的内存</strong>，这样的话开发人员就可以从手动动态管理内存的繁杂内容中解放出来。（重点注意！！）</p>
</li>
<li><p>野指针：指向非法的内存地址指针叫作野指针（Wild Pointer），也叫悬挂指针（Dangling Pointer），意为无法正常使用的指针。</p>
</li>
<li><p><strong>野指针产生的原因</strong></p>
<ul>
<li>指针变量未初始化或者便赋值</li>
<li>指针释放后未置空</li>
<li>指针操作超出了变量的作用域</li>
</ul>
</li>
<li><p><strong>如何避免野指针：</strong></p>
<ul>
<li>指针变量一定要初始化，可以初始化为 nullptr</li>
<li>释放后置为 nullptr。</li>
</ul>
</li>
</ul>
<h5 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h5><p>RAII 是 Resource Acquisition Is Initialization(资源获取即初始化)的缩写。RAII 是C++ 中常用的一种编程技术，具体是指必须在使用前获取的资源（如栈内存，线程，文件，锁，数据库连接，磁盘空间）的声明周期绑定在一个对象的生命周期，这样使用者就不需要自己去释放资源，避免资源泄露。</p>
<p><strong>实现原理</strong></p>
<p>利用对象的生命周期管理资源，在对象离开作用域时，会自动调用析构函数</p>
<p><strong>特征</strong></p>
<p>标准库提供几种 RAII包 装器以管理用户提供的资源：</p>
<ul>
<li>std::unique_ptr 及 std::shared_ptr 以管理动态分配的内存，或以用户提供的删除器管理任何以普通指针表示的资源；</li>
<li>std::lock_guard 、 std::unique_lock 、 std::shared_lock 以管理互斥。</li>
</ul>
<h5 id="四种智能指针"><a href="#四种智能指针" class="headerlink" title="四种智能指针"></a>四种智能指针</h5><p><strong>auto_ptr</strong></p>
<p>可以随意复制，不安全，弃用</p>
<p><strong>unique_ptr</strong></p>
<p>两个unique_ptr 不能指向一个对象</p>
<p>不能赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="literal">nullptr</span>)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="function">unique_ptr&lt;T,D&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>), D())</span></span>;<span class="comment">// 用类型为 D 的对象替代默认删除器 std::default_delete,比如fclose()关文件和delete []a删数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr&lt;T,D&gt; p1(p);//不能复制</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;T,D&gt; p1 = p;//不能复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是可以拿来接临时的函数返回值</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">demo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;string&gt; <span class="title">temp</span> <span class="params">(<span class="keyword">new</span> string(s))</span>； </span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> temp；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; ps</span>;</span><br><span class="line">ps = <span class="built_in">demo</span>(<span class="string">&quot;Uniquely special&quot;</span>)；</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pi = p.<span class="built_in">release</span>();<span class="comment">// 释放所有权</span></span><br><span class="line">std::<span class="built_in">move</span>()<span class="comment">//转移所有权</span></span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));<span class="comment">// 销毁旧对象（如果有）然后绑定新对象</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p1.<span class="built_in">release</span>());<span class="comment">// 转移所有权，p2置空</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1);<span class="comment">// 转移所有权，p1置空</span></span><br><span class="line"></span><br><span class="line">p = <span class="literal">nullptr</span>;<span class="comment">//显式销毁所指对象，同时智能指针变为空指针。与 p.reset() 等价</span></span><br></pre></td></tr></table></figure>

<p>比auto_ptr的优点</p>
<ul>
<li>能放在容器中</li>
<li>重载了[]，可以管理数组</li>
<li>可以自定义删除方式</li>
</ul>
<p><strong>shared_ptr</strong></p>
<p>自带引用计数器，为0自动释放，创建时在引用计数管理区域new一个计数器，包含weak计数和shared计数</p>
<ul>
<li>shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针。</li>
<li>时间上的开销主要在初始化和拷贝操作上， * 和 -&gt; 操作符重载的开销跟 auto_ptr 是一样。</li>
<li>开销并不是我们不使用 shared_ptr 的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点</li>
<li>不是线程安全，因为拷贝非原子操作（计数++，传递指针），即使计数器是线程安全的</li>
</ul>
<p><strong>weak_ptr</strong></p>
<p>为了解决循环引用问题，引入weak_ptr</p>
<p>不会增加引用计数，和shared_ptr配合使用，没有重载operator* 和 operator-&gt;，只有观测权</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; w;	 	<span class="comment">//创建空 weak_ptr，可以指向类型为 T 的对象</span></span><br><span class="line"><span class="function">weak_ptr&lt;T&gt; <span class="title">w</span><span class="params">(sp)</span></span>;	<span class="comment">//与 shared_ptr 指向相同的对象，shared_ptr 引用计数不变。T必须能转换为 sp 指向的类型</span></span><br><span class="line">w=p;				<span class="comment">//p 可以是 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象</span></span><br><span class="line">w.<span class="built_in">reset</span>();			<span class="comment">//将 w 置空</span></span><br><span class="line">w.<span class="built_in">use_count</span>();		<span class="comment">//返回与 w 共享对象的 shared_ptr 的数量</span></span><br><span class="line">w.<span class="built_in">expired</span>();		<span class="comment">//若 w.use_count() 为 0，返回 true，否则返回 false</span></span><br><span class="line">w.<span class="built_in">lock</span>();			<span class="comment">//如果 expired() 为 true，返回一个空 shared_ptr，否则返回非空 shared_ptr</span></span><br></pre></td></tr></table></figure>



<p><strong>实现原理</strong></p>
<p>unique：出范围自动调用析构</p>
<p>shared：增加计数器Counter(s &#x3D; 0,w &#x3D; 0)，s &#x3D; 0自动销毁</p>
<p>weak：获得Counter,w++，用lock获取shared_ptr</p>
<p><strong>线程安全</strong></p>
<ul>
<li>使用智能指针访问资源不是线程安全的，需要手动加锁解锁。</li>
<li>智能指针的拷贝也不是线程安全的,要先复制指针，再增加计数</li>
</ul>
<h5 id="指针-、–"><a href="#指针-、–" class="headerlink" title="指针++、–"></a>指针++、–</h5><p>对于int a[10] &#x3D; {0, 1, 77, 88}而言，a的值是数组首元素的地址，而&amp;a是整个数组的地址，a+1，就是第二个元素的地址，int类型占用4个字节，所以前后相差4。&amp;a+1,就是向后移动(10*4)个单位，所以前后相差40。</p>
<h5 id="指针解引用"><a href="#指针解引用" class="headerlink" title="指针解引用"></a>指针解引用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x; <span class="comment">// p 是一个指向 x 的指针</span></span><br><span class="line"><span class="type">int</span>** pp = &amp;p; <span class="comment">// pp 是指向指针 p 的指针</span></span><br><span class="line"><span class="type">int</span> zz = *p;  <span class="comment">// 解引用一次得到 p</span></span><br><span class="line"><span class="type">int</span> z = **pp;  <span class="comment">//解引用两次得到 x; z 被赋值为 p 指向的值，即 x 的值</span></span><br><span class="line"><span class="comment">//pp 是一个多级指针，即指针的指针。解引用两次 **pp 可以获取 pp 指向的指针所指向的值，即 x 的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ptrToVoid = &amp;x;</span><br><span class="line"><span class="comment">//*ptrToVoid = 20; // 错误：不允许解引用 void 指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* voidPtr = &amp;value;</span><br><span class="line"><span class="type">int</span>* intPtr = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(voidPtr);</span><br><span class="line"><span class="type">int</span> dereferencedValue = *intPtr; <span class="comment">// 合法的解引用操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h5><p>特殊的指针类型, 可以存放任意对象地址. 通用指针</p>
<ul>
<li>任何类型指针可以赋值给void*, 无需进行强制类型转换</li>
<li>需要显示转换赋值给其他类型指针</li>
<li>void*作为函数的输入输出时, 表示可以接受任意类型的输入指针和输出任意类型的指针.</li>
<li>可以算术运算，按字节移动</li>
</ul>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">void</span> (*sum)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 声明</span></span><br><span class="line">    sum = &amp;printSum; <span class="comment">// 带不带&amp;符号都一样效果，函数名也表示地址,和sum = printSum;一样</span></span><br><span class="line">    <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p&quot;</span>, printSum, &amp;printSum, sum, *sum);  <span class="comment">// 打印出来的地址是一样的，所以上面加不加&amp;符号效果都一样</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*SUM)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    SUM fun = printSum;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//类成员函数</span></span><br><span class="line">    Sample *ins = <span class="keyword">new</span> Sample;</span><br><span class="line">    <span class="built_in">void</span> (Sample::*sum)(<span class="type">int</span>, <span class="type">int</span>);<span class="comment">//类成员函数声明，要加类名</span></span><br><span class="line">    sum = &amp;Sample::printSum; <span class="comment">// 这个必须加&amp;，与普通函数不同</span></span><br><span class="line">    (ins-&gt;*sum)(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用，注意：这里需要加星*</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Sample::*SUM)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">	SUM sum = &amp;Sample::printSum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><strong>默认构造函数</strong>：如果没有人为指定就生成默认的</li>
<li><strong>一般构造函数</strong></li>
<li><strong>拷贝构造函数</strong></li>
<li><strong>移动构造函数</strong></li>
<li><strong>赋值构造函数：</strong>&#x3D;运算符的重载，类似拷贝构造函数，将&#x3D;右边的类对象赋值给类对象左边的对象，不属于构造函数，&#x3D;两边的对象必须都要被创建。</li>
<li><strong>类型转换构造函数：</strong>有时候不想要隐式转换，用explict关键字修饰。一般来说带一个参数的构造函数，或者其他参数是默认的构造函数</li>
</ul>
<h5 id="移动、复制构造函数"><a href="#移动、复制构造函数" class="headerlink" title="移动、复制构造函数"></a>移动、复制构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(other.data)) &#123;<span class="comment">//理想情况，实际可能需要新分配内存和判空</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp; other)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;other)&#123;</span><br><span class="line">            <span class="keyword">if</span>(other.data!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                data = <span class="keyword">new</span> <span class="built_in">int</span>(other.data);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;<span class="comment">//理想情况，实际可能需要新分配内存和判空</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;other)&#123;</span><br><span class="line">            data = other.data;</span><br><span class="line">            other.data = <span class="literal">nullptr</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>什么情况下会调用拷贝构造函数？</strong></p>
<ol>
<li>对象以值传递的方式进入函数体</li>
<li>对象以值传递的方式从函数返回</li>
<li>一个对象需要另外一个对象初始化</li>
</ol>
<h5 id="构造析构顺序"><a href="#构造析构顺序" class="headerlink" title="构造析构顺序"></a>构造析构顺序</h5><ul>
<li><p>构造顺序为：先调用基类的构造函数，再调用派生类的构造函数，</p>
</li>
<li><p>析构顺序为：先调用派生类的析构函数，再调用基类的析构函数。</p>
</li>
</ul>
<p>父子子父</p>
<h4 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h4><ul>
<li>左值（lvalue）是一个具有持久性的、可寻址的表达式，它代表一个具体的对象或变量。简单来说，左值可以出现在赋值操作符的左边或右边，可以取得地址。例如，变量、数组元素和通过引用访问的对象都是左值。</li>
<li>右值（rvalue）是一个临时的、一次性的表达式，它代表一个临时的数值或对象。右值不能出现在赋值操作符的左边，不能取得地址。例如，常量、临时对象和表达式的结果都可以是右值。</li>
</ul>
<h5 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h5><p>std::move作用主要可以将一个左值转换成右值引用，从而可以调用C++11右值引用的拷贝构造函数</p>
<ul>
<li>传递的是左值，推导为左值引用，仍旧static_cast转换为右值引用。</li>
<li>传递的是右值，推导为右值引用，仍旧static_cast转换为右值引用。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/254803.htm">https://www.jb51.net/article/254803.htm</a></p>
<h4 id="c-新特性"><a href="#c-新特性" class="headerlink" title="c++新特性"></a>c++新特性</h4><ul>
<li><strong>C++11</strong>：<ul>
<li>引入了 auto 关键字和 decltype 关键字，用于自动推导变量类型；</li>
<li>引入了 lambda 表达式，用于定义匿名函数；</li>
<li>引入了智能指针，例如 shared_ptr 和 unique_ptr，用于自动管理内存；</li>
<li>引入了可变参数模板，允许模板参数数量可变；</li>
<li>引入了右值引用和移动语义，用于提高代码效率。</li>
</ul>
</li>
<li><strong>C++14</strong>：<ul>
<li>改进了泛型编程，引入了泛型 lambda 表达式；</li>
<li>引入了二进制字面量和通用的 lambda 捕获初始化；</li>
<li>改进了 constexpr 函数，允许函数内包含控制流语句。</li>
</ul>
</li>
<li><strong>C++17</strong>：<ul>
<li>引入了 if constexpr 语句，允许在编译期间进行条件判断；</li>
<li>引入了折叠表达式，简化了变长参数模板的实现；</li>
<li>改进了模板参数推导规则，支持类模板参数推导。</li>
</ul>
</li>
<li><strong>C++20：</strong><ul>
<li>引入了概念（Concepts），用于限定模板参数的类型；</li>
<li>引入了协程（Coroutines），用于实现异步编程；</li>
<li>引入了三向比较运算符（Three-way Comparison），用于简化比较操作；</li>
<li>引入了格式化输出库（std::format），用于格式化输出字符串。</li>
</ul>
</li>
</ul>
<h4 id="auto-和-decltype-区别"><a href="#auto-和-decltype-区别" class="headerlink" title="auto 和 decltype 区别"></a>auto 和 decltype 区别</h4><p>两者都是用于类型推断,区别在于auto用于变量声明时的类型推导，decltype适用于表达式的返回值类型的推断，实际上没有执行那个表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;  <span class="comment">//ci 为整数常量,cr 为整数常量引用 </span></span><br><span class="line"><span class="keyword">auto</span> a = ci;     <span class="comment">// a 为一个整数, 顶层const被忽略</span></span><br><span class="line"><span class="keyword">auto</span> b = cr;     <span class="comment">// b 为一个整数，顶层const被忽略</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;ci;    <span class="comment">// c 为一个整数指针.</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;cr;    <span class="comment">// d 为一个指向整数常量的指针(对常量对象区地址是那么const会变成底层const)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>, &amp;cj = ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;   <span class="comment">// x 类型为const int</span></span><br><span class="line"><span class="keyword">auto</span> z = ci;          <span class="comment">// z 类型为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;   <span class="comment">// y 类型为const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> h = cj;          <span class="comment">// h 类型为int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) x1 = <span class="number">0</span>;       <span class="comment">//因为 i 为 int ,所以 x1 为int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = i;              <span class="comment">//因为 i 为 int ,所以 x2 为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r) y1 = i;       <span class="comment">//因为 r 为 int&amp; ,所以 y1 为int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> y2 = r;              <span class="comment">//因为 r 为 int&amp; ,但auto会忽略引用，所以 y2 为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) z1 = <span class="number">0</span>;   <span class="comment">//因为 r + 0 为 int ,所以 z1 为int,</span></span><br><span class="line"><span class="keyword">auto</span> z2 = r + <span class="number">0</span>;          <span class="comment">//因为 r + 0 为 int ,所以 z2 为int,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(*p) h1 = i;      <span class="comment">//这里 h1 是int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> h2 = *p;             <span class="comment">// h2 为 int.</span></span><br></pre></td></tr></table></figure>

<h4 id="顶层、底层const"><a href="#顶层、底层const" class="headerlink" title="顶层、底层const"></a>顶层、底层const</h4><p>指针既可以是底层const，也可以是顶层cosnt。指针是顶层const的含义是指针本身的值不能被改变，指针是底层const的含义是不能通过指针修改被指向的对象（但是被指向的对象可能是const，也可能不是cosnt）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1=&amp;i; <span class="comment">//不能改变p1的值，顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2=&amp;ci;<span class="comment">//允许改变p2的值，底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">42</span>;  <span class="comment">//不能改变ci的值，顶层const</span></span><br></pre></td></tr></table></figure>



<h4 id="const和define的区别"><a href="#const和define的区别" class="headerlink" title="const和define的区别"></a>const和define的区别</h4><ol>
<li><p>就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用                                             </p>
</li>
<li><p>就起作用的方式而言： #define只是简单的字符替换，没有类型检查,存在边界的错误；const对应数据类型，进行类型检查；    </p>
</li>
<li><p>就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份,占用代码段空间；const定义的只读变量在程序运行过程中只有一份备份，占用数据段空间。   </p>
</li>
<li><p>从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。</p>
</li>
<li><p>从是否可以再定义的角度而言： const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。</p>
</li>
<li><p>从某些特殊功能而言： define可以用来防止头文件重复引用，而const不能;</p>
</li>
<li><p>从用于类中来看：const用于类成员变量的定义，只要一定义，不可修改。define 不可用于类成员变量的定义，但是可以用于全局变量。</p>
</li>
<li><p>const采用一个普通的常量名称，define可以采用表达式作为名称；</p>
</li>
</ol>
<h4 id="const实现原理（？）"><a href="#const实现原理（？）" class="headerlink" title="const实现原理（？）"></a>const实现原理（？）</h4><p>在C++中，<code>const</code>关键字用于声明一个常量，即一个在程序执行过程中不可修改的值。<code>const</code>的实现原理涉及编译器和运行时环境。</p>
<p>在<strong>编译阶段</strong>，当编译器遇到一个使用<code>const</code>声明的变量时，它会将该变量标记为只读。这意味着编译器会在编译过程中对这些变量进行静态检查，以确保它们不会被修改。如果在编译期间发现对<code>const</code>变量的修改尝试，编译器将生成错误或警告。</p>
<p>在生成的可执行文件中，<code>const</code>变量通常被视为符号常量。编译器可能会将这些常量存储在可执行文件的常量数据段中，该段在程序加载时被加载到内存中，并且在运行时是只读的。这样，即使程序尝试修改<code>const</code>变量的值，由于内存区域被标记为只读，操作系统会阻止对该内存区域的写入操作。</p>
<p>通常情况下，const将变量的值保存到编译器的符号表中，并不为变量分配内存空间。在这样的处理下，变量就成为了一个编译期间的常量，没有了对变量的存储和读取内存的操作，使得代码执行的效率得到提高。同时，变量的值被保存到符号表中，在需要变量的地方用符号表中保存的值直接替换，从而保证了变量的值不被修改，提高了代码的安全性。</p>
<p>需要注意的是，<code>const</code>并不是绝对的保证，因为通过类型转换或指针操作，可能会绕过<code>const</code>限制。但是，大多数情况下，<code>const</code>提供了一种有效的方法来声明和使用常量，并且可以帮助编译器进行更好的优化。</p>
<ul>
<li>被修饰的常量是基本类型且是局部变量<ul>
<li>编译器会预先替换变量的引用（常量折叠）</li>
<li>持续占据内存空间（在栈上）</li>
</ul>
</li>
<li>被修饰的常量是全局变量<ul>
<li>当全局const变量被取地址时，会导致全局const变量占用存储空间。</li>
</ul>
</li>
</ul>
<p>const不被修改的原理</p>
<ul>
<li>编译器检查</li>
<li>操作系统将内存区设为只读</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> j=<span class="number">100</span>;    </span><br><span class="line"><span class="type">int</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;j);    </span><br><span class="line"><span class="comment">//int *p = (int *)&amp;j;</span></span><br><span class="line">*p=<span class="number">200</span>;    </span><br><span class="line">cout&lt;&lt;j&lt;&lt;endl;<span class="comment">//100,被编译器替换成立即数了 </span></span><br></pre></td></tr></table></figure>

<p>C语言中只是检查代码是否修改const，不是真正意义上的const</p>
<h4 id="const作用"><a href="#const作用" class="headerlink" title="const作用"></a>const作用</h4><ul>
<li>修饰变量，说明该变量不可以被改变;</li>
<li>修饰指针，分为指向常量的指针(pointer to const)和自身是常量的指针(常量指针，const pointer);</li>
<li>修饰引用，指向常量的引用(reference to const)，用于形参类型，即避免了拷贝，又避免了函数对值的修改;</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
<li>修饰成员函数的返回值，说明返回值不能是左值</li>
</ul>
<h5 id="const-int-和-int-const"><a href="#const-int-和-int-const" class="headerlink" title="const int* 和 int* const"></a>const int* 和 int* const</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p; <span class="comment">//p可变,p指向的内容不可变</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* p; <span class="comment">//p可变,p指向的内容不可变</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p; <span class="comment">//p不可变,p指向的内容可变</span></span><br></pre></td></tr></table></figure>

<h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ypshowm/article/details/89030194">https://blog.csdn.net/ypshowm/article/details/89030194</a></p>
<ul>
<li>c&#x2F;c++共有<ul>
<li>修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。<ul>
<li>该变量在全局数据区分配内存； </li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）； </li>
<li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</li>
</ul>
</li>
<li>修饰局部变量时，表明该变量的值不会因为函数终止而丢失。<ul>
<li>该变量在全局数据区分配内存； </li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； </li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0； </li>
<li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li>
</ul>
</li>
<li>修饰函数时，表明该函数只在同一文件中调用。<ul>
<li>静态函数不能被其它文件所用； </li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突；</li>
</ul>
</li>
</ul>
</li>
<li>c++独有：<ul>
<li>修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。<ul>
<li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</li>
<li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li>
</ul>
</li>
<li>用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量</li>
</ul>
</li>
</ul>
<h4 id="static初始化"><a href="#static初始化" class="headerlink" title="static初始化"></a>static初始化</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/duskymountain/article/details/133811006">https://blog.csdn.net/duskymountain/article/details/133811006</a></p>
<p>1.静态初始化<br>static initialization：指的是用<strong>常量</strong>来对静态变量进行初始化，包括zero initialization和const initialization，</p>
<ul>
<li>zero initialization的变量会保存在.bss段（未初始化静态变量，以及初始化为0的静态变量）</li>
<li>const initialization的变量保存在.data段(已经初始化为非0的静态变量)。</li>
</ul>
<p>对于静态初始化的变量（请注意：包括在函数中采用静态初始化的静态变量），是在<strong>程序编译时</strong>完成的初始化。</p>
<p>2.动态初始化<br>dynamic initialization：指的是需要调用函数才能完成的初始化，比如类的构造函数。</p>
<ul>
<li>对于全局变量或者类的静态成员变量，是在main()函数执行前的<strong>加载阶段</strong>时调用相应的代码进行初始化的。</li>
<li>对于局部静态变量，是在函数执行至此<strong>初始化语句</strong>时才开始执行的初始化。</li>
</ul>
<ol>
<li>静态变量的<strong>初始化</strong>是在编译时进行，变量的<strong>赋值</strong>是在函数或程序运行时进行。</li>
<li>静态变量只初始化一次，但可以通过赋值的方式多次修改静态变量的值。</li>
<li>全局变量和静态变量 在进入 main 前被初始化</li>
<li>局部静态变量是进入<strong>函数执行至此初始化语句</strong>时才开始执行的初始化</li>
</ol>
<h4 id="const初始化"><a href="#const初始化" class="headerlink" title="const初始化"></a>const初始化</h4><ul>
<li><p>类的const成员变量必须在构造函数的参数<strong>初始化列表</strong>中进行初始化。</p>
</li>
<li><p>c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放。</p>
</li>
<li><p>而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放。</p>
</li>
<li><p>对于基础数据类型，也就是const int a &#x3D; 10这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配内存</p>
</li>
<li><p>对于基础数据类型，如果用一个变量初始化const变量，如果const int a &#x3D; b,那么也是会给a分配内存</p>
</li>
<li><p>对于自定数据类型，比如类对象，那么也会分配内存。</p>
</li>
</ul>
<p>而c++中，一个const不是必需创建内存空间，而在c中，一个const总是需要一块内存空间。</p>
<p>在c++中是否要为const全局变量分配内存空间，取决于这个const变量的用途，如果是充当着一个值替换（即就是将一个变量名替换为一个值），那么就不分配内存空间，不过当对这个const全局变量取地址或者使用extern时，会分配内存，存储在只读数据段。也是不能修改的。</p>
<ul>
<li>const修饰的局部变量在栈上分配内存空间</li>
<li>const修饰的全局变量在只读存储区分配内储存空间</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型&#x2F;初始化</th>
<th>类内</th>
<th>类外</th>
<th>构造函数</th>
<th>初始化列表</th>
</tr>
</thead>
<tbody><tr>
<td>非静态非常量</td>
<td>X</td>
<td>X</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>非静态常量</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td><strong>√</strong></td>
</tr>
<tr>
<td>静态非常量</td>
<td>X</td>
<td><strong>√</strong></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>静态常量</td>
<td>√</td>
<td>√</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>无论静态函数还是非静态函数,都是属于类的(这一点与数据成员的静态非静态不同),对象并不拥有函数的拷贝.两者的区别在于:非静态的函数由类对象(加.或指针加-&gt;;)调用,这时将向函数传递this指针.而静态函数由类名(::)(或对象名.)调用,但静态函数不传递this指针,不识别对象个体,所以通常用来对类的静态数据成员操作.</p>
<p>访问成员函数时通常会隐式携带this指针指向对应的对象</p>
<p>this指针初始化：和函数参数一样，但是先进后出，先于成员函数的形参初始化，出作用域后销毁</p>
<h4 id="内存分配模型"><a href="#内存分配模型" class="headerlink" title="内存分配模型"></a>内存分配模型</h4><p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTgwMTk=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>C++程序在执行时，将内存大方向划分为<strong>5个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量</li>
<li>常量区：存放常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
<li>运行前<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量（可以是局部静态变量）</li>
<li><strong>常量区</strong>中存放 const修饰的全局常量 和 字符串常量</li>
</ul>
</li>
<li>运行中<ul>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配释放,若程序员不释放,程序结束时由操作系统回收，在C++中主要利用new在堆区开辟内存</li>
</ul>
</li>
</ul>
<h5 id="栈内存与堆内存的分配"><a href="#栈内存与堆内存的分配" class="headerlink" title="栈内存与堆内存的分配"></a>栈内存与堆内存的分配</h5><p><strong>堆内存分配</strong>：</p>
<ul>
<li>堆内存的分配是在程序运行时通过<strong>动态内存分配函数</strong>（如<code>new</code>、<code>malloc</code>）或操作系统提供的相应系统调用（如<code>brk</code>、<code>sbrk</code>）来进行的。</li>
<li>当程序执行到动态内存分配语句时，会向操作系统请求一定大小的堆内存。操作系统会在堆区中找到合适大小的空闲内存，分配给程序，并返回一个指向该内存块的指针。</li>
<li>开发者在不再需要堆内存时，需要显式地通过动态内存释放函数（如<code>delete</code>、<code>free</code>）或系统调用来释放已分配的堆内存。</li>
</ul>
<h6 id="堆内存慢的原因"><a href="#堆内存慢的原因" class="headerlink" title="堆内存慢的原因"></a>堆内存慢的原因</h6><p>堆的分配速度相对较慢主要是由于以下几个原因：</p>
<ol>
<li>内存碎片化：堆内存的分配和释放过程中会产生内存碎片，也就是已分配但未使用的小块内存。当需要分配内存时，系统需要搜索合适的空闲内存块，而碎片化会导致搜索时间增加，从而影响分配速度。</li>
<li>分配算法的开销：堆内存的分配通常使用的是复杂的分配算法（如首次适应、最佳适应等），这些算法会增加分配过程的开销，包括搜索空闲块、更新内存管理数据结构等。</li>
<li>系统调用的开销：堆内存的分配通常需要通过系统调用来申请更多的内存空间。系统调用涉及内核态和用户态之间的切换，会引入较大的开销，从而导致分配速度变慢。</li>
<li>间接寻址：需要先找存放地址的指针再找实际对象，第一步将分配的地址放到寄存器，然后取出这个地址的值，然后放到目标地址。</li>
</ol>
<p>为了解决堆的分配速度较慢的问题，可以考虑以下几种方案：</p>
<ol>
<li>内存池：使用内存池管理堆内存，通过预先申请一大块内存并进行划分，避免频繁的系统调用和内存碎片化。内存池可以提前分配一定数量的内存块，当需要分配内存时，直接从内存池中获取，提高了分配速度。</li>
<li>自定义分配器：可以使用自定义的内存分配器来替代标准库提供的分配器。自定义分配器可以根据具体应用场景和需求设计更高效的内存分配算法，提高分配速度。</li>
<li>内存复用：尽量复用已经分配过的内存块，避免频繁的分配和释放操作，从而减少内存碎片化和分配算法的开销。</li>
<li>对象池：对于频繁创建和销毁的对象，可以考虑使用对象池技术。对象池预先创建一定数量的对象，当需要时直接从池中获取对象，使用完后放回池中，避免频繁的对象创建和销毁操作，提高性能。</li>
<li>预分配内存：在程序初始化阶段或空闲时间段，预先分配一部分内存，并进行预处理，减少实际分配内存的开销。</li>
</ol>
<h6 id="栈内存快的原因"><a href="#栈内存快的原因" class="headerlink" title="栈内存快的原因"></a>栈内存快的原因</h6><ul>
<li><p>栈指针，后进先出</p>
</li>
<li><p>栈结构，扩容收缩方便，</p>
</li>
<li><p>栈中数据cpu命中率更高，满足局部性原理。</p>
</li>
<li><p>寄存器指令：有寄存器直接对栈进行访问</p>
</li>
</ul>
<p><strong>栈内存分配</strong>：</p>
<ul>
<li>栈内存的分配是在程序运行时由<strong>编译器自动完成</strong>的。</li>
<li>当程序执行到<strong>函数调用</strong>语句时，编译器将为函数分配一块新的栈帧（stack frame）用于存储函数的局部变量、函数参数和其他相关信息。</li>
<li>栈帧的大小在编译时就可以确定，通常在函数调用前就会为其分配栈空间。</li>
<li>函数执行完毕后，对应的栈帧会被销毁，释放栈内存。</li>
</ul>
<h6 id="栈内存不支持动态扩容的原因"><a href="#栈内存不支持动态扩容的原因" class="headerlink" title="栈内存不支持动态扩容的原因"></a>栈内存不支持动态扩容的原因</h6><ul>
<li>每个线程有独立栈，留很多预留空间就是浪费，全分了也浪费，不如写死</li>
<li>栈要求是连续空间，需求完全无法预测，防止用户爆栈导致oom</li>
</ul>
<h6 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h6><p>一个函数调用的过程通常包括以下步骤：</p>
<ol>
<li><strong>函数调用语句</strong>：在程序中遇到函数调用语句时，会触发函数的执行。函数调用语句包括函数名和参数列表，用于指定要调用的函数以及传递给函数的参数。</li>
<li><strong>保存返回地址</strong>：在函数调用之前，当前函数的执行状态（包括下一条指令的地址）需要保存。为此，将返回地址（即当前函数调用后需要继续执行的下一条指令的地址）压入栈中。</li>
<li><strong>创建栈帧</strong>：为被调用的函数创建一个新的<strong>栈帧（stack frame）</strong>，用于存储该函数的局部变量、函数参数和其他相关信息。栈帧通常由栈指针和帧指针来管理。</li>
<li><strong>传递参数</strong>：将函数调用语句中的参数值传递给被调用函数。传递参数的方式可以是通过寄存器、栈或者混合使用。</li>
<li><strong>跳转到被调用函数</strong>：程序将跳转到被调用函数的入口点，开始执行被调用函数的代码。</li>
<li><strong>函数执行</strong>：被调用函数开始执行自己的代码。它可以使用传递的参数值、访问局部变量，并执行相应的计算和操作。</li>
<li><strong>返回值传递</strong>：如果被调用函数有返回值，它会将返回值存储在特定的寄存器或内存位置中。</li>
<li><strong>恢复栈帧</strong>：当被调用函数执行完毕后，将释放其所占用的栈帧，并恢复上一级函数的栈帧。</li>
<li><strong>恢复返回地址</strong>：从栈中弹出返回地址，并将程序的执行状态恢复到调用函数的下一条指令，以继续执行。</li>
<li><strong>继续执行</strong>：程序继续执行调用函数之后的指令，使用返回值（如果有）或进行其他操作。</li>
</ol>
<ul>
<li>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li>
<li>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li>
</ul>
<h5 id="栈回溯"><a href="#栈回溯" class="headerlink" title="栈回溯"></a>栈回溯</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013318019/article/details/104040516">https://blog.csdn.net/u013318019/article/details/104040516</a></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTgwMTk=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTgwMTk=,size_16,color_FFFFFF,t_70-17141882211862.png" alt="img"></p>
<ul>
<li>寄存器ebp（base pointer ）可称为“帧指针”或“基址指针”，其实语意是相同的。</li>
<li>寄存器esp（stack pointer）可称为“ 栈指针”。</li>
</ul>
<h4 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h4><ul>
<li>栈内存连续，用完就释放，堆不连续，用完手动释放&#x2F;GC</li>
<li>栈放变量，堆放对象，地址传给栈的变量</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>申请方式的不同。栈由系统自动分配，而堆是人为申请开辟;</li>
<li>申请大小的不同。栈获得的空间较小，而堆获得的空间较大;</li>
<li>申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢;</li>
<li>存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;</li>
<li>底层不同。栈是连续的空间，而堆是不连续的空间。</li>
</ul>
<h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><ul>
<li>大量局部变量</li>
<li>死循环</li>
<li>无限递归</li>
</ul>
<h5 id="栈溢出保护"><a href="#栈溢出保护" class="headerlink" title="栈溢出保护"></a>栈溢出保护</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ATFWUS/article/details/104552315">https://blog.csdn.net/ATFWUS/article/details/104552315</a></p>
<h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><p>默认4字节对齐（？），可以通过**<strong>attribute</strong>((arg))<strong>调整是否对齐，通过</strong>#pragma pack(n)**调整对齐系数</p>
<p>好处就是加速寻址，提高读取效率</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>pointer</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>enum</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>union</td>
<td>取 union 中最大一个变量类型大小</td>
<td>取 union 中最大一个变量类型大小</td>
</tr>
</tbody></table>
<p><strong>结构体嵌套</strong>：子结构体的成员变量<strong>起始地址要视子结构体中最大变量类型决定</strong></p>
<p>union:取 union 中最大一个变量类型大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu2</span> &#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="type">char</span> v[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu1</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">u1</span> &#123;</span><br><span class="line">        <span class="type">int</span> a1;</span><br><span class="line">        <span class="type">char</span> a2[<span class="number">5</span>];</span><br><span class="line">    &#125;a;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stu2</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%85%AB%E8%82%A1/5f3132d640804c61bd8a969298a9c501.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu2</span> &#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="type">char</span> v[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu1</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stu2</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="/images/%E5%85%AB%E8%82%A1/375880a888ba49d8b0c875e0660f41dd.png" alt="img"></p>
<p>C#的结构体上可以选择特性<strong>LayoutKind</strong>，控制是否使用内存对齐</p>
<p>什么时候不希望进行内存对齐：内存紧缺的嵌入式设备，硬件支持情况</p>
<h4 id="malloc-x2F-free-amp-nbsp-和new-x2F-delete的区别"><a href="#malloc-x2F-free-amp-nbsp-和new-x2F-delete的区别" class="headerlink" title="malloc&#x2F;free&amp;nbsp;和new&#x2F;delete的区别"></a>malloc&#x2F;free&amp;nbsp;和new&#x2F;delete的区别</h4><p>前者只分配内存空间，后者可以额外完成执行构造函数和析构函数，更好分配管理内存</p>
<p>只能对应用，交替用不合逻辑</p>
<ul>
<li>new操作符从自由存储区（free store）(由 operator new实现决定, 可以是堆也可以是静态存储区)上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</li>
<li>new返回对象类型指针, malloc返回void*</li>
<li>new无需指定分配内存大小, malloc需要指定大小</li>
<li>new分配完成后调用构造函数, malloc不调用</li>
<li>分配失败, new抛出异常, malloc返回NULL</li>
</ul>
<h5 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载全局的 operator new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Custom operator new called. Size: &quot;</span> &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);  <span class="comment">// 使用标准的 malloc 函数分配内存</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载全局的 operator delete</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Custom operator delete called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">free</span>(ptr);  <span class="comment">// 使用标准的 free 函数释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* buffer = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyClass));  <span class="comment">// 预分配内存块</span></span><br><span class="line">MyClass* obj = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">42</span>);  <span class="comment">// 使用 placement new</span></span><br><span class="line">obj-&gt;~<span class="built_in">MyClass</span>();  <span class="comment">// 手动调用析构函数</span></span><br><span class="line"><span class="built_in">free</span>(buffer);  <span class="comment">// 释放内存块</span></span><br></pre></td></tr></table></figure>

<p><strong>delete如何知道该释放多大的空间，这些信息存在什么位置</strong></p>
<p>当使用<code>new</code>运算符分配内存时，会在内存中存储有关分配的大小信息。具体来说，<code>new</code>运算符通常会在分配的内存块前面存储一个额外的字节，其中包含了分配的内存大小。这个大小信息通常由操作系统或编译器提供，并且通常是以某种形式进行对齐。</p>
<p><strong>new delete，new[] delete[]一定要配对使用吗？为什么？</strong></p>
<ul>
<li><p><strong>new和delete</strong></p>
<p>  new和delete主要是为了为那些自定义类型的对象开辟空间，因为这些对象在创建的时候要自动执行构造函数，消亡的时候要执行析构函数，对于自定义类型对象如果不配对使用的话，可能会出现没有析构干净的情况</p>
</li>
<li><p><strong>new[]和delete[]</strong></p>
<p>  我们再用new[]创建数组的时候，比如一个对象大小为N，则K个数组需要K*N个空间来构造。那当delete的时候如何知道这个数组空间的大小呢？我们会在new出来的这个空间的头部申请一个int类型的字节，4字节用来存储数组的长度，这样调用delete[]的时候就知道数组的大小，才会调用K次析构函数，释放K * N + 4字节大小的内存。</p>
<p>  下面针对自定义类型变量：</p>
<p>  如果new和delete[]使用，delete的时候会找前4个字节，看要释放的内存有多大。但是使用new导致没有设备区部分4个字节用来存放数组长度，这样会导致这4个字节是未定义的，因此会调用不定次的delete。同时比如说其实地址为A，应该从A开始释放，现在会从A-4开始释放。</p>
<p>  如果new[]和delete一起使用，程序会认为这是一个对象占用的空间，而不是数组，因此就析构一次。同时释放的是new[]中表示长度的前4个字节的地址，应该从A-4开始释放，如果不从头释放的话回出问题。</p>
</li>
<li><p>当new[]中的数组元素是基本类型时，通过delete和delete[]都可以释放数组空间；</p>
</li>
<li><p>但是当new[]中的数组元素是自定义类型时，只能通过delete[]释放数组空间。因为当数组中的元素是自定义类型时，delete在释放空间时只会调用数组中首个元素的析构函数，而delete[]在释放空间时会调用数组中所有元素的析构函数。</p>
</li>
</ul>
<h5 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h5><p>语法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object * p = <span class="built_in">new</span> (address) <span class="built_in">ClassConstruct</span>(...);</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先分配一对内存</span></span><br><span class="line"><span class="type">int</span>* buff = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此处new的placement new，在buff的内存上构造int对象，不需要分配额外的内存</span></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">new</span> (buff)<span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>让对象只能创建在栈&#x2F;堆上</strong></p>
<p>只在栈上：重载new&#x2F;delete并设为私有</p>
<p>只在堆上：将构造函数设为私有</p>
<h5 id="alloc-x2F-allocate-x2F-deallocate"><a href="#alloc-x2F-allocate-x2F-deallocate" class="headerlink" title="alloc&#x2F;allocate&#x2F;deallocate"></a>alloc&#x2F;allocate&#x2F;deallocate</h5><p>allocate 包装malloc，deallocate包装free</p>
<p>alloc在栈上分配内存，不会爆栈，但是会越界</p>
<h4 id="深浅复制"><a href="#深浅复制" class="headerlink" title="深浅复制"></a>深浅复制</h4><p><strong>深拷贝：</strong>指的是拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝。这样进行深拷贝后的拷贝对象就和源对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。</p>
<p><strong>浅拷贝：</strong>指的是拷贝一个对象时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。</p>
<p>c++中实现深拷贝主要靠拷贝构造函数中为新对象新分配内存，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student::<span class="built_in">Student</span>(<span class="type">const</span> Student &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	name = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(name, s.name, <span class="built_in">strlen</span>(s.name));  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;copy Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="强制类型转换cast"><a href="#强制类型转换cast" class="headerlink" title="强制类型转换cast"></a>强制类型转换cast</h4><p><strong>static_cast</strong></p>
<p>实现C++种内置基本数据类型之间的相互转换，不能用于两个不相关类型进行转换。</p>
<ul>
<li>用于类层次结构中基类和派生类之间引用或指针的转换。</li>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的。</li>
<li>进行下行转换（把基类的指针或引用转换成派生类表示），由于没有动态类型检查，不安全。</li>
<li>用于基本数据类型之间的转换</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(b);</span><br></pre></td></tr></table></figure>

<p><strong>dynamic_cast</strong></p>
<p>用于将一个父类对象的指针&#x2F;引用转换为子类对象的指针或引用（动态转换）。<strong>运行时完成，其他都是编译时完成</strong></p>
<ul>
<li>type_id 必须是类的指针、类的引用或者void*。</li>
<li>主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。</li>
<li>dynamic_cast只能用于含有虚函数的类；</li>
<li><strong>进行上行转换的时候，与static_cast 的作用一样。下行转换的时候，具有类型检查的功能，比static_cast更安全。</strong></li>
<li>dynamic_cast会先检查是否能转换成功，如果能则转换，不能则返回nullptr。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(B *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D *pd1 = <span class="built_in">static_cast</span>(pb);</span><br><span class="line">    D *pd2 = <span class="built_in">dynamic_cast</span>(pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 dynamic_cast 进行转换的，<strong>基类中一定要有虚函数</strong>，因为虚函数表中有运行时类型信息，这样才知道能不能转</p>
<p>dynamic_cast和虚函数的区别：<strong>dynamic_cast是为了使用子类的非虚方法或成员变量</strong></p>
<p><strong>const_cast</strong></p>
<p>const_cast 是用来强制去掉const这种不能被修改的常数特性。不是去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，对象必须为指针或引用。</p>
<p>用来修改类型的const或volatile属性。</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p = &amp;a;</span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">q = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(p);</span><br><span class="line">*q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br></pre></td></tr></table></figure>

<p><strong>reinterpret_cast</strong></p>
<p>通常为操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不同的类型。</p>
<p>例如：double&#x2F;float-&gt;int会变成奇怪的数，因为浮点数计数方式和int不同</p>
<p>type_id 必须是一个指针、引用、算术类型、函数指针、成员指针。</p>
<p>应用场景：</p>
<ul>
<li>改变指针或引用的类型</li>
<li>将整形与指针或引用互相转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">double</span> *d = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<h5 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/118541570">https://blog.csdn.net/weixin_43798887/article/details/118541570</a></p>
<p>Runtime Type Identification 运行时类型识别</p>
<p>（1）typeid运算符，该运算符返回其表达式或类型名的实际类型。返回指针和引用所指的实际类型；</p>
<p>（2）dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。</p>
<p>为了获得一个对象的类型可以使用typeid函数，该函数反回一个对type_info类对象的引用，要使用typeid必须使用头文件<code>&lt;typeinfo&gt;</code>，因为typeid是一个返回类型为typ_info的引用的函数</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzAxNjI4,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>首先，我们要理解<strong>内存碎片的类型</strong>：内存碎片大致分为两类，外部碎片和内部碎片。</p>
<ul>
<li>外部碎片是因为内存中分布了许多小的、不连续的空闲区域，导致无法满足较大的内存分配请求。</li>
<li>内部碎片是指分配给程序的内存块中未被利用的部分。</li>
</ul>
<p>那么，就有处理内存碎片的方式有几个策略：</p>
<ol>
<li><strong>使用内存池</strong>：内存池是一种预先分配一大块内存，然后按需从中分配小块内存的策略。这样可以减少外部碎片的产生，因为内存是从一个连续的内存块中分配的。</li>
<li><strong>对象池</strong>：对于频繁创建和销毁的小对象，可以使用对象池。对象池预先分配一定数量的对象，并在需要时重新使用这些对象，而不是频繁地创建和销毁。</li>
<li><strong>优化内存分配策略</strong>：比如使用适合应用需求的内存分配器，例如 jemalloc 或 tcmalloc，这些分配器通常比默认的 malloc 更有效地管理内存，减少碎片化。</li>
<li><strong>避免小内存块的频繁分配</strong>：尽可能地合并小内存块的分配请求，减少内存碎片的产生。</li>
<li><strong>内存压缩和重分配</strong>：在长时间运行的应用中，可以考虑定期对内存进行压缩和重分配，将小的碎片合并成较大的连续空间。</li>
<li><strong>使用智能指针管理内存</strong>：使用 C++ 的智能指针如 std::unique_ptr 和 std::shared_ptr 可以帮助自动管理内存，减少内存泄漏的风险，间接减少碎片化。</li>
</ol>
<h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hansionz/article/details/83827329">https://blog.csdn.net/hansionz/article/details/83827329</a></p>
<h5 id="C-模板和-C-泛型之间的区别"><a href="#C-模板和-C-泛型之间的区别" class="headerlink" title="C++ 模板和 C# 泛型之间的区别"></a>C++ 模板和 C# 泛型之间的区别</h5><p>C# 泛型和 C++ 模板都是用于提供参数化类型支持的语言功能。 然而，这两者之间存在许多差异。 在语法层面上，C# 泛型是实现参数化类型的更简单方法，不具有 C++ 模板的复杂性。 此外，C# 并不尝试提供 C++ 模板所提供的所有功能。 在实现层面，主要区别在于，C# 泛型类型替换是在运行时执行的，从而为实例化的对象保留了泛型类型信息。 有关更多信息，请参见 <a target="_blank" rel="noopener" href="https://technet.microsoft.com/zh-cn/library/f4a6ta2h(v=vs.120)">运行时中的泛型（C# 编程指南）</a>。</p>
<ol>
<li><p>C#泛型无法调用算术运算符，而C++模板可以。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 泛型示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T a, T b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 无法调用算术运算符</span></span><br><span class="line">        <span class="comment">// 编译错误：Operator &#x27;+&#x27; cannot be applied to operands of type &#x27;T&#x27; and &#x27;T&#x27;</span></span><br><span class="line">        T result = a + b; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T a, T b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T result = a + b; <span class="comment">// 可以调用算术运算符</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C#不允许非类型模板参数，如<code>template C&lt;int i&gt; &#123;&#125;</code>。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;<span class="built_in">int</span> i&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 泛型无法实现同样的功能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C#不支持显式专用化，即特定类型的模板的自定义实现。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// int类型的专用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 泛型无法实现同样的功能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C#不支持部分专用化：类型参数子集的自定义实现。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span>&lt;<span class="title">int</span>, <span class="title">U</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 部分专用化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 泛型无法实现同样的功能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C#不允许将类型参数用作泛型类型的基类。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 泛型示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; : <span class="title">T</span> <span class="comment">// 编译错误：Type parameter cannot be used as the base type of a class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span> : <span class="title">T</span> <span class="comment">// 可以将类型参数用作基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C#不允许类型参数具有默认类型。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 泛型示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span> = <span class="title">int</span>&gt; <span class="comment">// 编译错误：The type or namespace name &#x27;T&#x27; could not be found</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;typename T = <span class="built_in">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C#泛型类型参数不能是泛型类型，而C++允许。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 泛型示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&lt;<span class="title">U</span>&gt;&gt; <span class="comment">// 编译错误：The type or namespace name &#x27;U&#x27; could not be found</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span>&lt;<span class="title">T</span>&lt;<span class="title">U</span>&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++允许在模板中编写可能并非对所有类型参数都有效的代码，而C#要求类中的代码适用于满足约束的任何类型。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 模板示例</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TemplateClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">T obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.SomeMethod(); <span class="comment">// 假设SomeMethod()只在部分类型中有效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 泛型示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">ISomeInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">T obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.SomeMethod(); <span class="comment">// 只能在满足约束的类型中调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="模板特化与萃取"><a href="#模板特化与萃取" class="headerlink" title="模板特化与萃取"></a>模板特化与萃取</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hansionz/article/details/85219139">https://blog.csdn.net/hansionz/article/details/85219139</a></p>
<ul>
<li>特化：预先指定泛型的其中一部分（或全部）类型并给出对应实现<ul>
<li>偏特化：给出一部分类型</li>
<li>全特化：给出全部类型</li>
</ul>
</li>
<li>萃取：通过类模板中对不同的类型进行不同的特化区分（萃取）出需要执行不同操作的类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内置类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrueType</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FalseType</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通用模板，默认IsPodType是false</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeTraits</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> FalseType IsPodType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用所有内置类型对该模板特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeTraits</span>&lt;<span class="type">int</span>&gt;<span class="comment">//float，double等实现相同，略</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> TrueType IsPodType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实现一个真正的通用方法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(T* dst, T* src, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (TypeTraits&lt;T&gt;::IsPodType::<span class="built_in">Get</span>())</span><br><span class="line">		<span class="built_in">memcpy</span>(dst, src, <span class="built_in">sizeof</span>(T)*size);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			dst[i] = src[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>模板不支持分离编译</strong></li>
<li><strong>解决方法：</strong><ul>
<li>将声明和定义放到一个文件 <code>xxx.hpp</code> 里面或者<code>xxx.h</code></li>
<li>模板定义的位置<code>显式实例化</code>，不常用，因为这样做就降低了模板的好处</li>
<li>使用过程中<code>不要将声明和定义</code>分离</li>
</ul>
</li>
</ul>
<p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbnNpb256,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>POD：Plain Old Data，平凡数据类型，指的是基本数据类型、指针、union、数组、构造函数是 trivial 的 struct 或者 class。换言之就是符合C语言风格的数据结构</p>
<p>如果一个类或结构是平凡的，具有标准布局的，且不包含任何非POD的非静态成员，那么它就被认定是POD。平凡的类或结构定义如下：</p>
<p>1.具有一个平凡的缺省构造器。（可以使用缺省构造器语法，如 SomeConstructor() &#x3D; default;)</p>
<p>2.具有一个平凡的拷贝构造器。（可以使用缺省构造器语法)</p>
<p>3.具有一个平凡的拷贝赋值运算符。（可以使用缺省语法)</p>
<p>4.具有一个非虚且平凡的析构器。</p>
<p>一个具有标准布局的类或结构被定义如下：</p>
<p>1.所有非静态数据成员均为标准布局类型。</p>
<p>2.所有非静态成员的访问权限(public, private, protected) 均相同。</p>
<p>3.没有虚函数。</p>
<p>4.没有虚基类。</p>
<p>5.所有基类均为标准布局类型。</p>
<p>6.没有任何基类的类型与类中第一个非静态成员相同。</p>
<p>7.要么全部基类都没有非静态数据成员，要么最下层的子类没有非静态数据成员且最多只有一个基类有非静态数据成员。总之继承树中最多只能有一个类有非静态数据成员。所有非静态数据成员必须都是标准布局类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ~A() = <span class="keyword">default</span>;                    <span class="comment">// trivially copyable</span></span><br><span class="line">    A() &#123;&#125;                             <span class="comment">// trivially copyable</span></span><br><span class="line">    A(<span class="type">const</span> A &amp;) = <span class="keyword">default</span>;            <span class="comment">// trivially copyable</span></span><br><span class="line">    A(A &amp;&amp;) = <span class="keyword">default</span>;                 <span class="comment">// trivially copyable</span></span><br><span class="line">    A &amp;operator=(<span class="type">const</span> A &amp;) = <span class="keyword">default</span>; <span class="comment">// trivially copyable</span></span><br><span class="line">    A &amp;operator=(A &amp;&amp;) = <span class="keyword">default</span>;      <span class="comment">// trivially copyable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>区分是否平凡的作用：根据类型选取更高效的内存分配方式（调用 复制构造函数 vs memmove）</p>
<p><strong>SFINAE</strong></p>
<p>Substitution failure is not an error</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21314708">https://zhuanlan.zhihu.com/p/21314708</a></p>
<h4 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h4><p>值传递：</p>
<ol>
<li>参数的值被复制：在值传递中，调用函数时，实际参数的值被复制到函数的形式参数中。这意味着在函数内部对形式参数的修改不会影响到实际参数。</li>
<li>独立的变量：在函数内部，形式参数是独立的变量，对其进行修改不会影响到实际参数。</li>
<li>适用于简单数据类型：值传递适用于传递简单数据类型（如整数、浮点数、布尔值等）或者较小的数据结构。<ul>
<li>函数中直接使用栈上内容，不用二次寻址，效率高</li>
</ul>
</li>
</ol>
<p>引用传递：</p>
<ol>
<li>参数的引用被传递：在引用传递中，调用函数时，实际参数的引用（内存地址）被传递给函数的形式参数。这意味着在函数内部对形式参数的修改会影响到实际参数。</li>
<li>共享同一变量：在函数内部，形式参数和实际参数引用的是同一个变量，对形式参数的修改会反映到实际参数上。</li>
<li>适用于大型数据结构：引用传递适用于传递大型数据结构（如数组、对象、结构体等），避免了复制整个数据结构的开销。<ul>
<li>函数中通过地址找到引用内容，不用额外复制，效率高</li>
</ul>
</li>
</ol>
<h4 id="struct和union的区别"><a href="#struct和union的区别" class="headerlink" title="struct和union的区别"></a>struct和union的区别</h4><p><strong>结构体 (<code>struct</code>)</strong> 是一种能够同时存储不同类型的多个成员（字段）的数据类型。每个成员都有自己的内存空间，它们会依次存储在内存中。结构体的大小等于其所有成员的大小之和。</p>
<p><strong>联合体 (<code>union</code>)</strong> 是一种特殊的数据类型，它允许在相同的内存空间中存储不同类型的数据，但只能同时存储其中一个成员（先存的会被覆盖）。联合体的大小等于其最大成员的大小（根据成员决定内存对齐，如int+char[13]&#x3D;16,char+char[13]&#x3D;13）。</p>
<h4 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h4><ol>
<li>**预处理 (Preprocessing)**：预处理器会处理源文件中的预处理指令，如宏展开、头文件包含等。预处理的输出是一个经过宏替换和条件编译处理的新的源文件。后缀.cpp&#x2F;.cxx</li>
<li>**编译 (Compilation)**：编译器将预处理后的源文件翻译成汇编语言。它会对每个函数进行语法分析、语义分析、优化等操作，并生成相应的汇编代码文件。后缀.s&#x2F;.asm</li>
<li>**汇编 (Assembly)**：汇编器将汇编代码文件转换为机器码指令的目标文件。它会将汇编代码转换为与特定硬件架构相关的机器指令。后缀.o&#x2F;.obj&#x2F;.co</li>
<li>**链接 (Linking)**：链接器将编译器生成的目标文件与所需的库文件进行链接，生成最终的可执行文件。链接器解析函数调用、符号引用等，将目标文件和库文件中的代码、数据整合在一起，并生成可执行文件。后缀.exe</li>
</ol>
<h4 id="动静链接"><a href="#动静链接" class="headerlink" title="动静链接"></a>动静链接</h4><ul>
<li>静态编译：编译器在编译可执行文件时，把需要用到的对应动态链接库(.so或.ilb)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库.</li>
<li>动态编译: 动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点一 方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</li>
</ul>
<p>动态链接库：<br>创建一个动态链接库,会生成x.dll,x.lib<br>动态链接库有两种加载方式:</p>
<p>1.一种是静态加载，就是在编译的时候就载入动态链接库。此种方法可调用类方法.<br>可执行程序静态加载动态链接库需要三个文件 x.dll, x.lib, x.h<br>可执行程序的头文件加入：<br>#include “x.h”<br>#pragma comment(lib,”x.lib”)<br>编译时还要附加库目录，防止程序编译时无法找到x.dll。</p>
<p>2.动态加载<br>只需要x.dll文件。<br>在程序执行需要该动态链接库的地方加载x.dll。<br>然后获取需要的x.dll库里面的函数或数据.<br>该方法不能调用类方法.</p>
<p>静态链接库：<br>创建一个静态链接库，会生成x.lib文件<br>想要调用静态链接库里面的内容需要x.lib文件和x.h文件<br>库中内容会直接编译到x.exe文件中。<br>可执行程序使用静态库编译成x.exe后，x.exe的运行就不在需要静态链接库了，可以独立运行了。</p>
<p>内联函数的函数体不建议放在 .cpp 文件里面，因为内联函数需要在每个调用它的地方进行代码插入，而编译器在编译每个源文件时只能看到该源文件中包含的内容。如果将内联函数的函数体放在 .cpp 文件中，则其他源文件无法访问到函数的定义，无法进行代码插入。</p>
<p>有些情况下内联函数的函数体也可以放在 .cpp 文件中，例如：</p>
<ul>
<li>当内联函数只在某个特定的源文件中使用，并且不需要被其他源文件访问时，可以将函数体放在 .cpp 文件中。</li>
<li>在某些特殊的情况下，编译器可能能够根据整个程序的上下文进行函数的内联展开，即使函数体放在 .cpp 文件中也能够实现内联的效果。这通常取决于编译器的具体实现和优化策略。</li>
</ul>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>把函数展开，省去压栈操作，适用于常用的小型函数（语句数小于5）</p>
<ul>
<li>优点<ul>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
<li>可以说inline函数不仅吸收了了C宏定义的，同时消除宏定义的缺点。</li>
</ul>
</li>
<li>缺点<ul>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译。</li>
<li>万一又递归调用，代码量很大。（一般来说编译器会忽略复杂函数）</li>
</ul>
</li>
</ul>
<h4 id="include-lt-gt-和-include-“”区别"><a href="#include-lt-gt-和-include-“”区别" class="headerlink" title="#include&lt;&gt;和#include “”区别"></a>#include&lt;&gt;和#include “”区别</h4><ul>
<li>#include&lt;&gt;只查<strong>系统类库目录</strong>的头文件、</li>
<li>#include “”先从项目当前目录查，再从项目配置的头文件引用目录查，最后从系统类库目录查</li>
</ul>
<h4 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h4><p>C语言允许在一个结构体中以位为单位来指定其成员所占内存长度，这种以位为单位的成员称为“位段”或称“位域”( bit field) 。利用位段能够用较少的位数存储数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> _a:<span class="number">2</span>; <span class="comment">//开辟一个32个bit位，a占了2个</span></span><br><span class="line"><span class="type">int</span> _b:<span class="number">5</span>; <span class="comment">//在a开辟的bit位中占5个bit</span></span><br><span class="line"><span class="type">int</span> _c:<span class="number">10</span>;<span class="comment">//在a开辟的bit位中占10个bit</span></span><br><span class="line"><span class="type">int</span> _d:<span class="number">30</span>;<span class="comment">//另外开辟32个bit位，d占了30个</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型</p>
<p>1、位段不能跨字节存储<br>2、位段不能跨类型存储</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44443986/article/details/110196939">https://blog.csdn.net/qq_44443986/article/details/110196939</a></p>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><h5 id="调用C函数"><a href="#调用C函数" class="headerlink" title="调用C函数"></a>调用C函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_module.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// my_module.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_module.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line">  cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>用它声明的类型变量表示可以被某些编译器未知的因素更改（多线程、汇编，存储器映射的硬件寄存器），强制其从内存读取变量的值</p>
<h4 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunada2005/p/3397090.html">https://www.cnblogs.com/sunada2005/p/3397090.html</a></p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>显式指定</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C c1;</span><br><span class="line">	c1.A::<span class="built_in">f</span>();</span><br><span class="line">	c1.B::<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>同名覆盖</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A::<span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚基类</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;</span><br><span class="line">    priavte:</span><br><span class="line">    <span class="type">int</span> b1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span>:virutual <span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> b2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>假设</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	Base----&gt;ParentA;</span><br><span class="line">	Base----&gt;ParentB;</span><br><span class="line">	ParentA----&gt;Son;</span><br><span class="line">	ParentB----&gt;Son;</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若使用虚继承，ParentA，ParentB中对Base的构造函数不生效，需要在Son里对Base再次构造</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Son</span>(<span class="type">int</span> i, <span class="type">float</span> f, <span class="type">char</span> c) : <span class="built_in">ParentA</span>(i, f), <span class="built_in">ParentB</span>(i, c)&#123;&#125;<span class="comment">//错误</span></span><br><span class="line"><span class="built_in">Son</span>(<span class="type">int</span> i, <span class="type">float</span> f, <span class="type">char</span> c) : <span class="built_in">ParentA</span>(i, f), <span class="built_in">ParentB</span>(i, c), <span class="built_in">Base</span>(i) &#123;&#125;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/what951006/article/details/78273903">https://blog.csdn.net/what951006/article/details/78273903</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//原子变量</span></span><br><span class="line"><span class="function">atomic_int <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//原子变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(fun)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(fun)</span></span>;</span><br><span class="line">    th1.<span class="built_in">detach</span>();</span><br><span class="line">    th2.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">mutex x;<span class="comment">//互斥锁</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        x.<span class="built_in">lock</span>();</span><br><span class="line">        c++;</span><br><span class="line">        x.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">th1</span><span class="params">(fun)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(fun)</span></span>;</span><br><span class="line">    th1.<span class="built_in">detach</span>();</span><br><span class="line">    th2.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">condition_variable g_CV;</span><br><span class="line">mutex g_mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(g_mtx)</span></span>;</span><br><span class="line">        g_CV.<span class="built_in">wait</span>(ul);</span><br><span class="line">        cout &lt;&lt; g_value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lg</span><span class="params">(g_mtx)</span></span>;</span><br><span class="line">        g_value++;</span><br><span class="line">        g_CV.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(write_thread)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(read_thread)</span></span>;</span><br><span class="line">    th1.<span class="built_in">detach</span>();</span><br><span class="line">    th2.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空类-x2F-结构体的大小"><a href="#空类-x2F-结构体的大小" class="headerlink" title="空类&#x2F;结构体的大小"></a>空类&#x2F;结构体的大小</h4><p>C++中默认是1字节，因为C++标准规定每个对象需要有独一无二的地址</p>
<p>若空基类被继承，则为0，因为有空基类优化(EBO)</p>
<p>C语言中空结构体大小为0</p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>捕获列表 [capture]</p>
<p>  捕获一定范围内的变量，有以下几种方式：</p>
<ol>
<li>[] - 表示不捕捉任何变量</li>
<li>[&amp;] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)</li>
<li>[&#x3D;] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)</li>
<li>[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li>
<li>[this] - 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定的值是按值传递，如x，y</li>
</ul>
</li>
<li><p>参数列表 (params): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写</p>
</li>
<li><p>opt 选项，不需要可以省略，一般有两个</p>
<ol>
<li>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li>
<li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</li>
</ol>
</li>
<li><p>返回值类型</p>
<p>  很多时候，lambda 表达式的返回值是非常明显的，因此在 C++11 中允许省略 lambda 表达式的返回值。</p>
</li>
<li><p>函数体：函数的实现，这部分不能省略，但函数体可以为空。</p>
</li>
</ul>
<h5 id="sort-函数comparator"><a href="#sort-函数comparator" class="headerlink" title="sort 函数comparator"></a>sort 函数comparator</h5><ol>
<li>comparator 的签名必须为</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于相等的值永远返回 false</li>
</ol>
<p>快速排序的时候piovt 使用的是三数取中的方式<br>在__unguarded_partition函数，如果相等值返回 true的话， 那么这个函数可能会出现越界情况</p>
<h4 id="nullptr和null的区别"><a href="#nullptr和null的区别" class="headerlink" title="nullptr和null的区别"></a>nullptr和null的区别</h4><ul>
<li><p>首先给出NULL在C和C++中的定义</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL    0  </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL    ((void *)0)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>要明白一点儿，NULL是一个无类型的东西，而且是一个宏。而宏这个东西，从C++诞生开始，就是C++之父嗤之以鼻的东西，他推崇尽量避免宏。</p>
</blockquote>
<p>下面看一段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">NULL</span>); <span class="comment">// what function will be called?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们本来是想用NULL来代替空指针，但是在将NULL输入到函数中时，它却选择了int形参这个函数版本，所以是有问题的，这就是用NULL代替空指针在C++程序中的二义性。<em><em>而引入了nullptr，这个问题就得到了真正解决，会很顺利的调到void f(void</em>)这个版本。</em>*</p>
<p><strong>nullptr，可以保证在任何情况下都代表空指针</strong></p>
<p>nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。</p>
<h3 id="c-1"><a href="#c-1" class="headerlink" title="c#"></a>c#</h3><h4 id="与C-的区别"><a href="#与C-的区别" class="headerlink" title="与C++的区别"></a>与C++的区别</h4><ol>
<li>类没有多继承</li>
<li>万物都是对象</li>
<li>数组是对象，放在堆里</li>
<li>没有宏</li>
<li>C#有自动垃圾收集机制</li>
<li>平时不给用指针</li>
</ol>
<h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><p><strong>继承</strong></p>
<p>提高代码重用度，增强软件可维护性的重要手段，符合<strong>开闭原则</strong>（软件中的对象扩展是开放的，修改是关闭的）。继承就是把子类的公共属性集合起来（变量，方法等）共同管理，这些公共属性设置为父类，C#的继承是单继承，但继承有传递性：A继承B，B继承C，A可以调用C#中的方法。</p>
<p><strong>封装</strong></p>
<p>封装是将数据和行为相结合，通过行为约束代码修改数据的程度，增强数据的安全性，属性是C#封装实现的最好体现。将一些复杂的逻辑包装起来，程序员不管内部是如何实现的，只负责使用里面的数据或者逻辑，目的是保护或者防止代码被无意修改。</p>
<p><strong>多态</strong></p>
<p>多态性是指<strong>同名的方法在不同环境下，自适应的反应出不同得表现</strong>，是方法动态展示的重要手段。例如叫声，在鸟这个类中是“鸣啼”在狗这个类中是“犬吠”。</p>
<ul>
<li>静态的多态：<strong>函数重载,看起来调用同一个函数却有不同的行为。静态：原理是编译时实现。</strong></li>
<li>动态的多态：<strong>一个父类的引用或指针去调用同一个函数，传递不同的对象，会调用不同的函数。动态：原理是运行时实现。</strong></li>
</ul>
<h5 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h5><ol>
<li><p>静态构造函数既没有访问修饰符，也<strong>没有参数</strong>。</p>
</li>
<li><p>在创建第一个类实例或任何<strong>静态成员被引用</strong>时，.NET将自动调用静态构造函数来初始化类。</p>
</li>
<li><p>一个类<strong>只能有一个</strong>静态构造函数。</p>
</li>
<li><p>无参数的构造函数可以与静态构造函数共存。</p>
</li>
<li><p>最多<strong>只运行一次</strong>。</p>
</li>
<li><p>静态构造函数<strong>不可以被继承</strong>。</p>
</li>
<li><p>如果没有写静态构造函数，而类中包含带有初始值设定的<strong>静态成员</strong>，那么编译器会自动生成默认的静态构造函数。</p>
</li>
<li><p>如果静态构造函数引发异常，运行时将不会再次调用该构造函数，并且在程序运行所在的应用程序域的生存期内，类型将保持未初始化。</p>
</li>
</ol>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>值类型：int，bool，float，char，struct，enum。</li>
<li>引用类型：string，object，delegate，interface，class，array。</li>
</ul>
<p>区别</p>
<ul>
<li>值类型存储在<strong>栈</strong>中，引用类型存储在<strong>堆</strong>中。</li>
<li>值类型存储<strong>快</strong>，引用类型存储<strong>慢</strong>。</li>
<li>值类型表示<strong>实际数据</strong>，引用类型表示指向在内存堆中的<strong>指针和引用</strong>。</li>
<li>值类型在栈中可以<strong>自动释放</strong>，引用类型在堆中需要<strong>GC</strong>来释放</li>
<li>值类型继承与 System.ValueType，（System.ValueType继承于System.Object)，引用类型继承于System.Object。</li>
<li>值类型在栈中存储的是直接的值，引用类型数据本身实在堆中，栈中存放的是一个引用的地址。</li>
</ul>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h4><ul>
<li>string内容相同时指的是同一个地址</li>
<li>string内容改变时是开辟新空间存储</li>
<li>当频繁堆一个字符串进行修改时，利用StringBuilder代替String，不用GC<ul>
<li>不一定StringBuilder就更好，因为要初始化</li>
</ul>
</li>
<li>结构体里的引用：放在堆里，所有同结构体共享（string也是，但是因为更改时是开辟新空间所以看起来不共享）</li>
<li>类里的值：放在堆里</li>
</ul>
<h5 id="string内容相同是否是同一个引用"><a href="#string内容相同是否是同一个引用" class="headerlink" title="string内容相同是否是同一个引用"></a>string内容相同是否是同一个引用</h5><p>字符串有一个缓存池(Intern Pool)（一个哈希表），特定情况下会检查池内是否存在对应字符串</p>
<ul>
<li>利用字面量值创建string对象</li>
<li>利用string.Intern()创建string对象</li>
<li>字面量值+字面量值拼接创建string对象</li>
<li>多个charArray.ToString()之间</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;qwer&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> b = <span class="string">&quot;qwer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> c = a + b;</span><br><span class="line"><span class="built_in">string</span> d = a + b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> e = <span class="string">&quot;qwerqwer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> f = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> g = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;45&quot;</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(a, b));<span class="comment">//true，编译阶段字面量相等</span></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(c, d));<span class="comment">//false，运行阶段非字面量拼接</span></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(d, e));<span class="comment">//false，运行阶段非字面量拼接</span></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(f, g));<span class="comment">//true，字面量拼接</span></span><br></pre></td></tr></table></figure>

<ul>
<li>驻留池由CLR来维护，其中的所有字符串对象的值都不相同。</li>
<li>只有编译阶段的文本字符常量会被自动添加到驻留池。</li>
<li>运行时期动态创建的字符串不会被加入到驻留池中。（new，toString，带非字面量的拼接）</li>
<li>string.Intern()可以把动态创建的字符串加入到驻留池中。</li>
</ul>
<h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><p><strong>常见GC算法</strong></p>
<ul>
<li><p><strong>标记-清除</strong></p>
<ul>
<li>优点<ul>
<li>实现简单</li>
<li>与保守式GC算法兼容（保守式GC在后面介绍）</li>
</ul>
</li>
<li>缺点<ul>
<li>碎片化：如上图所示，在回收的过程中会产生被细化的分块，到后面，即使堆中分块的总大小够用，但是却因为分块太小而不能执行分配。</li>
<li>分配速度：因为分块不是连续的，因此每次分块都要遍历空闲链表，找到足够大的分块，从而造成时间的浪费。</li>
<li>与写时复制技术不兼容</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>标记-压缩</strong></p>
<ul>
<li>例如分代算法</li>
<li>唯一缺点：效率不高，移动对象需要耗费更多时间</li>
</ul>
</li>
<li><p><strong>引用计数</strong></p>
<ul>
<li><p>优点</p>
<ul>
<li><p>可即时回收垃圾：在该方法中，每个对象始终知道自己是否有被引用，当被引用的数值为0时，对象马上可以把自己当作空闲空间链接到空闲链表。</p>
</li>
<li><p>最大暂停时间短。</p>
</li>
<li><p>没有必要沿着指针查找</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>计数器值的增减处理非常繁重</p>
</li>
<li><p>计算器需要占用很多位。</p>
</li>
<li><p>实现繁琐。</p>
</li>
<li><p>循环引用无法回收。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复制算法</strong>：没清除的复制到堆内存的另一半</p>
<ul>
<li>优点<ul>
<li>优秀的吞吐量。</li>
<li>可实现高速分配：复制算法不用使用空闲链表。这是因为分块是连续的内存空间，因此，调用这个分块的大小，只需要这个分块大小不小于所申请的大小，移动指针进行分配即可。</li>
<li>不会发生碎片化。</li>
<li>与缓存兼容。</li>
</ul>
</li>
<li>缺点<ul>
<li>堆的使用效率低下。</li>
<li>不兼容保守式GC算法。</li>
<li>递归调用函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="c-2"><a href="#c-2" class="headerlink" title="c#"></a>c#</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41719595/article/details/121016454">https://blog.csdn.net/qq_41719595/article/details/121016454</a></p>
<p>GC总体可以分为三个步骤：</p>
<ol>
<li>标记（Mark）。从Root开始进行引用标记，未被标记到的为不可达内存，不可达内存为GC对象。<ul>
<li>GC搜索roots的地方包括<strong>全局对象</strong>、<strong>静态变量</strong>、<strong>局部对象</strong>、<strong>函数调用参数</strong>、<strong>当前CPU寄存器中的对象指针（还有finalization queue）等</strong>。主要可以归为2种类型：<strong>已经初始化了的静态变量</strong>、<strong>线程仍在使用的对象（stack+CPU register）</strong> 。</li>
</ul>
</li>
<li>重新分配地址（Relocate）。更新所有活动对象列表中的所有对象的引用，以便它们指向对象将在压缩阶段重定位到的新位置。<ul>
<li>指针修复是因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPU register中的指针以及heap中其他对象的引用指针。</li>
</ul>
</li>
<li>压缩（Compact）。当部分内存被清除后，原本的内存空间变得不连续，因此剩余的存活对象需要按照原始顺序从基址开始重新排列。</li>
</ol>
<p>分代算法：有内存整理，避免碎片化。有压缩。越老说明</p>
<ul>
<li>​    0代，未被标记回收的新分配对象</li>
<li>​    1代，上次垃圾回收中没有被回收的对象</li>
<li>​    2代，在一次以上的垃圾回收之后任然没有被回收的对象</li>
</ul>
<p><strong>详细流程</strong></p>
<ol>
<li>当新建立引用类型对象时，检查0代储存空间是否有充足的空间使得新的引用类型对象存储。若没有，将0代对象进行遍历检查（<strong>暂时只检查第零代</strong>），是否有被调用（激活），没有被调用的对象被标记“可回收”。</li>
<li>遍历完成后，将所有被“可回收”的对象进行垃圾回收，释放的空间返回给0代储存区，其他的对象的对象 迁移 到1代储存区，标记为“1代对象”，此时该对象是分散分布的，要进行 <strong>压缩</strong> 操作，使得1代对象顺序紧密排列。新对象存储于0代储存空间，标记为0代对象。</li>
<li>当1代空间满了时，将1代对象按照上述操作遍历，迁移，压缩到2代储存区，标记为2代对象，<strong>收集一代意味着收集该一代及其所有年轻一代的对象，因此第 2 代垃圾回收也称为完整垃圾回收</strong></li>
</ol>
<p><strong>触发方法</strong></p>
<ul>
<li>手动触发</li>
<li>自动触发</li>
<li>堆内存分配时出现内存不足</li>
</ul>
<h5 id="unity"><a href="#unity" class="headerlink" title="unity"></a>unity</h5><ul>
<li><p>unity内部有两个内存管理池:<strong>堆内存和栈内存</strong>。栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。</p>
</li>
<li><p>只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。</p>
</li>
<li><p><strong>处于栈上的内存回收及其快速</strong>，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。不再使用的内存只会在GC的时候才会被回收。</p>
</li>
<li><p>垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。当GC的时候，以全局数据区和当前寄存器中的对象为根节点，按照引用关系进行遍历，对于遍历到的每一个对象，将其标记为活的（alive）</p>
</li>
</ul>
<p><strong>分配流程</strong></p>
<ol>
<li>首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应大小的内存单元；</li>
<li>如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够大小的内存单元，则进行内存分配。</li>
<li>如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应大小的内存单元给变量。</li>
</ol>
<p><strong>回收流程</strong></p>
<ol>
<li>GC会检查堆内存上的每个存储变量;</li>
<li>对每个变量会检测其引用是否处于激活状态;</li>
<li>如果变量的引用不再处于激活状态，则会被标记为可回收;</li>
<li>被标记的变量会被移除，其所占有的内存会被回收到堆内存上。</li>
</ol>
<p><strong>造成的问题</strong></p>
<ul>
<li>卡顿</li>
<li><strong>内存碎片化</strong></li>
</ul>
<p><strong>如何避免</strong></p>
<ul>
<li>缓存公共对象，用对象池</li>
<li>少new</li>
<li>大量字符串拼接用StringBuilder</li>
<li>容器提前指定长度</li>
<li>减少装箱拆箱</li>
</ul>
<h5 id="有了-GC-还会不会发生内存泄漏？"><a href="#有了-GC-还会不会发生内存泄漏？" class="headerlink" title="有了 GC 还会不会发生内存泄漏？"></a>有了 GC 还会不会发生内存泄漏？</h5><p>循环引用</p>
<p>非托管资源</p>
<h5 id="非托管资源"><a href="#非托管资源" class="headerlink" title="非托管资源"></a>非托管资源</h5><p>IDispose接口</p>
<p>可以用**using(object){}**用完就扔</p>
<p>非托管内存、文件句柄、socket连接需要及时释放</p>
<p><strong>GC是可以释放非托管资源的</strong>，做法是在托管资源的析构函数里释放</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leo_wl/p/7423935.html">https://www.cnblogs.com/Leo_wl/p/7423935.html</a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleClass</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//演示创建一个非托管资源</span></span><br><span class="line">    <span class="keyword">private</span> IntPtr nativeResource = Marshal.AllocHGlobal(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//演示创建一个托管资源</span></span><br><span class="line">    <span class="keyword">private</span> AnotherResource managedResource = <span class="keyword">new</span> AnotherResource();</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 实现IDisposable中的Dispose方法，用于手动调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//必须为true</span></span><br><span class="line">        Dispose(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//通知垃圾回收机制不再调用终结器（析构器）因为我们已经自己清理了，没必要继续浪费系统资源</span></span><br><span class="line">        <span class="comment">//即：从等待终结的Finalize队列中移除this</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 必须，以备程序员忘记了显式调用Dispose方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    ~SampleClass()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//必须为false，跳过托管资源的清理，只手动清理非托管的资源，垃圾回收器会自动清理托管资源</span></span><br><span class="line">        Dispose(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 非密封类修饰用protected virtual</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 密封类修饰用private</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;disposing&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (disposed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disposing)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 清理托管资源</span></span><br><span class="line">            <span class="keyword">if</span> (managedResource != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                managedResource.Dispose();</span><br><span class="line">                managedResource = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理非托管资源</span></span><br><span class="line">        <span class="keyword">if</span> (nativeResource != IntPtr.Zero)</span><br><span class="line">        &#123;</span><br><span class="line">            Marshal.FreeHGlobal(nativeResource);</span><br><span class="line">            nativeResource = IntPtr.Zero;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让类型知道自己已经被释放</span></span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p>装箱是将<strong>值类型</strong>转换为 <strong>object 类型</strong></p>
<p>步骤</p>
<ul>
<li>去堆内存new一个Object类对象</li>
<li>把值类型的数据存入到堆中的Object对象中</li>
<li>将堆上创建的对象的地址返回给引用类型变量。</li>
</ul>
<p>拆箱是从 <strong>object 类型</strong>到<strong>值类型</strong></p>
<p>步骤</p>
<ul>
<li>获取已装箱的对象的地址检查对象实例，以<strong>确保它是给定值类型的装箱值</strong>。（int装箱后拆箱成double行不通）</li>
<li>将该值从实例复制到值类型变量中。</li>
</ul>
<p>装箱拆箱会产生临时对象导致内存垃圾和GC</p>
<p><strong>泛型</strong>介绍：处理多个代码对不同的数据类型执行相同指令的操作。也可以理解为：多个类型共享一组代码。泛型类不是实际的类，而是类的<strong>模板</strong>。泛型不会进行装箱拆箱，所以性能很高</p>
<p><strong>所以少用ArrayList（会转成Object），多用List&lt;T&gt;</strong></p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><strong>修饰符</strong></h4><h5 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h5><ol>
<li>public:对任何类和成员都公开，无限制访问</li>
<li>private:仅对该类公开</li>
<li>protected:对该类和其派生类公开</li>
<li>internal:只能在包含该类的程序集中访问该类</li>
</ol>
<ul>
<li>sealed 防止被继承，通常和override搭配</li>
</ul>
<h5 id="形参ref-与-out"><a href="#形参ref-与-out" class="headerlink" title="形参ref 与 out"></a>形参ref 与 out</h5><p>解决值类型和引用类型在函数内部改值或者重新申明能够影响外部传入的变量让其也被修改。</p>
<ul>
<li>ref传入的变量必须初始化但是在内部可改可不改。<strong>传地址</strong></li>
<li>out传入的变量不用初始化但是在内部必须修改该值(必须赋值）。<strong>传入的形参会被清空</strong></li>
</ul>
<h5 id="泛型in-与-out"><a href="#泛型in-与-out" class="headerlink" title="泛型in 与 out"></a>泛型in 与 out</h5><p>指定泛型是在形参或者返回值，<strong>只有泛型接口和泛型委托能使用</strong></p>
<ul>
<li><p>协变(out):</p>
<ul>
<li>和谐、自然的变化</li>
<li>里式替换原则中，父类容器可以装载子类对象，子类可以转换成父类。比如string转object，感受是和谐的。</li>
</ul>
</li>
<li><p>逆变(in):</p>
<ul>
<li>逆常规、不正常的变化</li>
<li>里式替换原则中，父类容器可以装载子类对象，但是子类对象不能装载父类。所以父类转换为子类，比如object转string，感受是不和谐的。</li>
</ul>
</li>
</ul>
<p><strong>区别</strong></p>
<ol>
<li><p>结构体是<strong>值</strong>类型，类是<strong>引用</strong>类型。</p>
</li>
<li><p>结构体存在<strong>栈</strong>中，类存在<strong>堆</strong>中。</p>
</li>
<li><p>结构体变量和类对象进行类型传递时,结构体变量进行的就是<strong>值传递</strong>,而类对象进行的是<strong>引用传递</strong></p>
</li>
<li><p><strong>结构体</strong>类型定义时，成员是<strong>不能初始化</strong>的,这样就导致了，定义结构体变量时,变量的所有成员都要自己赋值初始化。但对于类，在定义类时,就可以初始化其中的成员变量,所以在定义对象时,对象本身就已经有了初始值,你可以自己在重新给个别变量赋值。(注意在C++中，类的定义中是不能初始化的，初始化要放在构造函数中)</p>
</li>
<li><p><strong>结构体不能申明无参</strong>的构造函数，而类可以。</p>
</li>
<li><p>声明了结构类型后，可以使用<strong>new运算符</strong>创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。</p>
</li>
<li><p>结构体申明<strong>有参构造函</strong>数后，无参构造不会被顶掉。</p>
</li>
<li><p>结构体不能申明<strong>析构函数</strong>，而类可以。</p>
</li>
<li><p>结构体不能被<strong>继承</strong>，而类可以。</p>
</li>
<li><p>结构体需要在构造函数中<strong>初始化所有成员变量</strong>，而类随意。</p>
</li>
<li><p>结构体不能被静态**static修饰(**不存在静态结构体)，而类可以。</p>
</li>
</ol>
<p><strong>应用</strong></p>
<ul>
<li>结构体<ul>
<li>传递数据集合</li>
<li>传递轻量数据</li>
<li>传递数据的拷贝而非指针</li>
</ul>
</li>
<li>类<ul>
<li>复杂逻辑</li>
<li>需要用到继承和多态</li>
</ul>
</li>
</ul>
<h4 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h4><p><strong>默认访问级别</strong></p>
<p>class和struct 本身成员的默认访问级别不同，是最本质的特点（这块我之前有知道，但是具体的不同忘记了，就谈了pubilc、protect、private）。<strong>结构体的成员和成员函数在默认情况下的访问级别是公有的（public），类的成员和成员函数在默认情况下的访问级别是私有的（private）。</strong></p>
<p><strong>两者在赋值上存在不同</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;<span class="type">char</span> c1; <span class="type">int</span> n2; <span class="type">float</span> db3;&#125;;A a = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>这样可以直接给结构体赋值，没有任何错误，但是并不可以给类赋值。</strong>我们平时使用{}来对结构赋值，是一个初始化列表形式进行初始化，这样简单的初始化只能用在简单的数据结构上，如果加上构造函数，那么struct会表现出一种对象的特性，因此再使用这种方式赋值就会失效。也就是说当我们在一个结构中加入构造函数后，结构体的内部结构会发生变化；但加入一个普通函数，结构体内部结构依旧不变；因此可以理解为普通函数是一种对数据结构的算法，并不会打破原本数据的特性。</p>
<h4 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h4><p><strong>区别</strong></p>
<ul>
<li><p>接口不能被<strong>实例化</strong>，抽象类可以间接实例化（可以被继承，有构造函数，可以实例化子类的同时间接实例化抽象类这个父类）。</p>
</li>
<li><p>接口只能做<strong>方法申明</strong>，抽象类中可以做方法申明，也可以做方法实现。</p>
</li>
<li><p>抽象类中可以有实现成员，接口只能包含抽象成员。因此接口是<strong>完全抽象</strong>，抽象类是部分抽象。</p>
</li>
<li><p>抽象类要被子类<strong>继承</strong>，接口要被类<strong>实现</strong>。</p>
</li>
<li><p>抽象类中所有的成员修饰符都能使用，<strong>接口</strong>中的成员都是<strong>对外</strong>的，所以不需要修饰符修饰。</p>
</li>
<li><p>接口可以实现<strong>多继承</strong>，抽象类只能实现单继承，一个类只能继承一个类但可以实现多个接口。</p>
</li>
<li><p>抽象方法要被实现，所以不能是静态的，也不能是私有的。</p>
</li>
</ul>
<p>应用</p>
<ul>
<li>使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性。</li>
<li>抽象类适合用来定义某个领域的固有属性，接口适合用来定义某个领域的扩展功能。</li>
</ul>
<p>抽象类</p>
<ul>
<li>当2个或多个类中有重复部分的时候，我们可以抽象出来一个基类，如果希望这个基类<strong>不能被实例化</strong>，就可以把这个基类设计成抽象类。</li>
<li>当需要为一些类提供<strong>公共的实现代码</strong>时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</li>
</ul>
<p>接口</p>
<ul>
<li>当注重代码的<strong>扩展性</strong>跟<strong>可维护性</strong>时，应当优先采用接口。</li>
<li>接口与实现它的类之间可以<strong>不存在任何层次关系</strong>，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活;</li>
<li>接口只关心对象之间的<strong>交互的方法</strong>，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</li>
</ul>
<h4 id="不安全代码与非托管代码"><a href="#不安全代码与非托管代码" class="headerlink" title="不安全代码与非托管代码"></a>不安全代码与非托管代码</h4><ul>
<li><p>托管代码: 在公共语言运行时(CLR)控制下运行的代码。</p>
<ul>
<li>有GC</li>
</ul>
</li>
<li><p>非托管代码: 不在公共语言运行时(CLR)控制下运行的代码。</p>
<ul>
<li>应用程序、程序员自己管内存</li>
<li>Unsafe，IDispoose接口</li>
</ul>
</li>
<li><p>不安全(Unsafe)代码: 不安全代码可以被认为是介于托管代码和非托管代码之间的。不安全代码仍然在公共语言运行时(CLR)控制下运行，但它将允许您直接通过指针访问内存。<strong>可以使用unsafe关键字</strong></p>
</li>
</ul>
<h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>委托是约束集合中的一个<strong>类</strong>，而不是一个方法，相当于<strong>一组方法</strong>列表的引用，可以便捷的使用委托对这个方法集合进行操作。委托是对函数指针的封装。</p>
<p><strong>委托和接口的区别</strong></p>
<ul>
<li>接口<ul>
<li>无法继承的场所</li>
<li>完全抽象的场所</li>
<li>多人协作的场所</li>
</ul>
</li>
<li>委托<ul>
<li>多由于事件的处理</li>
</ul>
</li>
</ul>
<p><strong>委托</strong>delegate和<strong>事件</strong>event的区别</p>
<ul>
<li>事件可以看做成委托中的一个<strong>变量</strong>。</li>
<li>事件是基于委托的存在，事件是委托的安全包裹，让委托的使用更具有安全性。</li>
<li><strong>委托可以用“&#x3D;”来赋值</strong>，事件不可以。</li>
<li>委托可以在声明它的<strong>类外部</strong>进行调用，而事件只能在类的内部进行调用。</li>
<li>委托是一个<strong>类型</strong>，事件修饰的是一个对象。</li>
</ul>
<p>Action:delegate的封装，写法方便，泛型填形参类型，按顺序，最多16个</p>
<p>Func:delegate的封装，但是有返回值，泛型最后一个是返回值，返回<strong>最后添加</strong>的事件的返回值</p>
<h4 id="New的实现"><a href="#New的实现" class="headerlink" title="New的实现"></a>New的实现</h4><p> rPoint1 &#x3D; new RefPoint(1);</p>
<ul>
<li><p>在应用程序堆上创建一个<strong>引用类型对象的实例</strong>，并为它<strong>分配内存地址</strong>。</p>
</li>
<li><p>自动传递该实例的<strong>引用</strong>给<strong>构造函数</strong>(正因如此，在构造函数中才能使用<strong>this</strong>来访问这个实例)。</p>
</li>
<li><p>调用该类型的<strong>构造函数</strong>。</p>
</li>
<li><p><strong>返回该实例的引用内存地址</strong>，赋值给 rPoint1 变量，该rPoint1 引用对象保存的数据是指向在<strong>堆</strong>上创建该类型的实例地址。</p>
</li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>可以在加载程序运行时，动态获取和加载<strong>程序集</strong>，并且可以获取到程序集的信息反射即在运行期动态获取类、对象、方法、对象数据等的种重要手段。</p>
<p><strong>反射面向对像体现</strong></p>
<p>之前了解的面向对象是基于类实现，而反射中就是基于程序集实现，只不过把类再用程序集包裹了一下，封装是把一些属性方法封装到一个类中，限制其数据修改的程度，那多加一层皮（程序集）就是一个道理了，继承多态就是和类一样，把类换成程序集去理解。</p>
<ul>
<li>优点<ul>
<li>允许在运行时发现并使用编译时还<strong>不了解的类型以及成员</strong>。</li>
</ul>
</li>
<li>缺点<ul>
<li>根据目标类型的字符串搜索<strong>扫描程序集</strong>的元数据的过程耗时。</li>
<li>反射<strong>调用方法或属性</strong>比较耗时。(首先必须将实参打包成数组，在内部，反射必须将这些实参解包到线程栈上。可以使用多态避免反射操作)</li>
</ul>
</li>
</ul>
<p><strong>通过反射去获取对象的一个实例</strong></p>
<p>反射可以直接访问类的构造，直接通过getConstructor,去访问这个构造函数，然后通过不同的参数列表，就河以具体的定位到哪一个构造的重载，通过这个方法，去得到类的实例，把对像就拿到了。</p>
<h4 id="重载、重写、隐藏"><a href="#重载、重写、隐藏" class="headerlink" title="重载、重写、隐藏"></a>重载、重写、隐藏</h4><ul>
<li>重载：使用不同参数表的同名函数</li>
<li>重写：使用override关键字重写父类的virtual虚函数，即使发生向上转型也是调用子类函数</li>
<li>隐藏：使用new关键字重写父类的函数，与父类函数独立，发生向上转型时调用父类函数</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        say();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Animal Eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Animal say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEnable();<span class="comment">//输出Animal say</span></span><br><span class="line">        Start();<span class="comment">//输出Dog Eat</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dog Eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">say</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dog say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="static、readonly与const"><a href="#static、readonly与const" class="headerlink" title="static、readonly与const"></a>static、readonly与const</h4><p>csharp里const带static属性</p>
<p>区别</p>
<ul>
<li>声明及初始化<ul>
<li>readonly常量只能声明为类字段，支持实例类型或静态类型，可以在声明的同时初始化或者在构造函数中进行初始化，初始化完成后便无法更改。</li>
<li>const常量除了可以声明为类字段之外，还可以声明为方法中的局部常量，默认为静态类型(无需用static修饰，否则将导致编译错误)，但必须在声明的同时完成初始化。</li>
</ul>
</li>
<li>数据类型<ul>
<li>由于const常量在编译时将被替换为字面量，使得其取值类型受到了一定限制。const常量只能被赋予数字(整数、浮点数)、字符串以及枚举类型。</li>
</ul>
</li>
<li>可维护性<ul>
<li>readonly以引用方式进行工作，某个常量更新后，所有引用该常量的地方均能得到更新后的值。</li>
<li>const的情况要稍稍复杂些，特别是跨程序集调用：</li>
</ul>
</li>
<li>性能比较<ul>
<li>const直接以字面量形式参与运算，性能要略高于readonly，但对于一般应用而言，这种性能上的差别可以说是微乎其微。</li>
</ul>
</li>
</ul>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。但该变量提供的值并非变量创建时的值，而是在<strong>父函数范围内的最终值</strong>。</p>
<p>因此会有一些陷阱，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">List&lt;UserModel&gt; userList = <span class="keyword">new</span> List&lt;UserModel&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> UserModel&#123; UserName=<span class="string">&quot;jiejiep&quot;</span>, UserAge = <span class="number">26</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> UserModel&#123; UserName=<span class="string">&quot;xiaoyi&quot;</span>, UserAge = <span class="number">25</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> UserModel&#123; UserName=<span class="string">&quot;zhangzetian&quot;</span>, UserAge=<span class="number">24</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem((obj) =&gt;</span><br><span class="line">                                 &#123;</span><br><span class="line">                                     Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">                                     UserModel u = userList[i];<span class="comment">//这里的i始终为3</span></span><br><span class="line">                                     Console.WriteLine(u.UserName);</span><br><span class="line">                                 &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line">List&lt;UserModel&gt; userList = <span class="keyword">new</span> List&lt;UserModel&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> UserModel&#123; UserName=<span class="string">&quot;jiejiep&quot;</span>, UserAge = <span class="number">26</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> UserModel&#123; UserName=<span class="string">&quot;xiaoyi&quot;</span>, UserAge = <span class="number">25</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> UserModel&#123; UserName=<span class="string">&quot;zhangzetian&quot;</span>, UserAge=<span class="number">24</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    UserModel u = userList[i];<span class="comment">//临时变量缓存</span></span><br><span class="line">    ThreadPool.QueueUserWorkItem((obj) =&gt;</span><br><span class="line">                                 &#123;</span><br><span class="line">                                     Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">                                     <span class="comment">//UserModel u = userList[i];</span></span><br><span class="line">                                     Console.WriteLine(u.UserName);</span><br><span class="line">                                 &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul>
<li><p>使用BinaryFormatter进行串行化；</p>
</li>
<li><p>使用XmlSerializer进行串行化。</p>
</li>
<li><p>可以使用[Serializable]属性将类标志为可序列化的</p>
</li>
<li><p>可以使用[NonSerialized]属性来标志</p>
</li>
<li><p>可以使用[XmlIgnore]来标志</p>
</li>
</ul>
<p>使用System.Runtime.Serialization.Formatters.Binary命名空间下的<strong>BinaryFormatter 和 XmlSerializer</strong>二进制序列化</p>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Expand</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Add</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> stringName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> stringName+ <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类是static</li>
<li>方法是public static</li>
<li>形参使用this修饰</li>
<li>形参类型是想拓展的类型</li>
</ul>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38601677/article/details/111317136">https://blog.csdn.net/weixin_38601677/article/details/111317136</a></p>
<ul>
<li>delegate</li>
<li>async&#x2F;await</li>
<li>Task</li>
</ul>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43360872/article/details/108081628">https://blog.csdn.net/qq_43360872/article/details/108081628</a></p>
<p>c++：volatile</p>
<h4 id="HashTable和Dictionary的区别"><a href="#HashTable和Dictionary的区别" class="headerlink" title="HashTable和Dictionary的区别"></a>HashTable和Dictionary的区别</h4><ul>
<li>HashTable不支持泛型，而Dictionary支持泛型。</li>
<li>Hashtable 的元素属于 Object 类型，通常发生装箱和拆箱的操作</li>
<li>单线程程序中推荐使用 Dictionary, 有泛型优势, 且读取速度较快, 容量利用更充分。多线程程序中推荐使用 Hashtable, 默认的 Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized() 方法可以获得完全线程安全的类型. 而 Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减。</li>
<li>key是整数型Dictionary的效率比Hashtable快，如果key是字符串型，Dictionary的效率没有Hashtable快。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Stack栈和Queue队列"><a href="#Stack栈和Queue队列" class="headerlink" title="Stack栈和Queue队列"></a>Stack栈和Queue队列</h4><ul>
<li><p>相同点：</p>
<ul>
<li>都是线性结构。</li>
<li>插入操作都是限定在表尾进行。</li>
<li>都可以通过顺序结构和链式结构实现。</li>
<li>插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。</li>
<li>多链栈和多链队列的管理模式可以相同。</li>
<li>底层都是由泛型数组实现。</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li>栈先进后出，队列先进先出：删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。</li>
<li>顺序栈能够实现多栈空间共享，而顺序队列不能。</li>
<li>应用场景不同</li>
</ul>
</li>
</ul>
<h4 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h4><ul>
<li>链表<ul>
<li>查找难，增删简单</li>
<li>多一个存地址的空间</li>
<li>内存地址离散</li>
</ul>
</li>
<li>数组<ul>
<li>查找容易，增删难</li>
<li>内存连续</li>
</ul>
</li>
</ul>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul>
<li>前序遍历：（根左右）先访问根节点，再访问左节点，再访问右节点。</li>
<li>中序遍历，（左根右）先访问左节点，再访问根节点，再访问右节点。</li>
<li>后序遍历，（左右根）先访问左节点，再访问右节点，再访问根节点。</li>
</ul>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240315003204318.png" alt="image-20240315003204318"></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/bd3133148d8948c2bedda3e32163ce1c.png" alt="img"></p>
<p><strong>平衡二叉树</strong></p>
<p>定义：任意节点的子树的高度差都小于等于 1</p>
<h4 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h4><p>本质上是数组，容量不足会扩容到<strong>两倍</strong></p>
<p>应对方法</p>
<ul>
<li>预先指定长度</li>
<li>list.TrimExcess();</li>
<li>list.AddRange(collection);</li>
<li>使用<code>LinkedList&lt;T&gt;</code>替代<code>List&lt;T&gt;</code></li>
</ul>
<p>线程不安全，需要加锁</p>
<p><strong>增</strong></p>
<ul>
<li><p>Add()</p>
<ul>
<li><p>大小不够，整体搬家，长度加倍</p>
</li>
<li><p>容易造成GC，建议初始指定长度</p>
</li>
</ul>
</li>
<li><p>Insert()</p>
<ul>
<li>后方整体后移，O(n)</li>
</ul>
</li>
</ul>
<p><strong>删</strong></p>
<ul>
<li><p>Remove()</p>
<ul>
<li>线性查找IndexOf()，然后删除RemoveAt(),剩余数组左移，O(2n)</li>
</ul>
</li>
<li><p>RemoveAt(),后面元素前移，O(n)</p>
</li>
<li><p>Clear()</p>
</li>
<li><p>O(n)，size标记为0，清除引用，方便GC</p>
</li>
</ul>
<p><strong>查</strong></p>
<ul>
<li><p>[]：O(1)</p>
</li>
<li><p>IndexOf()：O(n)</p>
</li>
<li><p>Contains()：O(n)</p>
</li>
<li><p>Find()遍历，O(n)</p>
</li>
<li><p>Enumerator:会创建迭代器，有GC</p>
</li>
</ul>
<p><strong>改</strong></p>
<p><strong>排序</strong></p>
<p>此方法使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Introsort">introsort (introsort</a>) 算法，如下所示：</p>
<ul>
<li>如果分区大小小于或等于 16 个元素，则它使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Insertion_sort">插入排序</a> 算法。</li>
<li>如果分区数超过 2 * LogN，其中 <em>N</em> 是输入数组的范围，则它使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Heapsort">堆排序</a> 算法。</li>
<li>否则，它使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quicksort">快速排序</a> 算法。</li>
</ul>
<p><strong>转数组</strong></p>
<p>少用，容易有垃圾</p>
<h4 id="字典Dictionary"><a href="#字典Dictionary" class="headerlink" title="字典Dictionary"></a>字典Dictionary</h4><p>本质上是一个int数组bucket+一个数据数组entries+一个(伪)链表freeList</p>
<ul>
<li>bucket下标是hash取余的结果，值是第一个数据的下标，通常是新的（头插法）</li>
<li>entries负责存放数据，用结构体内的next指向桶内下一个元素</li>
<li>freeList只是一个int代表最近被删除的元素</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> Entry &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hashCode;    <span class="comment">// Lower 31 bits of hash code, -1 if unused</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> next;        <span class="comment">// Index of next entry, -1 if last</span></span><br><span class="line">    <span class="keyword">public</span> TKey key;        <span class="comment">// Key of entry</span></span><br><span class="line">    <span class="keyword">public</span> TValue <span class="keyword">value</span>;    <span class="comment">// Value of entry</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] buckets; <span class="comment">// Hash桶</span></span><br><span class="line"><span class="keyword">private</span> Entry[] entries; <span class="comment">// Entry数组，存放元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> count; <span class="comment">// 当前entries的index位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> version; <span class="comment">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeList; <span class="comment">// 被删除Entry在entries中的下标index，这个位置是空闲的</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> freeCount; <span class="comment">// 有多少个被删除的Entry，有多少个空闲的位置</span></span><br><span class="line"><span class="keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer; <span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> KeyCollection keys; <span class="comment">// 存放Key的集合</span></span><br><span class="line"><span class="keyword">private</span> ValueCollection values; <span class="comment">// 存放Value的集合</span></span><br></pre></td></tr></table></figure>

<p>可以指定初始长度，但是并不会实际分配空间，只是表明bucket和entries的大概大小（因为要根据传入值判离他最近的最小质数）</p>
<p>质数扩大为至少两倍</p>
<p><strong>增</strong></p>
<p>Add():把Insert套了一层</p>
<p>Insert()</p>
<ul>
<li>key判空</li>
<li>判初始化<ul>
<li>获取质数决定bucket大小</li>
</ul>
</li>
<li>对key进行hash，取余</li>
<li>判断bucket是否为空<ul>
<li>不为空就把新元素的next指向当前头</li>
</ul>
</li>
<li>bucket值修改，freeList值后移</li>
</ul>
<p><strong>删</strong></p>
<p>不是真正释放内存，只是置空</p>
<p>插入freeList头</p>
<p><strong>查</strong></p>
<p>ContainsKey()把FindEntry()包了一层，后者返回值entries为数组下标，只需要判是否大于-1</p>
<p><strong>HashCode</strong></p>
<p>不同数据类型使用不同比较器，防止装箱拆箱</p>
<p>对象的hashcode是基于<strong>内存地址</strong>计算的</p>
<h5 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h5><ul>
<li>开放定址法：寻找一个新的空闲的哈希地址<ul>
<li>线性探测法：找下一个</li>
<li>平方探测法（二次探测）：$h(x)&#x3D;(Hash(x) +i)mod (Hashtable.length)$;（i依次为$+(i^2)和-(i^2)$）</li>
</ul>
</li>
<li>再哈希法：同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二、三、四个</li>
<li>开链法：指针数组+链表</li>
</ul>
<h5 id="哈希构造函数"><a href="#哈希构造函数" class="headerlink" title="哈希构造函数"></a>哈希构造函数</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011037053/article/details/82080023">https://blog.csdn.net/u011037053/article/details/82080023</a></p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li>
</ul>
<p><strong>平衡二叉树</strong></p>
<p>它的左子树和左子树的高度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。</p>
<p>红黑树（Red-Black Tree）和AVL树是两种常见的自平衡二叉搜索树，它们在平衡性维护和性能方面存在一些区别，下面是它们之间的主要区别：</p>
<ol>
<li>平衡条件：红黑树和AVL树具有不同的平衡条件。红黑树的平衡条件是通过节点的颜色标记和一组约束条件来实现的，如每个节点是红色或黑色，从任意节点到其每个叶子的简单路径都包含相同数目的黑色节点等。而AVL树通过要求任意节点的左子树和右子树的高度差不超过1来保持平衡。</li>
<li>插入和删除操作的性能：AVL树在插入和删除节点时要求保持严格的平衡条件，可能需要进行更多的旋转操作来调整树的结构，以满足平衡条件。相比之下，红黑树通过旋转和重着色操作来维护平衡，它的平衡性维护操作相对较少，因此在插入和删除操作上的性能可能略优于AVL树。</li>
<li>内存消耗：AVL树在每个节点中需要额外存储平衡因子（balance factor）来记录左子树和右子树的高度差，以便进行平衡调整。这导致AVL树在存储上需要更多的额外空间。而红黑树只需要存储颜色信息，相对来说更加节省内存。</li>
<li>查询操作的性能：由于红黑树和AVL树都是二叉搜索树，它们在查找操作上具有相同的时间复杂度，即O(log n)，其中n是树中节点的数量。因此，在只涉及查找操作的情况下，它们的性能相当。</li>
</ol>
<h4 id="c-中的STL容器"><a href="#c-中的STL容器" class="headerlink" title="c++中的STL容器"></a>c++中的STL容器</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40156159/article/details/115464132">https://blog.csdn.net/qq_40156159/article/details/115464132</a></p>
<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><ul>
<li>内存可2倍增长的动态数组</li>
<li>数据结构：线性连续空间</li>
<li>三个迭代器：start、finish、end_of_storage</li>
<li>在尾部插入和删除快，随即查找快。在前面或中间插入慢。</li>
<li>capability：为降低空间配置时的速度成本，vector实际配置的大小可能比初始化所需要的大，以便将来的扩充。</li>
</ul>
<p>vector中的扩容机制</p>
<p>当 vector 的大小和容量相等也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。</p>
<p>vector 容器扩容的过程需要经历以下 3 步： </p>
<ol>
<li><p>完全弃用现有的内存空间，重新申请更大的内存空间； </p>
</li>
<li><p>将旧内存空间中的数据，按原有顺序移动到新的内存空间中； </p>
</li>
<li><p>最后将旧的内存空间释放。</p>
</li>
</ol>
<p>因为vector扩容需要申请重新申请新的空间，但是扩容以后它的内存地址会发生变化，这样进行扩容是非常耗时的，为了降低时间车成本，每次扩容时候都会申请比用户需求更多的内存空间，以便后期使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(vector&lt;<span class="type">int</span>&gt;) = <span class="number">24</span>;<span class="comment">//貌似是因为有三个指针pointer _M_start、pointer _M_finish;、pointer _M_end_of_storage;</span></span><br></pre></td></tr></table></figure>

<p><strong>resize()</strong></p>
<p>调整容器的长度大小，使其能容纳n个元素。</p>
<ul>
<li>如果n小于容器的当前的size，则删除多出来的元素。</li>
<li>否则，添加采用值初始化的元素。</li>
</ul>
<p>resize(n，t)</p>
<p>多一个参数t，将所有新添加的元素初始化为t。</p>
<p><strong>reserve()</strong></p>
<p>仅仅分配空间，不初始化对象</p>
<h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><ul>
<li>允许常数时间内对起首端进行元素的插入和删除。</li>
<li>deque没有所谓的容量概念，因为它是以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。</li>
</ul>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240326094342997.png" alt="image-20240326094342997"></p>
<p>deque的中控器</p>
<p>中控器（map）保存着一组指针，每个指针指向一段数据空间的起始位置，通过中控器可以找到所有的数据空间。如果中控器的数据空间满了，会重新申请一块更大的空间，并将中控器的所有指针拷贝到新空间中。</p>
<p>deque采用一块所谓的map（注意，不是STL的map容器）作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体<br><img src="/images/%E5%85%AB%E8%82%A1/image-20240326094541191.png" alt="image-20240326094541191"></p>
<p>deque的迭代器</p>
<p>deque是分段连续空间，维持其”整体连续”假象的任务，落在了迭代器的operator++ 和 operator– 两个运算符重载身上。<br>deque的迭代器由四个属性组成，这四个属性是我们随机访问一个容器内元素的必要成分。</p>
<p>迭代器内部包含 4 个指针，它们各自的作用为：</p>
<ul>
<li><p>cur：指向当前正在遍历的元素；</p>
</li>
<li><p>first：指向当前连续空间的首地址；</p>
</li>
<li><p>last：指向当前连续空间的末尾地址；</p>
</li>
<li><p>node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。</p>
</li>
</ul>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240326094611967.png" alt="image-20240326094611967"></p>
<p>deque的数据结构</p>
<p>deque除了维护一个指向map的指针外，也维护start、finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。此外，也必须记住目前的map大小，因为一旦map的所提供的空间不足，它将需要重新配置一个更大的空间，依然是经过三个步骤：<strong>配置更大的、拷贝原来的、释放原空间。</strong></p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><ul>
<li>数据结构：环状双向链表</li>
<li>插入(insert)和接合(splice)操作都不会造成原来list的迭代器失效</li>
<li>删除（erase）操作仅仅使“指向被删除元素”的迭代器失效，其它迭代器不受影响</li>
<li>随机访问比较慢</li>
<li>任何位置元素的插入和删除，list是常数时间</li>
</ul>
<p>链表较长（单元数量很多）又无法提前知道数量，只能一个个 push_back，这时如果用 vector 效率受影响，因为 vector 增长过程中会不时的重新分配内存，每重新分配一次就要把 vector 中已有的数据都 copy 一遍。</p>
<p>链表中按值保存一个自定义结构，结构中有资源指针（不是智能指针），虽然结构的析构函数会释放资源，但这时只能用 list，如果用 vector，出现 vector 重新分配内存后就会出错。如果实在想用 vector，可以给自定义结构写拷贝构造函数或在 vector 里保存结构的智能指针。</p>
<p>链表中间位置频繁插入删除元素，用 list。</p>
<h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><p><strong>底层实现：deque</strong></p>
<p>可以使用list和vector</p>
<h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><p><strong>底层实现：deque</strong></p>
<p>可以使用list</p>
<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h5><p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先出队的行为特征。</p>
<p>优先队列实现了类似堆的功能（其实底层就是用堆实现的）。</p>
<p>STL默认使用 &lt;操作符来确定对象之间的优先级关系（也就是从大到小排序，默认大根堆）</p>
<p>优先队列的底层是用堆实现的。 在优先队列中默认存放数据的容器是vector，在声明时也可以用deque(双向队列)<br>没有迭代器，不提供遍历功能</p>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>数据结构：底层使用平衡的搜索树——红黑树实现</p>
<ul>
<li><p>set中的元素都是排序好的</p>
</li>
<li><p>set中的元素都是唯一的，没有重复的</p>
</li>
<li><p>插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝</p>
</li>
<li><p>set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列</p>
</li>
<li><p>支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差 (set_symmetric_difference) 等一些集合上的操作</p>
</li>
<li><p>set内部元素也是以键值对的方式存储的，只不过它的键值与实值相同</p>
</li>
<li><p>set中不允许存放两个实值相同的元素</p>
</li>
<li><p>迭代器是被定义成constiterator的，说明set的键值是不允许更改的，并且不允许通过迭代器进行修改set里面的值</p>
</li>
<li><p>hash_set：底层hashtable，没有排序</p>
</li>
<li><p>multiset：允许重复</p>
</li>
</ul>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ul>
<li>map中key的值是唯一的</li>
<li>数据结构：红黑树变体的平衡二叉树数据结构</li>
<li>提供基于key的快速检索能力</li>
<li>元素插入是按照排序规则插入的，不能指定位置插入</li>
<li>对于迭代器来说，可以修改实值，而不能修改key。</li>
<li>根据key值快速查找,查找的复杂度基本是log2n</li>
</ul>
<p>multimap：允许重复</p>
<h5 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h5><p>底层：hashtable</p>
<ul>
<li><p>map的元素有自动排序功能而hash_map没有</p>
</li>
<li><p>底层数组+链表实现，可以存储null键和null值，线程不安全</p>
</li>
<li><p>初始size为16，扩容：newsize &#x3D; oldsize*2，size一定为2的n次幂</p>
</li>
<li><p>扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入</p>
</li>
<li><p>插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）</p>
</li>
<li><p>当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀 计算index方法：index &#x3D; hash&amp; (tab.length – 1)</p>
</li>
</ul>
<h5 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h5><p>无序</p>
<p>hashtable</p>
<ul>
<li>底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化</li>
<li>初始size为11，扩容：newsize &#x3D; olesize*2+1</li>
<li>计算index的方法：index &#x3D; (hash &amp;0x7FFFFFFF) % tab.length</li>
</ul>
<h5 id="map、hash-map、unordered-map比较"><a href="#map、hash-map、unordered-map比较" class="headerlink" title="map、hash_map、unordered_map比较"></a>map、hash_map、unordered_map比较</h5><ul>
<li>运行效率方面：unordered_map最高，hash_map其次，而map效率最低单提供了有序的序列。</li>
<li>占用内存方面：hash_map内存占用最低，unordered_map其次(数量少时优于hash_map），而map占用最高。</li>
<li>需要无序容器时候用unordered_map，有序容器时候用map。</li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>erase返回被删除元素的后一个元素的迭代器</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      instance = (T)<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      instance = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton5</span><span class="comment">//懒汉式</span></span><br><span class="line">&#123;</span><br><span class="line">    Singleton5()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;An instance of Singleton5 is created.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Nested.instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Nested</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">Nested</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton5 instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton3</span><span class="comment">//加锁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> syncObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (syncObj)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h4><h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>观察者模式（又被称为发布-订阅（Publish&#x2F;Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p>观察者模式的效果有以下的优点：</p>
<ol>
<li>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。<ul>
<li>由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。</li>
</ul>
</li>
<li>观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，</li>
</ol>
<p>观察者模式有下面的缺点：</p>
<ol>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。</li>
<li>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。</li>
<li>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。</li>
</ol>
<p>观察者模式的应用场景：<br>1、 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。<br>2、 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。</p>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><h4 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h4><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101038664">https://zhuanlan.zhihu.com/p/101038664</a></p>
<p>主要采用<strong>封装（分层）的思想，来降低耦合度</strong></p>
<h4 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h4><ul>
<li>Entity</li>
<li>Component</li>
<li>System</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30538626">https://zhuanlan.zhihu.com/p/30538626</a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="如何判断链表中是否有环"><a href="#如何判断链表中是否有环" class="headerlink" title="如何判断链表中是否有环"></a>如何判断链表中是否有环</h4><p>可以利用快慢指针来实现，让慢指针每次向下移动一个节点，让快指针每次向下移动两个节点，如果快慢指针可以重合表示在链表中有环，否则则表示无环。</p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/sort.png" alt="img"></p>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010452388/article/details/81283998">https://blog.csdn.net/u010452388/article/details/81283998</a></p>
<ul>
<li>每个结点的值都大于其左孩子和右孩子结点的值，称之为大根堆；</li>
<li>每个结点的值都小于其左孩子和右孩子结点的值，称之为小根堆。</li>
</ul>
<h4 id="判断二叉平衡树"><a href="#判断二叉平衡树" class="headerlink" title="判断二叉平衡树"></a>判断二叉平衡树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span>* pleft;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span>* pright;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">我们用后序遍历的方式遍历整棵二叉树。在遍历某结点的左右子结点</span></span><br><span class="line"><span class="comment">之后，我们可以根据它的左右子结点的深度判断它是不是平衡的，并</span></span><br><span class="line"><span class="comment">得到当前结点的深度。当最后遍历到树的根结点的时候，也就判断</span></span><br><span class="line"><span class="comment">了整棵二叉树是不是平衡二叉树。</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalanced</span><span class="params">(BinaryTreeNode* proot, <span class="type">int</span> *depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(proot == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> left, right;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">IsBalaced</span>(proot-&gt;pleft, &amp;left) &amp;&amp; <span class="built_in">IsBalanced</span>(proot-&gt;pright, &amp;right))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> diff = left - right;</span><br><span class="line">		<span class="keyword">if</span>(diff &lt;=<span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*depth = <span class="number">1</span> + left &gt; right ? left : right;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//return false;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalanced</span><span class="params">(BinaryTreeNode* proot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">IsBalanced</span>(proot, &amp;depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Node&gt;();</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    Node p = null;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        p = s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p != null) &#123;</span><br><span class="line">            <span class="comment">//处理节点</span></span><br><span class="line">            s.<span class="built_in">push</span>(p.right);</span><br><span class="line">            s.<span class="built_in">push</span>(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Node&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != null) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//处理节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.right != null) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = null;</span><br><span class="line">    &#125; <span class="keyword">while</span>(p != null || !s.<span class="built_in">empty</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> <span class="built_in">Stack</span>&lt;Node&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != null || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != null) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//处理节点</span></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>() &amp;&amp; p == s.<span class="built_in">peek</span>().left) &#123;<span class="comment">//判断是否为栈顶的左节点，是的话先访问右节点，否则访问根节点</span></span><br><span class="line">            p = s.<span class="built_in">peek</span>().right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="STL的sort"><a href="#STL的sort" class="headerlink" title="STL的sort"></a>STL的sort</h4><img src="/images/八股/v2-0aa7d503f23b86b14da16c3950696026_1440w.image" alt="img" style="zoom:50%;" />

<ul>
<li>快排</li>
<li>插入排序</li>
<li>堆排序</li>
</ul>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dark_cy/article/details/88698736">https://blog.csdn.net/dark_cy/article/details/88698736</a></p>
<h3 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a><strong>Unity</strong></h3><h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><ul>
<li><p>Awake 用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次，当脚本设置为不可用时，运行时Awake方法仍然会执行一次。Awake在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如 GameObject.FindWithTag 这样的函数搜索它们。每个游戏物体上的Awke以随机的顺序被调用。因此，你应该用Awake来设置脚本间的引用，并用Start来传递信息 ,Awake总是在Start之前被调用。它不能用来执行协同程序。</p>
<ul>
<li>在初始化使用Instantiate创建GameObject之后会调用</li>
</ul>
</li>
<li><p>OnEnable当对象变为可用或激活状态时被调用事件监听。</p>
</li>
<li><p>Start 在behaviour的生命周期中只被调用一次。它和Awake的不同是Start只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。Awake总是在Start之前执行。这允许你协调初始化顺序。</p>
</li>
<li><p>FixedUpdate 当MonoBehaviour启用时，其在每一帧被调用。处理Rigidbody时，需要用FixedUpdate代替Update。例如:给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧。(两者帧长不同)。</p>
</li>
<li><p>Update 是实现各种游戏行为最常用的函数。</p>
</li>
<li><p>LateUpdate 每帧调用一次（在 在所有Update函数调用后被调用） 用于更新游戏场景和状态，和摄像机相关的更新。 官网上例子是摄像机的跟随，都是所有的Update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。</p>
</li>
<li><p>OnGUI 渲染和处理GUI事件时调用。这意味着你的OnGUI程序将会在每一帧被调用。要得到更多的GUI事件的信息查阅Event手册。如果Monobehaviour的enabled属性设为false，OnGUI()将不会被调用。</p>
</li>
<li><p>OnDisable 不能用于协同程序。当对象变为不可用或非激活状态时此函数被调用。</p>
</li>
<li><p>OnDestroy 当对象被销毁时调用。</p>
</li>
</ul>
<p><img src="/images/%E5%85%AB%E8%82%A1/3972e5eb357943538773f4b2fa4f7591.jpeg" alt="img"></p>
<h4 id="unity编译原理"><a href="#unity编译原理" class="headerlink" title="unity编译原理"></a>unity编译原理</h4><p>分为Mono和IL2CPP，两者有各自的虚拟机</p>
<ul>
<li>Mono<ul>
<li>C#$\rightarrow$IL$\rightarrow$机器码</li>
<li>兼容性不佳，每个平台独立适配</li>
<li>Mono虚拟机负责解释和运行</li>
<li>效率低</li>
<li>构建快</li>
</ul>
</li>
<li>IL2CPP<ul>
<li>C#$\rightarrow$IL$\rightarrow$C++$\rightarrow$机器码</li>
<li>兼容性良好，都用的C++</li>
<li>IL2CPP虚拟机只负责运行</li>
<li>效率高</li>
</ul>
</li>
</ul>
<p>IL2CPP也要走Mono翻译成中间代码，最后在自己的虚拟机或平台编译器执行</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MzQ3MzEz,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>开发用Mono，打包用IL2CPP</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421135901412.png" alt="image-20240421135901412"></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/v2-dd8ec43772f9025f42762bf9aa98d287_720w.webp" alt="img"></p>
<p><strong>编译模式</strong></p>
<ul>
<li>Just-in-time:即时编译，运行时把中间代码CIL转为机器码</li>
<li>Ahead-of-Time:预先编译，将中间代码IL转为机器码储存在文件，静态</li>
<li>完全静态编译（Full Ahead-of-Time）：程序运行前，将所有源码编译成目标平台的原生码。</li>
</ul>
<h4 id="合批"><a href="#合批" class="headerlink" title="合批"></a>合批</h4><p>批量渲染是通过减少CPU向GPU <strong>发送渲染命令（DrawCall）的次数，以及减少GPU切换渲染状态的次数</strong>，尽量让GPU一次多做一些事情，来提升逻辑线和渲染线的整体效率。但这是建立在GPU相对空闲，而CPU把更多的时间都耗费在渲染命令的提交上时，才有意义。</p>
<p>Draw Call性能消耗原因是 命令从Runtime到Driver的过程中，CPU要发生<strong>从用户模式到内核模式</strong>的切换。</p>
<p><strong>合批只是对CPU的优化，与GPU没有任何关系</strong></p>
<p>合批后，经过VS,PS，尝试测试，模板测试后，此时已没有了纹理，顶点，索引的概念，只剩下一个个孤立的像素，各像素间没有任何关系了。像素送到GPU后进行批量处理，呈现到屏幕硬件上。因此合批与GPU没有任何关系，也几乎没有影响。不管是一批还是多批，最终在此帧送到GPU的像素数量是相等的，数据是相同的。合批与否，对GPU的影响仅是像素到达的慢了还是快了，几乎不影响GPU的性能</p>
<p><strong>离线合批</strong></p>
<p>离线合批就是在游戏运行前，先用工具把相关资源做合批处理，以减轻引擎实时合批的负担。</p>
<p>适合离线合批的是静态模型和场景物件。如场景地表装饰面：石头&#x2F;砖块等等。</p>
<p>离线合批方式有：</p>
<ol>
<li>美术利用专业建模工具合批。如3D Max&#x2F;Maya等。</li>
<li>利用引擎插件或工具。如Unity的插件MeshBaker和DrawCallMinimizer，可以将静态物体进行合批。</li>
<li>自制离线合批工具。如果第三方插件无法满足项目需求，就要程序专门实现离线合批工具。</li>
</ol>
<p><strong>实时合批</strong></p>
<p><strong>静态</strong></p>
<p>静态合批是勾选Static，Unity在Build的时候，会自动下生成合并的网格，并将它以文件形式存储合并后的数据，这样在当场景被加载时，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调用多次Draw call分别绘制每一个子模型SubMesh。</p>
<p><strong>要在PlayerSettings中开启static batching，对需要静态合批物体的Static打钩即可</strong></p>
<ul>
<li>前提<ul>
<li>不能移动</li>
<li>材质球相同</li>
</ul>
</li>
<li>优点<ul>
<li>预先把所有的子模型的顶点变换到了世界空间下，并且这些子模型共享材质，所以在多次Draw call调用之间并没有渲染状态的切换，渲染API会<strong>缓存绘制命令</strong>，起到了渲染优化的目的。另外，在运行时所有的顶点位置处理不再需要进行计算，节约了计算资源。</li>
</ul>
</li>
<li>缺点<ul>
<li>打包之后体积增大，应用运行时所占用的内存体积也会增大。</li>
<li>需要额外的内存来存储合并的几何体。</li>
<li>注意如果多个GameObject在静态批处理之前共享相同的几何体，则会在编辑器或运行时为每个GameObject创建几何体的副本，这会增大内存的开销。例如，在密集的森林级别将树标记为静态可能会产生严重的内存影响。</li>
<li>静态合批在大多数平台上的限制是64k顶点和64k索引</li>
</ul>
</li>
</ul>
<p><strong>动态</strong></p>
<p>Unity自动处理</p>
<ul>
<li>前提<ul>
<li>相同材质球</li>
</ul>
</li>
<li>限制<ol>
<li>900个顶点数据（顶点坐标，法线，UV，UV0，UV1，切线等）以下的模型。</li>
<li>如果两个模型缩放大小不同，不能被合批的，即模型之间的缩放必须一致。</li>
<li>合并网格的材质球的实例必须相同。即材质球属性不能被区分对待，材质球对象实例必须是同一个。</li>
<li>如果他们有Lightmap数据，必须相同的才有机会合批。</li>
<li>使用多个pass的Shader是绝对不会被合批。因为Multi-pass Shader通常会导致一个物体要连续绘制多次，并切换渲染状态。这会打破其跟其他物体进行Dynamic batching的机会。</li>
<li>延迟渲染是无法被合批。</li>
</ol>
</li>
</ul>
<p><strong>GPU Instancing</strong></p>
<p>与动态和静态合批不同的是，GPU Instancing 并不通过对网格的合并操作来减少Drawcall，GPU Instancing 的处理过程是只提交一个模型网格让GPU绘制很多个地方，这些不同地方绘制的网格可以对缩放大小，旋转角度和坐标有不一样的操作，材质球虽然相同但材质球属性可以各自有各自的区别。</p>
<p>用于将同一模型渲染在不同地方且可以有参数上的差异，通过shader中的InstancingID区分</p>
<h4 id="TextMeshpro和text区别"><a href="#TextMeshpro和text区别" class="headerlink" title="TextMeshpro和text区别"></a>TextMeshpro和text区别</h4><p>Text是像素渲染放大之后就会模糊，使用Text父物体的放大缩小会影响子物体Text的清晰度， TMPText不会，它是网格渲染TMPText会把字体生成一个类似于贴图的东西然后读取贴图的坐标来获取对应的文字，更换文字的消耗会比Text大。<br>TMPText更适用于不会变动的文字，特别是在量大的情况下，性能比Text高一些，需要经常变动的问题用Text好点，TMPText在字体库很大的情况下查找更换会比较慢。</p>
<h4 id="image和sprite的区别"><a href="#image和sprite的区别" class="headerlink" title="image和sprite的区别"></a>image和sprite的区别</h4><ul>
<li>渲染上<ul>
<li>Image 通过UGUI的Image和CanvasRenderer组件组件来渲染</li>
<li>Sprite 通过SpriteRenderer组件来渲染</li>
</ul>
</li>
<li>使用上<ul>
<li>Image需要位于某个Canvas下才能显示出来</li>
<li>Sprite可以像普通的3D游戏物体一样对待，</li>
</ul>
</li>
<li>处理上<ul>
<li>Image为一个矩形的Sprite生成两个三角形拼成的矩形几何体，</li>
<li>Sprite则会根据显示内容，裁剪掉元素中的大部分透明区域，最终生成的几何体可能会有比较复杂的顶点结构。</li>
</ul>
</li>
</ul>
<p><strong>渲染管线的基本流程进行推断：</strong><br>1.Sprite由于顶点数据更加复杂，在进行顶点计算时会比Image效率更低；<br>2.Sprite会比Image执行较多的顶点着色器运算；<br>3.Image会比Sprite执行更多的片段着色器运算（Sprite会裁剪掉多余的像素，减少了片段着色器的计算并降低了overdraw，在绝大多数情况下，反而比Image拥有更好的效率）</p>
<h4 id="image和rawimage区别"><a href="#image和rawimage区别" class="headerlink" title="image和rawimage区别"></a>image和rawimage区别</h4><ul>
<li>Image<ul>
<li>开销大</li>
<li>只能使用Sprite</li>
<li>可以打图集，可以参与合批</li>
</ul>
</li>
<li>RawImage<ul>
<li>开销小</li>
<li>图片类型任意</li>
<li>不能打图集，不能参与合批</li>
</ul>
</li>
</ul>
<p>RawImage就放单独展示的图片就可以，或者是太大进不了图集或偶尔用一两次的图片，性能会比Image好很多</p>
<h4 id="mask和rectmask2d区别"><a href="#mask和rectmask2d区别" class="headerlink" title="mask和rectmask2d区别"></a>mask和rectmask2d区别</h4><ul>
<li>Mask<ul>
<li>采用着色器重绘</li>
<li>Mask主要处理不规则图形遮罩效果</li>
<li>Mask需要一个Image来当作遮罩区域,子节点在Image[渲染区域]才会显示</li>
<li>会产生额外drawcall，即使多个Mask之间可以进行合批(头和头合批, 子对象和子对象合批, 尾和尾合批),需要同渲染层级(depth), 同材质, 同图集</li>
<li>Mask内外不能进行合批.</li>
</ul>
</li>
<li>rectmask2d<ul>
<li>采用顶点重构</li>
<li>RectMask2D只能做矩形遮罩</li>
<li>RectMask2D以自身RectTransform为裁剪区域,子节点在[RectTransform区域]内显示</li>
<li>RectMask2D本身不产生drawcall.</li>
<li>不同RectMask2D的子对象不能合批.</li>
</ul>
</li>
</ul>
<p><strong>根据UGUI源码, 嵌套Mask不能超过9层, 超过部分会使用默认材质, 超出部分遮罩失效.</strong></p>
<h4 id="ui框架"><a href="#ui框架" class="headerlink" title="ui框架"></a>ui框架</h4><p>提供统一的接口开、关、初始化、销毁、查找、事件响应</p>
<h4 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h4><ul>
<li><strong>合并多张图，减少drawcall</strong></li>
<li>太大会导致空间浪费导致IO时间太长得不偿失</li>
<li>大图不打图集</li>
<li>OpenGL每张贴图都需要设置为2的N次方才能使用</li>
</ul>
<h5 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/strawberryPudding/p/16250365.html">https://www.cnblogs.com/strawberryPudding/p/16250365.html</a></p>
<ul>
<li>DXT：PC	</li>
<li>ETC：安卓</li>
<li>ASTC 安卓、IOS</li>
</ul>
<h4 id="Animation和Animator-的区别"><a href="#Animation和Animator-的区别" class="headerlink" title="Animation和Animator 的区别"></a>Animation和Animator 的区别</h4><h4 id="ugui优化"><a href="#ugui优化" class="headerlink" title="ugui优化"></a>ugui优化</h4><ul>
<li>动静分离</li>
<li>少移动开关</li>
<li>减少重叠</li>
<li>打图集</li>
</ul>
<h4 id="Astar算法"><a href="#Astar算法" class="headerlink" title="Astar算法"></a>Astar算法</h4><ul>
<li>优化<ul>
<li>离线计算</li>
<li>hcost权重</li>
<li>开列表排序方式</li>
<li>闭列表set<ul>
<li>findindex替代isclosed，全局版本index，被取出把格子的设为index</li>
</ul>
</li>
<li>拆分区域</li>
</ul>
</li>
</ul>
<h4 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h4><ul>
<li><p>Resources.Load()</p>
</li>
<li><p>StreamingAssets</p>
</li>
<li><p>AssetBundle</p>
<ul>
<li><p>优化：封装操作，加入引用计数器（类似智能指针），计数为0在随机秒数范围内销毁</p>
</li>
<li><p>&#96;&#96;&#96;c#<br>  public class CreateAssetBundles<br>  {<br>  [MenuItem(“Assets&#x2F;Build AssetBundles”)]<br>  static void BuildAllAssetBundles()<br>  {<br>      string dir &#x3D; “AssetBundles”;<br>      if (Directory.Exists(dir) &#x3D;&#x3D; false)<br>      {<br>          Directory.CreateDirectory(dir);<br>      }<br>      &#x2F;&#x2F;BuildTarget 选择build出来的AB包要使用的平台<br>      BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);<br>  }<br>  }</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 加载方法</span><br><span class="line"></span><br><span class="line">        - AssetBundle.LoadFromFile 从本地加载</span><br><span class="line">        - AssetBundle.LoadFromMemory 从内存加载</span><br><span class="line">        - WWW.LoadFromCacheOrDownload 下载后放在缓存中备用(该方法逐渐被弃用)</span><br><span class="line">        - UnityWebRequestAssetBundle 从服务器下载</span><br><span class="line"></span><br><span class="line">    - 加载资源</span><br><span class="line"></span><br><span class="line">        - AssetBundle.LoadAsset(assetName)</span><br><span class="line">        - AssetBundle.LoadAllAssets() 加载AB包中所有的对象，不包含依赖的包</span><br><span class="line">        - AssetBundle.LoadAssetAsync() 异步加载，加载较大资源的时候</span><br><span class="line">        - AssetBundle.LoadAllAssetsAsync() 异步加载全部资源</span><br><span class="line">        - AssetBundle.LoadAssetWithSubAssets 加载资源及其子资源</span><br><span class="line"></span><br><span class="line">    - 卸载资源</span><br><span class="line"></span><br><span class="line">        - AssetBundle.Unload(true) //卸载AB文件的内存镜像，且包含所有Load创建出来的对象</span><br><span class="line">        - AssetBundle.Unload(false) //卸载AB文件的内存镜像，但是除了Load创建出来的对象</span><br><span class="line">        - Reources.UnloadAsset(Object) //释放已加载的资源Object</span><br><span class="line">        - Resources.UnloadUnusedAssets //卸载所有没有被场景引用的资源对象</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">##### 资源路径</span><br><span class="line"></span><br><span class="line">Resource：加密</span><br><span class="line"></span><br><span class="line">StreamingAsset：不加密</span><br><span class="line"></span><br><span class="line">AssetBundle：</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/appppppen/article/details/51396256</span><br><span class="line"></span><br><span class="line">![img](/images/八股/20151207164623779.jpeg)</span><br><span class="line"></span><br><span class="line">#### 网络编程</span><br><span class="line"></span><br><span class="line">socket</span><br><span class="line">异步收发数据-双队列，多线程</span><br><span class="line">请求-顺序发，异步发，混合发，合并发</span><br><span class="line"></span><br><span class="line">#### 帧同步与状态同步	</span><br><span class="line"></span><br><span class="line">|                    | 状态同步                                                     | 帧同步                                                       |</span><br><span class="line">| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |</span><br><span class="line">| 流量               | 相对高                                                       | 相对低                                                       |</span><br><span class="line">| 回放（离线）       | 可以支持回放，但是逻辑比较复杂，需要不断记录状态信息，同时回放时候需要读取合适的时间。回放文件大 | 本身收集了所有玩家的输入信息进行逻辑推进，天然支持回放，且回放文件比较小 |</span><br><span class="line">| 回放（实时）       | 相对容易，可以方便的记录快照信息，并按照录制内容随时播放     | 比较复杂，客户端需要本地对全场状态进行序列化，才能回到目标时间。播完回放后还需要加速追上实时游戏状态 |</span><br><span class="line">| 安全性             | 服务器实现逻辑，安全性高                                     | 逻辑在客户端，反外挂压力大、无法避免开图挂                   |</span><br><span class="line">| 服务器压力         | 大                                                           | 小                                                           |</span><br><span class="line">| 战斗校验           | 协议加密，内存混肴，误差校验，无法彻底解决。                 | 服务器可以重启跑一遍战斗。                                   |</span><br><span class="line">| 网络卡顿的表现     | 瞬移，回位，莫名掉血                                         | 战斗卡顿                                                     |</span><br><span class="line">| 中途加入和断线重连 | 容易。由于实时记录了各个对象的状态信息，所以重连的时候，直接创建这些对象，并同步信息即可 | 比较复杂。可以在断线的时候，通过快捷播放服务器同步的帧数据来快速跟上游戏(追帧，太慢了就用**内存快照**) |</span><br><span class="line">| 实现               | 调优状态同步方式，客户端需要做插值处理。                     | 客户端按照单机方式开发，保证逻辑层和表现层分离。逻辑层不要用到浮点数，不要用不确定顺序的逻辑结构。对于物理引擎和浮点数计算要不能使用Unity的。 |</span><br><span class="line">| 网络延迟适应性     | 适应性较高，方便做各种插值优化。当然高延迟下，也容易产生位置突变 | 要求较低的延迟。如果延迟较高，所有玩家体验都不好。即使采用乐观帧锁定优化，高延迟下也容易产生卡顿 |</span><br><span class="line"></span><br><span class="line">实现帧同步的流程一般是：</span><br><span class="line"></span><br><span class="line">1.  同步随机数种子。(一般游戏中都设计随机数的使用， 通过同步随机数种子，可以保持随机数一致性)</span><br><span class="line">2.  客户端上传操作指令。(指令包括游戏操作和当前帧索引)</span><br><span class="line">3.  服务器广播所有客户端的操作。(如果没有操作， 也要广播空指令来驱动游戏帧前进)。</span><br><span class="line"></span><br><span class="line">断线检测：**心跳包**</span><br><span class="line"></span><br><span class="line">##### 定点数</span><br><span class="line"></span><br><span class="line">```c#</span><br><span class="line">class FixVal&#123;</span><br><span class="line"></span><br><span class="line">    const int total_bit_cnt = 64;//总位数</span><br><span class="line">    const int f_bit_cnt = 16;//小数位数</span><br><span class="line">    const int i_bit_cnt = total_bit_cnt - f_bit_cnt;//整数位数</span><br><span class="line">    const long f_mask = (long)(ulong.MaxValue &gt;&gt; i_bit_cnt);//小数部分掩码</span><br><span class="line">    const long i_mask = (long)(-1L &amp; ~f_mask);//整数部分掩码</span><br><span class="line">    const long f_range = f_mask + 1;//进位范围</span><br><span class="line">    public const long min_val = long.MinValue &gt;&gt; f_bit_cnt;//最小值</span><br><span class="line">    public const long max_val = long.MaxValue &gt;&gt; f_bit_cnt;//最大值</span><br><span class="line">    long mRaw;</span><br><span class="line"></span><br><span class="line">    public FixVal(int intVal):this(((long)intVal) &lt;&lt; f_bit_cnt)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FixVal(long raw)&#123;</span><br><span class="line">        mRaw = raw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long GetRaw()&#123;</span><br><span class="line">        return mRaw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static FixVal operator +(FixVal a, FixVal b)&#123;</span><br><span class="line">        return new FixVal(a.mRaw + b.mRaw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static FixVal operator -(FixVal a, FixVal b)&#123;</span><br><span class="line">        return new FixVal(a.mRaw - b.mRaw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static FixVal operator *(FixVal a, FixVal b)&#123;</span><br><span class="line">        return new FixVal((a.mRaw * b.mRaw + (f_range &gt;&gt; 1)) &gt;&gt; f_bit_cnt);//结果右移，因为是小数相乘</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static FixVal operator /(FixVal a, FixVal b)&#123;</span><br><span class="line">        return new FixVal((a.mRaw &lt;&lt; f_bit_cnt) / b.mRaw);//被除数左移，因为是小数相除</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static explicit operator double (FixVal fixVal)&#123;</span><br><span class="line">        return (double)(fixVal.mRaw &gt;&gt; f_bit_cnt) + (fixVal.mRaw &amp; f_mask) / (double)f_range;//右移得到整数部分，取与除以进位得到小数范围</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><p>二进制传输</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;  <span class="comment">// (位置1)</span></span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;  </span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;  <span class="comment">// (位置2)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123;  <span class="comment">//电话类型枚举值 </span></span><br><span class="line">    MOBILE = <span class="number">0</span>;  <span class="comment">//手机号  </span></span><br><span class="line">    HOME = <span class="number">1</span>;    <span class="comment">//家庭联系电话</span></span><br><span class="line">    WORK = <span class="number">2</span>;    <span class="comment">//工作联系电话</span></span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//电话号码phone消息体</span></span><br><span class="line">  <span class="comment">//组成包括号码number、电话类型 type</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> number = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">optional</span> PhoneType type = </span><br><span class="line">          <span class="number">2</span> [default = HOME]; <span class="comment">// (位置3)</span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>; <span class="comment">// (位置4)</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通讯录消息体，包括一个Person类的people</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">AddressBook</span> &#123; </span><br><span class="line">  <span class="keyword">repeated</span> Person people = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="摄像机渲染顺序"><a href="#摄像机渲染顺序" class="headerlink" title="摄像机渲染顺序"></a>摄像机渲染顺序</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55762351">https://zhuanlan.zhihu.com/p/55762351</a></p>
<ul>
<li>Camera Depth：摄像机深度，越小越优先</li>
<li>Sorting Layer：层级排序，越小越优先</li>
<li>Order in Layer：层内排序，越小越优先</li>
<li>RenderQueue：渲染队列。越小越优先</li>
<li>RenderQueue 相等，RenderQueue 2500已下（含2500）由近到远排序优先（<strong>2500已上由远到近排序优先</strong>）</li>
<li>即渲染时RenderQueue大的会挡住RenderQueue小的，不论它的Sorting Layer和Order in Layer怎么设置都是不起作用的。</li>
</ul>
<h4 id="摄像机参数"><a href="#摄像机参数" class="headerlink" title="摄像机参数"></a>摄像机参数</h4><ol>
<li><p>Clear Flags:清除标记。决定屏幕的哪部分将被清除。一般用户使用对台摄像机来描绘不同游戏对象的情况，有3中模式选择：<br> 　　Skybox：天空盒。默认模式。在屏幕中的空白部分将显示当前摄像机的天空盒。如果当前摄像机没有设置天空盒，会默认用Background色。<br> 　　Solid Color：纯色。选择该模式屏幕上的空白部分将显示当前摄像机的background色。<br> 　　Depth only：仅深度。该模式用于游戏对象不希望被裁剪的情况。<br> 　　Dont Clear：不清除。该模式不清除任何颜色或深度缓存。其结果是，每一帧渲染的结果叠加在下一帧之上。一般与自定义的shader配合使用。</p>
</li>
<li><p>Background：背景。设置背景颜色。在镜头中的所有元素渲染完成且没有指定skybox的情况下，将设置的颜色应用到屏幕的空白处。</p>
</li>
<li><p>Culling Mask：剔除遮罩，选择所要显示的layer。</p>
</li>
<li><p>Projection：投射方式。<br>　　Perspective：透视。摄像机将用透视的方式来渲染游戏对象。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<strong>Field of view</strong>：视野范围。用于控制摄像机的视角宽度以及纵向的角度尺寸。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Orthographic：正交。摄像机将用无透视的方式来渲染游戏对象。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Size：大小。用于控制正交模式摄像机的视口大小。</p>
</li>
<li><p>Clipping Planes： 剪裁平面。摄像机开始渲染与停止渲染之间的距离。<br>　　Near：近点。摄像机开始渲染的最近的点。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Far：远点。摄像机开始渲染的最远的点。</p>
</li>
<li><p>Viewport Rect：标准视图矩形。用四个数值来控制摄像机的视图将绘制在屏幕的位置和大小，使用的是屏幕坐标系，数值在0~1之间。坐标系原点在左下角。</p>
</li>
<li><p>Depth：深度。用于控制摄像机的渲染顺序，较大值的摄像机将被渲染在较小值的摄像机之上。</p>
</li>
<li><p>Rendering Path：渲染路径。用于指定摄像机的渲染方法。<br>　　Use Player Settings：使用Project Settings–&gt;Player中的设置。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Vertex Lit：顶点光照。摄像机将对所有的游戏对象座位顶点光照对象来渲染。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Forward：快速渲染。摄像机将所有游戏对象将按每种材质一个通道的方式来渲染。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Deferred Lighting：延迟光照。摄像机先对所有游戏对象进行一次无光照渲染，用屏幕空间大小的Buffer保存几何体的深度、法线已经高光强度，生成的Buffer将用于计算光照，同时生成一张新的光照信息Buffer。最后所有的游戏对象会被再次渲染，渲染时叠加光照信息Buffer的内容。</p>
</li>
<li><p>Target Texture: 目标纹理。用于将摄像机视图输出并渲染到屏幕。一般用于制作导航图或者画中画等效果。</p>
</li>
<li><p>HDR：高动态光照渲染。用于启用摄像机的高动态范围渲染功能。</p>
</li>
<li><p>Anti-aliasing ：抗锯齿模式</p>
</li>
</ol>
<h4 id="刚体"><a href="#刚体" class="headerlink" title="刚体"></a>刚体</h4><p><strong>Is Kinematic - 是否为运动学</strong></p>
<p>当这个打开的时候，物体就只能够通过修改Transform的方式去进行移动。</p>
<p>如果想要物体的运动不受其他力的影响，同时又需要保留Rigidbody属性，可以启用Is Kinematic。</p>
<p>一些不希望受到力的影响的物体包括：提供跳跃功能并且会移动的空中平台、敌人运动时的虚拟形象、以及静态触发器等。</p>
<p><strong>Interpolate - 运动插值</strong></p>
<p>让刚体的移动更平滑。当物理帧更新过长的时候，就需要开启这个选项。</p>
<p>物体的物理方面的更新和FixedTimeStep有关，如果这个参数过大，那么物体的运动则会变得非常的生硬。如果开启了运动插值的话，那么即使FixedTimeStep很大，物体的运动看起来也是十分顺滑的。</p>
<p>当物体移动速率过快时，可能会看见物体一闪而过的情况。此时启用Interpolate，物体的移动会变得清晰顺滑，但是此功能一般很少使用。</p>
<ul>
<li><p>None：不应用插值运算</p>
</li>
<li><p>Interpolate：根据前一帧的变换来平滑变换。</p>
</li>
<li><p>Extrapolate：根据下一帧的估计变换来平滑变换。</p>
</li>
</ul>
<p><strong>Collision Detection - 碰撞检测模式</strong></p>
<p><strong>Discrete - 离散碰撞检测</strong><br>离散碰撞检测在某一个时间段内，碰撞检测的时间点是随机分布的。性能消耗低，最容易穿过去。</p>
<p>对场景中的所有其他碰撞体使用离散碰撞检测，用于正常碰撞（默认值）。</p>
<p><strong>Continuous -连续检测</strong><br>Continuous Dynamic - 连续动态检测<br>Continuous和Continuous Dynamic的共同点在于，对待没有刚体和设置为Continuous Dynamic的物体都使用连续碰撞检测，对待设置为Discrete的刚体的物体则使用离散碰撞检测。</p>
<p>不同点在于，Continuous Dynamic检测另一个设置为Continuous的物体时，仍然使用连续碰撞检测模式，而Continuous检测另一个Continuous的物体时，则使用离散碰撞检测。</p>
<p>（同离散，异连续）</p>
<p>这两种方法依赖于连续（线性）扫描技术，因此在物体旋转迅速的情况下，会忽略物体的角速度，仍然可能会穿过墙壁。</p>
<p><strong>Continuous Speculative - 连续推测检测</strong><br>比连续碰撞检测的成本更低。</p>
<p>在Unity2018.3版本中新添了Continuous Speculative方法，该会根据物体的线性运动和角运动预测物体在不受阻挡时下一步的位置（位置不确定，但是能够被延伸），并根据下一步位置与当前位置划定一个broad-phase axis-aligned的最小包围框。通过算法推测并且选取最小包围框中与墙壁（如果存在）可能发生碰撞的触点并进行记录，并将记录送入解算器，确保球体不会穿过墙壁。由于该算法是基于推测式的方法，所以开销会小于基于扫描式的算法。</p>
<p>性能消耗关系<br>Continuous Dynamic &gt; Continuous Speculative &gt; Continuous &gt; Discrete</p>
<h4 id="GUID和Meta"><a href="#GUID和Meta" class="headerlink" title="GUID和Meta"></a>GUID和Meta</h4><p>GUID标识每一个文件，独一无二，meta是个文件，用yaml语法存储guid，时间戳，子文件fileid等</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CodeGize/p/8697227.html">https://www.cnblogs.com/CodeGize/p/8697227.html</a></p>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>慢在哪里：</p>
<ul>
<li>磁盘IO</li>
<li>内存分配</li>
<li>构造对象与初始化</li>
<li>GC</li>
</ul>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59619632">https://zhuanlan.zhihu.com/p/59619632</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/game_jqd/article/details/52104438">https://blog.csdn.net/game_jqd/article/details/52104438</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiudesuo/article/details/84551180">https://blog.csdn.net/qiudesuo/article/details/84551180</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luoyikun/article/details/122326342">https://blog.csdn.net/luoyikun/article/details/122326342</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/279383752">https://zhuanlan.zhihu.com/p/279383752</a></p>
<p>本质上是一个通过IEnumerator<strong>迭代器</strong>实现的状态机（state为执行到哪一步），当执行到yield时会将协程的代码权限交给父线程，这个协程的代码被挂起，直到父线程使用MoveNext，才会继续执行yield后面的代码</p>
<p>还是在主线程干的，不算异步</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;  </span><br><span class="line">   </span><br><span class="line">    Object Current &#123; <span class="keyword">get</span>; &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p><strong>每帧执行协程的MoveNext（）方法，当为true时继续往下执行</strong></p>
<p>C#没有协程，我们经常听到或看到C#协程的概念，主要来自于Unity，它对yield做了一些改造:</p>
<ol>
<li>基于yield返回的对象，只能是YieldInstruction的子类(它最重要的方法是bool IsDone()，用于判断当前任务是否已经完成)</li>
<li>默认实现了部分预定义的YieldInstruction，如WaitForSeconds，null，WaitForEndOfFrame等，以实现常用的协程控制(告诉Unity协程的唤醒时机)</li>
<li>Unity Runtime会根据返回的YieldInstruction对象类型，在合适(IsDone()&#x3D;&#x3D;true)的时候唤醒协程(无需显示MoveNext)</li>
<li>支持协程嵌套</li>
<li>简单的协程生命周期管理(提供StopCoroutine接口)，并将协程的生命周期与GmaeObject绑定</li>
</ol>
<p>在启动一个协程时，Unity会先调用得到的IEnumerator的MoveNext一次，以拿到IEnumerator的Current值。所以每启动一个协程，协程函数会立即执行到第一个yield return处然后“停住”。</p>
<p>对于不同的Current类型（一般是YieldInstruction的子类），Unity已做好了一些默认处理，比如：</p>
<ol>
<li>如果Current是null，就相当于什么也不做。在下一次游戏循环中，就会调用MoveNext。所以yield return null就起到了等待一帧的作用</li>
<li>如果Current是WaitForSeconds类型，Unity会获取它的等待时间，每次游戏循环中都会判断时间是否到了，只有时间到了才会调用MoveNext。所以yield return WaitForSeconds就起到了等待指定时间的作用</li>
<li>如果Current是UnityWebRequestAsyncOperation类型，它是AsyncOperation的子类，而AsyncOperation有isDone属性，表示操作是否完成，只有isDone为true时，Unity才会调用MoveNext。对于UnityWebRequestAsyncOperation而言，只有请求完成了，才会将isDone属性设置为true。</li>
</ol>
<h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>主要用到字典和队列数据结构</p>
<p>水位线对象池：池内对象低于一定个数就实例化新的</p>
<h4 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h4><p><strong>Ray</strong>射线</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/Ray-direction.html">direction</a></td>
<td>射线的方向。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/Ray-origin.html">origin</a></td>
<td>射线的原点。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/Ray.GetPoint.html">GetPoint</a></td>
<td>返回射线上 distance 个单位处的点。</td>
</tr>
</tbody></table>
<p><strong>RaycastHit</strong>射线击中</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-articulationBody.html">articulationBody</a></td>
<td>命中的接合体</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-barycentricCoordinate.html">barycentricCoordinate</a></td>
<td>命中的三角形的重心坐标。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-collider.html">collider</a></td>
<td>命中的 Collider。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-colliderInstanceID.html">colliderInstanceID</a></td>
<td>Instance ID of the Collider that was hit.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-distance.html">distance</a></td>
<td>从射线原点到撞击点的距离。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-lightmapCoord.html">lightmapCoord</a></td>
<td>撞击点处的 UV 光照贴图坐标。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-normal.html">normal</a></td>
<td>射线命中的表面的法线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-point.html">point</a></td>
<td>世界空间中射线命中碰撞体的撞击点。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-rigidbody.html">rigidbody</a></td>
<td>命中的碰撞体的 Rigidbody。如果该碰撞体未附加到刚体，则值为 &#x2F;null&#x2F;。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-textureCoord.html">textureCoord</a></td>
<td>碰撞位置处的 UV 纹理坐标。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-textureCoord2.html">textureCoord2</a></td>
<td>撞击点处的辅助 UV 纹理坐标。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-transform.html">transform</a></td>
<td>命中的刚体或碰撞体的 Transform。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/ScriptReference/RaycastHit-triangleIndex.html">triangleIndex</a></td>
<td>命中的三角形的索引。</td>
</tr>
</tbody></table>
<p><strong>Physics.Raycast</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>origin</td>
<td>射线在世界坐标系中的起点。</td>
</tr>
<tr>
<td>direction</td>
<td>射线的方向。</td>
</tr>
<tr>
<td>maxDistance</td>
<td>射线应检查碰撞的最大距离。</td>
</tr>
<tr>
<td>layerMask</td>
<td><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/Manual/Layers.html">层遮罩</a>，用于在投射射线时有选择地忽略碰撞体。</td>
</tr>
<tr>
<td>queryTriggerInteraction</td>
<td>指定该查询是否应该命中触发器。</td>
</tr>
</tbody></table>
<p>Physics2D里还有Overlap系列函数</p>
<h4 id="Area-Of-Interest"><a href="#Area-Of-Interest" class="headerlink" title="Area Of Interest"></a>Area Of Interest</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73915763/article/details/132586363">https://blog.csdn.net/m0_73915763/article/details/132586363</a></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="TCP-x2F-IP四层网络模型"><a href="#TCP-x2F-IP四层网络模型" class="headerlink" title="TCP&#x2F;IP四层网络模型"></a>TCP&#x2F;IP四层网络模型</h4><p><img src="/images/%E5%85%AB%E8%82%A1/f1e2ebbae1aa1e972d02b0f7432566b8.png" alt="img"></p>
<ul>
<li>应用层：HTTP，DNS…</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP（ARP）</li>
<li>链路层：物理层+数据链路层（MAC）</li>
</ul>
<h4 id="计算机五层网络模型"><a href="#计算机五层网络模型" class="headerlink" title="计算机五层网络模型"></a>计算机五层网络模型</h4><ul>
<li><p>应用层：为应用程序提供服务</p>
</li>
<li><p>传输层：建立、管理和维护端到端的连接</p>
</li>
<li><p>网络层：IP选址和路由选择</p>
</li>
<li><p>数据链路层：分帧，确定mac地址</p>
</li>
<li><p>物理层：真正的物理设备传输数据，物理层将2进制数据利用电脉冲在物理媒介上实现比特流的传输。</p>
</li>
</ul>
<h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="/images/%E5%85%AB%E8%82%A1/image-20240327111347249.png" alt="image-20240327111347249"></p>
<ul>
<li>应用层：为应用程序提供服务</li>
<li>表示层：数据格式转化，兼容并且适合传输的格式（起到翻译的作用）、数据加密。</li>
<li>会话层：建立、管理和维护会话，它主要负责数据传输中设置和维护网络中两台设备之间的通信连接。</li>
<li>传输层：建立、管理和维护端到端的连接</li>
<li>网络层：IP选址和路由选择</li>
<li>数据链路层：分帧，确定mac地址</li>
<li>物理层：真正的物理设备传输数据，物理层将2进制数据利用电脉冲在物理媒介上实现比特流的传输。</li>
</ul>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p><img src="/images/%E5%85%AB%E8%82%A1/image-20240327100613019.png" alt="image-20240327100613019"></p>
<ul>
<li>FTP用的是TCP</li>
</ul>
<h4 id="TCP的三握四挥"><a href="#TCP的三握四挥" class="headerlink" title="TCP的三握四挥"></a><strong>TCP的三握四挥</strong></h4><p><img src="/images/%E5%85%AB%E8%82%A1/image-20240327144436944.png" alt="image-20240327144436944"></p>
<p>第一次握手失败：客户端重传</p>
<p>第二次握手失败：客户端重传，超时服务端会释放资源</p>
<p>第三次握手失败：服务器重传或直接发送RST关闭连接，<strong>防止SYN洪泛攻击</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240327144454345.png" alt="image-20240327144454345"></p>
<ol>
<li><p>第一个FIN丢了，a收不到ack，就会重传fin</p>
</li>
<li><p>第一个ack丢了，a收不到ack就会重传fin</p>
</li>
<li><p>第二个fin丢了，b收不到ack就会重传fin</p>
</li>
<li><p>第二个ack丢了，b收不到ack还是会重传fin</p>
</li>
</ol>
<p><strong>为什么要四次挥手（常问）</strong></p>
<p>​    服务端在收到客户端的释放报文时，可能自己的数据报还没有发完，所以不会直接返回FIN+ACK，而只先返回一个ACK，表示自己收到了客户端的释放请求（第二次挥手）。等到服务端报文发完以后，在返回FIN（第三次挥手）。</p>
<p>为什么不能直接CLOSE状态，必须要先设置TIME_WAIT(2个MSL）状态</p>
<p>   理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能客户端发送给服务的的最后一个ACK丢失。一段时间后，服务端收不到最后的ACK，认为客户端没有收到FIN请求（第三次挥手），进行超时重发，但是客户端已经关闭了，不会给响应。（理论上来说 服务器超时重发5次后，就会主动断开连接，这样数据既不会丢失也不会错乱，是可以的，但是这样不符合可靠连接。）</p>
<p>  此时若旧的客户端直接CLOSE没有TIME_WAIT状态，新的客户端建立与服务端之间的连接，如果新连接和老连接的端口是一样的。假设老连接还有一些数据，因为网络或者其他原因，一直滞留没有发送成功，新连接建立后，就直接发送到新连接里面去了，造成数据的紊乱，因此，我们需要2*MSL的TIMEWAIT状态，让滞留在网络中的报文失效，再去建立新的连接。</p>
<h4 id="TCP为什么稳定"><a href="#TCP为什么稳定" class="headerlink" title="TCP为什么稳定"></a>TCP为什么稳定</h4><p>​    与 乱序重排、应答确认、报文重传 和 流量控制 四种机制有关。</p>
<ul>
<li><strong>乱序重排</strong><ul>
<li>由于网络或“多线程”等因素，接收方收到的数据段很可能是乱序的，不过因为每个 TCP 封装都有序号，接收方重组起来非常容易。</li>
</ul>
</li>
<li><strong>应答确认</strong><ul>
<li>计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测 “确认号（Ack）字段”，看 Ack &#x3D; Seq + 1 是否成立，如果成立说明对方正确收到了自己的数据包。</li>
</ul>
</li>
<li><strong>报文重传</strong><ul>
<li>TCP 的报文重传有两种独立的办法。一种是超时重传，一种是快速重传。<ul>
<li>超时重传<ul>
<li>因为网速 并不是稳定的，传输时的每个报文的延时也不一样。TCP 会根据报文的往返时间（RTT）自动调整超时重传时间（RTO）。发送方每发一个报文段都会开始计时，如果时间超过 RTO 还没收到这个报文段的确认，就重传该报文段。</li>
</ul>
</li>
<li>快速重传<ul>
<li>接收方收到序号X 后，回复X+1的确认号，希望收到X+1序号报文，但没有收到，却收到了比X+1还要大的报文，就连续发出确认号X+1的报文，如果发送方连续三次收到重复的确认号，立即重发该报文段，而不管是否超时。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>流量控制</strong><ul>
<li>所谓流量控制就是让发送发送速率不要过快，让接收方来得及接 收。利用<strong>滑动窗口</strong>机制就可以实施流量控制。原理这就是<strong>运用 TCP 报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</strong></li>
<li>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。解决这个问题，TCP 为每一个连接设置一个持续计时（persistence timer）。只要 TCP 的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小。</li>
</ul>
</li>
</ul>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><p>拥塞的发生是因为路由器缓存溢出，拥塞会导致丢包，但丢包不一定触发拥塞。拥塞控制是快速传输的基础。一个拥塞控制算法一般包括<strong>慢启动算法、拥塞避免算法、快速重传算法、快速恢复算法</strong>四部分。</p>
<h4 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h4><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<p>1）发送方原因</p>
<p>TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</p>
<ul>
<li>只有上一个分组得到确认，才会发送下一个分组</li>
<li>收集多个小分组，在一个确认到来时一起发送</li>
</ul>
<p>Nagle算法造成了发送方可能会出现粘包问题</p>
<p>（2）接收方原因</p>
<p>TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
<p><strong>如何解决</strong></p>
<p>（1）应用层</p>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p>
<p>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息：接收方以固定间隔切割数据流，不够灵活</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构：比如额外定义包头告知长度</li>
</ul>
<p>（2）发送方</p>
<p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>（3）接收方</p>
<p>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p>
<h4 id="报文头"><a href="#报文头" class="headerlink" title="报文头"></a>报文头</h4><p>TCP</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421114446660.png" alt="image-20240421114446660"></p>
<p>UDP</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421114511663.png" alt="image-20240421114511663"></p>
<h4 id="可靠UDP"><a href="#可靠UDP" class="headerlink" title="可靠UDP"></a>可靠UDP</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liukuan73/article/details/82798508">https://blog.csdn.net/liukuan73/article/details/82798508</a></p>
<p>参考TCP，在应用层实现：</p>
<ul>
<li><p>seq&#x2F;ack机制</p>
</li>
<li><p>发送和接收缓存区、窗口机制</p>
</li>
<li><p>超时数据重传机制</p>
</li>
</ul>
<p>常见： RUDP、RTP、UDT</p>
<h5 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/503602472">https://zhuanlan.zhihu.com/p/503602472</a></p>
<p><a target="_blank" rel="noopener" href="https://wetest.qq.com/labs/391">https://wetest.qq.com/labs/391</a></p>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>在网络层以上实现网络互连，为不同网络（段）的设备提供连接</p>
<h4 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h4><p>MTU，数据链路层规定的每一帧的最大长度，超过这个长度数据会被分片。通常MTU的长度为1500字节，IP协议规定所有的路由器均应该能够转发（512数据+60IP首部+4预留&#x3D;576字节）的数据。MSS，最大输出大小（双方的约定），<strong>合理的MTU应该是保证数据不被再分的前提下，尽可能的大。</strong><br>以太网的MTU通常为1500字节-IP头（20字节固定+40字节可选）-UDP头8个字节&#x3D;1472字节。<strong>KCP会考虑多传输协议，但是在UDP的情况下，设置为1472字节更为合理。</strong></p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p><img src="/images/%E5%85%AB%E8%82%A1/SouthEast.jpeg" alt="img"></p>
<p>Socket是介于网络层和传输层的接口</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Server</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 监听IP地址和端口</span></span><br><span class="line">        IPAddress ipAddress = IPAddress.Parse(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        IPEndPoint localEndPoint = <span class="keyword">new</span> IPEndPoint(ipAddress, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建TCP监听器</span></span><br><span class="line">        TcpListener listener = <span class="keyword">new</span> TcpListener(localEndPoint);</span><br><span class="line">        listener.Start();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;服务器已启动，等待客户端连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受客户端连接</span></span><br><span class="line">        TcpClient client = listener.AcceptTcpClient();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;客户端已连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取网络流</span></span><br><span class="line">        NetworkStream stream = client.GetStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取客户端发来的数据</span></span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">int</span> bytesRead = stream.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">        <span class="built_in">string</span> data = Encoding.ASCII.GetString(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;接收到客户端数据：&#123;0&#125;&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送响应给客户端</span></span><br><span class="line">        <span class="built_in">string</span> response = <span class="string">&quot;Hello, client!&quot;</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] responseData = Encoding.ASCII.GetBytes(response);</span><br><span class="line">        stream.Write(responseData, <span class="number">0</span>, responseData.Length);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;响应已发送给客户端&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        stream.Close();</span><br><span class="line">        client.Close();</span><br><span class="line">        listener.Stop();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;服务器已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Client</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        <span class="built_in">string</span> serverIP = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="built_in">int</span> serverPort = <span class="number">8080</span>;</span><br><span class="line">        TcpClient client = <span class="keyword">new</span> TcpClient(serverIP, serverPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取网络流</span></span><br><span class="line">        NetworkStream stream = client.GetStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据给服务器</span></span><br><span class="line">        <span class="built_in">string</span> message = <span class="string">&quot;Hello, server!&quot;</span>;</span><br><span class="line">        <span class="built_in">byte</span>[] requestData = Encoding.ASCII.GetBytes(message);</span><br><span class="line">        stream.Write(requestData, <span class="number">0</span>, requestData.Length);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;已发送数据给服务器：&#123;0&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务器的响应</span></span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">int</span> bytesRead = stream.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">        <span class="built_in">string</span> response = Encoding.ASCII.GetString(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;接收到服务器响应：&#123;0&#125;&quot;</span>, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        stream.Close();</span><br><span class="line">        client.Close();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;客户端已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101134290">https://zhuanlan.zhihu.com/p/101134290</a></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/v2-900262432b5e6140f5cc4849c2cb07bb_720w.webp" alt="img"></p>
<h4 id="HTTP长连接"><a href="#HTTP长连接" class="headerlink" title="HTTP长连接"></a>HTTP长连接</h4><p>长连接：HTTP 发送请求时，要先创建一个 TCP 连接，并在 TCP 连接上把 HTTP 请求的内容发送并且接收完返回，这是一次请求完成，浏览器与服务器进行协商是否关闭 TCP 链接，若不关闭 TCP 连接会有一定的消耗，好处是如果还有请求可以直接在这个 TCP 连接上发送，不需要经过创建时三次握手的消耗。</p>
<p>短连接：若关闭 TCP 连接，下次请求需要重新创建，这时会有网络延迟的开销，好处是每次请求完关闭 TCP 连接，减少客户端和服务端连接的并发数。</p>
<ul>
<li><p>http 请求是在 tcp 连接上发送的，一个 tcp 连接可以发送多个 http 请求</p>
</li>
<li><p>在 http 1.1 中 http 请求在 tcp 上进行发送有先后顺序，为了提高性能，需要使用并发 tcp 连接的方式。</p>
</li>
<li><p>在 http 2 中，可以在一个 tcp 连接上并发的发送 http 请求，所以只需要开一个 tcp 连接。</p>
</li>
</ul>
<h4 id="HTTP的版本历史"><a href="#HTTP的版本历史" class="headerlink" title="HTTP的版本历史"></a>HTTP的版本历史</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/472698466?utm_id=0">https://zhuanlan.zhihu.com/p/472698466?utm_id=0</a></p>
<h4 id="从浏览器地址栏输入url到页面显示的过程"><a href="#从浏览器地址栏输入url到页面显示的过程" class="headerlink" title="从浏览器地址栏输入url到页面显示的过程"></a>从浏览器地址栏输入url到页面显示的过程</h4><h5 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h5><p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAYmFuZ3NoYW8xOTg5,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>找到之后访问443端口建立TCP连接</p>
<h5 id="https如何加密的"><a href="#https如何加密的" class="headerlink" title="https如何加密的"></a>https如何加密的</h5><p><img src="/images/%E5%85%AB%E8%82%A1/70.png" alt="img"></p>
<p>CA证书的公钥加密，各自的私钥解密</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>进程：一个应用程序相当于一个进程，是操作系统资源分配的基本单位。 一个进程拥有多个线程。更安全。</p>
<p>线程：是程序的实际执行者。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，一个线程只有一个进程。效率高。</p>
<p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源</p>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>一个线程从属于一个进程；一个进程可以包含多个线程。</li>
<li>一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。</li>
<li><strong>调度的基本单位</strong>：进程是系统资源调度(CPU分配资源)的最小单位；线程是CPU调度的最小单位。</li>
<li>在同一进程中，线程的切换不会引起进程切换，在由一个进程中的线程切换到另一个进程中的线程时，将会引起进程切换。</li>
<li><strong>系统开销</strong>：进程系统开销显著大于线程开销，在创建或撤消进程时，OS所付出的开销将显著大于创建或撤消线程时的开销。线程切换的代价远低于进程切换的代价。同一进程中的多个线程之间的同步和通信也比进程的简单。</li>
<li>进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。</li>
<li><strong>拥有资源</strong>：进程是系统中拥有资源的一个基本单位，它可以拥有资源。线程本身不拥有系统资源，仅有一点保证独立运行的资源。允许多个线程共享其隶属进程所拥有的资源。</li>
<li><strong>并发性</strong>：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，也可并发执行。</li>
<li>进程适应于多核、多机分布；线程适用于多核，支持多处理机系统</li>
<li><strong>独立性</strong>：同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。</li>
</ul>
<h4 id="线程和协程"><a href="#线程和协程" class="headerlink" title="线程和协程"></a>线程和协程</h4><p><img src="/images/%E5%85%AB%E8%82%A1/a420b296934a4d389c1bce542fba3929.png" alt="img"></p>
<p>进程调度算法</p>
<ul>
<li>先来先服务FCFS</li>
<li>短作业优先SJF</li>
<li>优先级调度PR</li>
<li>轮转调度RR</li>
<li>多级反馈队列</li>
<li>基于公平原则</li>
</ul>
<h4 id="线程的资源"><a href="#线程的资源" class="headerlink" title="线程的资源"></a>线程的资源</h4><ul>
<li>独立<ul>
<li>线程运行的本质就是函数的执行，函数运行时的信息保存在栈帧中，包括函数的返回值、使用的局部变量、寄存器信息等，因此每个进程都有自己独立的、私有的栈区</li>
<li>程序计数器、函数运行使用的寄存器组的值也是线程私有的</li>
<li>每个线程用户独立的线程ID、独立的调度优先级、错误返回码</li>
</ul>
</li>
<li>共享<ul>
<li>代码区</li>
<li>数据区（全局变量和静态变量）</li>
<li>堆区</li>
<li>动态链接库</li>
<li>文件</li>
<li>线程共享当前工作目录、以及用户ID和组ID</li>
</ul>
</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p><strong>银行家算法</strong> Dijkstra <strong>避免死锁</strong>。</p>
<blockquote>
<p>设有 $m$ 种资源，分别当前还有 $available_i$ 个；$n$ 个进程，第 $i$ 个进程需要第 $j$ 种 $max_{i,j}$ 个，已经分配了 $allocation_{i,j}$ 个，还需要 $need_{i,j}$ 个，显然 $need_{i,j}&#x3D;max_{i,j}-allocation_{i,j}$。设进程请求 $request_{i,j}$ 个资源，每次请求执行算法如下：</p>
<ol>
<li><p>若 $request_{i,j} &gt; need_{i,j}$ 报错，请求超过最大值</p>
</li>
<li><p>否则，若 $request_{i,j} &gt; available_j$ 表示尚无足够资源，需要等待</p>
</li>
<li><p>否则，尝试分配，即 $available_j$ 减少，$allocation_{i,j}$ 增加，$need_{i,j}$ 增加</p>
</li>
<li><p>若分配后处于安全状态，则分配结束；否则，分配作废，撤销分配并让其等待。检测是否处于安全性的算法为：</p>
<p> 令 $work&#x3D;available$，设每个进程 $finish_i&#x3D;0$，然后：</p>
<ol>
<li><p>不断找到 $k$ 满足 $finish_k&#x3D;0,need_{k,j}\le work_j$，使其完成，即 $finish_k&#x3D;1,work_j$ 加上 $allocation_{j,k}$</p>
<p> 如果找不到，就不安全；如果最终使得全部 $finish&#x3D;1$ 则安全</p>
</li>
</ol>
</li>
</ol>
</blockquote>
<ol>
<li>加锁顺序（线程按照一定的顺序加锁）</li>
<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</li>
<li>死锁检测</li>
</ol>
<h4 id="进程间通信的方法"><a href="#进程间通信的方法" class="headerlink" title="进程间通信的方法"></a>进程间通信的方法</h4><ul>
<li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该 函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
</ul>
<h4 id="线程间通信方法"><a href="#线程间通信方法" class="headerlink" title="线程间通信方法"></a>线程间通信方法</h4><ul>
<li><p>Java</p>
<ul>
<li>线程上下文：<strong>任务从保存到再加载的过程就是一次上下文切换</strong></li>
<li>共享内存</li>
<li>IPC通信</li>
<li>套接字</li>
</ul>
</li>
<li><p>消息传递</p>
</li>
<li><p>管道流</p>
</li>
<li><p>锁</p>
</li>
<li><p>信号量</p>
</li>
<li><p>信号</p>
</li>
</ul>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存（Virtual Memory）是计算机操作系统中的一种技术，它扩展了计算机系统的内存管理能力，并提供了更大的可用内存空间。</p>
<p>虚拟内存通过将物理内存与磁盘空间结合使用，创建了一个抽象的、更大的内存空间。它将每个程序视为占用一块连续的虚拟地址空间，这个虚拟地址空间被分割成固定大小的块，称为页面（Page）或页面框（Page Frame）。</p>
<p>当程序需要访问一个虚拟地址上的数据时，虚拟内存系统会将相应的页面加载到物理内存中。如果所需的页面已经在物理内存中，则程序可以直接访问。如果所需的页面不在物理内存中，那么虚拟内存系统会将一部分暂时不用的物理内存页面换出（称为页面置换）到磁盘上，然后将所需的页面从磁盘加载到物理内存中，使程序可以访问。</p>
<p>虚拟内存的优势包括：</p>
<ol>
<li>扩展内存容量：虚拟内存提供了更大的可用内存空间，远远超过物理内存的容量。这使得系统可以同时运行更多的程序，并处理更大的数据集。</li>
<li>内存共享和保护：虚拟内存允许多个程序共享同一份代码和数据，从而节省内存空间。同时，它还提供了内存保护机制，确保一个程序不能访问或修改其他程序的内存空间。</li>
<li>页面置换和缓存：虚拟内存的页面置换机制允许系统根据需要将数据从磁盘加载到内存，从而有效地管理内存资源。此外，虚拟内存系统还可以利用物理内存中的页面缓存，提高对常用数据的访问速度。</li>
</ol>
<p>虚拟内存的实现涉及到地址映射、页面置换算法、页面错误处理等复杂的机制。操作系统负责管理虚拟内存，并提供相应的接口供应用程序使用。</p>
<p>作用：</p>
<ol>
<li>内存访问保护：虚拟映射后可以自定义界限，防止越界，提高安全性</li>
<li>按需分页（lazy load技术）：软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系</li>
<li>页换入换出（page swap in&#x2F;out）：把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中</li>
<li>写时复制（copy on write）：两个虚拟页的数据内容相同时，可只分配一个物理页框，这样如果对两个虚拟页的访问方式是只读方式，这这两个虚拟页可共享页框，节省内存空间；如果CPU对其中之一的虚拟页进行写操作，则这两个虚拟页的数据内容会不同，需要分配一个新的物理页框，并将物理页框标记为可写，这样两个虚拟页面将映射到不同的物理页帧，确保整个内存空间的正确访问</li>
</ol>
<h4 id="多线程劣势情况"><a href="#多线程劣势情况" class="headerlink" title="多线程劣势情况"></a>多线程劣势情况</h4><p>多线程和单线程是在计算机程序中常见的执行模型，它们各有优势和适用场景。然而，有些情况下多线程可能不如单线程，以下是一些可能导致多线程不如单线程的情况：</p>
<ol>
<li><p>线程同步开销：多线程编程中，线程之间需要进行同步，以确保共享资源的正确访问。同步机制如互斥锁、信号量等引入了额外的开销，包括竞争条件、死锁和上下文切换等。如果同步开销超过了并行计算的收益，多线程的性能可能不如单线程。</p>
</li>
<li><p>资源竞争：当多个线程同时访问共享资源时，可能会引发资源竞争的问题，如数据竞争和死锁。如果程序设计不合理或没有正确处理资源竞争，多线程可能导致错误和性能下降。</p>
</li>
<li><p>响应性要求不高：在某些应用场景中，对于响应速度要求不高的任务，使用多线程并行计算的好处可能不明显。相反，多线程引入的复杂性和开销可能会使得程序更难以理解和调试。</p>
</li>
<li><p>单核处理器：在单核处理器上，多线程并不能真正并行执行，而是通过时间片轮转或上下文切换来模拟并发。在这种情况下，多线程的开销可能超过了性能的收益。</p>
</li>
<li><p>编程复杂性：多线程编程相对于单线程编程更复杂，需要考虑线程同步、数据共享、线程间通信等问题。如果程序员没有正确地实现和管理多线程，可能会导致错误和性能下降。</p>
</li>
</ol>
<p>总之，多线程不一定总是比单线程更好，它们在不同的场景下有各自的优势和限制。在考虑使用多线程时，需要综合考虑程序的特点、任务的性质以及硬件环境等因素，权衡利弊，选择合适的执行模型。</p>
<h4 id="锁与原子操作"><a href="#锁与原子操作" class="headerlink" title="锁与原子操作"></a>锁与原子操作</h4><p>Java的</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/62e8935571b6422a9044663ad2f24e7b.png" alt="img"></p>
<p>i++和++i都不是原子操作</p>
<h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p><strong>定义</strong><br>指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个<strong>分页</strong>时，由中央处理器的<strong>内存管理单元</strong>所发出的中断。</p>
<p><strong>步骤</strong><br>每当所要访问的页面不在内存时，会产生一次缺页中断，陷入内核，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<ol>
<li>保护CPU现场</li>
<li>分析中断原因</li>
<li>转入缺页中断处理程序进行处理</li>
<li>恢复CPU现场，继续执行</li>
</ol>
<p><strong>区别</strong><br>缺页中断是由于所要访问的页面不存在与内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<ol>
<li>在指令执行期间产生和处理缺页中断信号</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
<li>缺页中断返回时，执行产生中断的那一条指令（再次判断），而一般的中断返回时，执行下一条指令</li>
</ol>
<p><strong>页面置换算法</strong><br>进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区。但此时应该把那个页面换出，则需要根据一定的页面置换算法（Page Replacement Algorithm)来确定。</p>
<ol>
<li>最佳置换（Optimal， OPT)</li>
<li>先进先出置换算法（First In First Out, FIFO)</li>
<li>最近最久未使用置换算法（Least Recently Used， LRU）</li>
</ol>
<h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><h4 id="int最小值-最大值的二进制表示"><a href="#int最小值-最大值的二进制表示" class="headerlink" title="int最小值, 最大值的二进制表示"></a>int最小值, 最大值的二进制表示</h4><p>0x80000000<br>10000000 00000000 00000000 00000000</p>
<p>0x7fffffff<br>01111111 11111111 11111111 11111111</p>
<h4 id="有符号整数和无符号整数的右移操作"><a href="#有符号整数和无符号整数的右移操作" class="headerlink" title="有符号整数和无符号整数的右移操作"></a>有符号整数和无符号整数的右移操作</h4><p>无符号整数: 空位补0</p>
<p>有符号数: 算术移位</p>
<ul>
<li>对于有符号数 int<ul>
<li>正数，左移直接丢弃最高位，在低位补对应个数的0；</li>
<li>正数，右移直接丢弃最低位，在高位补对应个数的0；</li>
<li>负数，左移直接丢弃最高位，在低位补对应个数的0；</li>
<li>负数，右移直接丢弃最低位，在高位补对应个数的1；</li>
</ul>
</li>
<li>对于无符号数 unsigned int<ul>
<li>左移直接丢弃最高位，在低位补对应个数的0；</li>
<li>右移直接丢弃最低位，在高位补对应个数的0，即使最高位原来是1。</li>
</ul>
</li>
</ul>
<h4 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h4><ul>
<li>小端：数字的低位存储到内存的低地址上。</li>
<li>大端：数字的低位存储到内存的高地址上。</li>
</ul>
<p>UDP&#x2F;TCP&#x2F;IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的， 所以说,网络字节序是<strong>大端字节序</strong>。</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NjU5Mg==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<h4 id="CacheLine"><a href="#CacheLine" class="headerlink" title="CacheLine"></a>CacheLine</h4><p>一读读一整块（一个cacheline大小）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21125183/article/details/80590934">https://blog.csdn.net/qq_21125183/article/details/80590934</a></p>
<h3 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h3><h4 id="点乘叉乘"><a href="#点乘叉乘" class="headerlink" title="点乘叉乘"></a>点乘叉乘</h4><p>点乘，也叫向量的内积、数量积。</p>
<p>求是否在四边形内</p>
<p>向量点乘符合交换律，结合律，分配律。</p>
<p>叉乘，也叫向量的外积、向量积。</p>
<p>求是否在多边形内</p>
<p>向量叉乘不符合交换律（b×a方向朝下），符合结合律，分配律。</p>
<h4 id="drawcall"><a href="#drawcall" class="headerlink" title="drawcall"></a>drawcall</h4><p>简而言之，Draw Call就是CPU调用图形编程接口，比如DirectX或OpenGL，来命令GPU进行渲染的操作。</p>
<p>每个draw call都包含了一系列的绘制命令，指示GPU如何处理顶点、纹理、着色器等图形数据。这些命令告诉GPU如何组装几何体、应用纹理、执行光照计算等。</p>
<h4 id="渲染管线综述"><a href="#渲染管线综述" class="headerlink" title="渲染管线综述"></a>渲染管线综述</h4><p><img src="/images/%E5%85%AB%E8%82%A1/image-20240327225929341.png" alt="image-20240327225929341"></p>
<ul>
<li><p>应用阶段：<strong>CPU</strong>根据场景数据（摄像机，模型，光源等）输出<strong>渲染图元</strong>(点，线，面等)</p>
<ul>
<li><p>工作</p>
<ul>
<li><p>准备场景数据，例如摄像机的位置、视锥体、场景中包含了哪些模型、使用了哪些光源等等；</p>
</li>
<li><p>粗粒度剔除工作，把那些不可见的物体剔除出去，这样就不需要再移交给几何阶段进行处理；</p>
<ul>
<li><p><strong>视锥体剔除</strong> (Frustum Culling) 只禁用相机视野外的对象渲染，不禁用视野中被遮挡的任何物体的渲染,在物体层面上对AABB（Axis-aligned bounding box，坐标对齐包围盒）或OBB（Oriented bounding box,方向包围盒）做处理，剔除在视锥体外的物体运算量较低精度也较低。</p>
</li>
<li><p><strong>遮挡剔除</strong>：遮挡剔除 (Occlusion Culling) 功能是在对象因被其他物体遮挡，当前在相机中无法看到时，禁用对象渲染。该功能一般不会在三维计算机图形中自动开启，因为在大部分情况下，离相机最远的对象最先渲染，离相机近的对象覆盖先前的物体（该步骤称之为“重复渲染 (overdraw)”）。透明物体慎重考虑。</p>
</li>
</ul>
</li>
<li><p>设置渲染状态，包括但不限于使用的材质属性（漫反射颜色、高光反射颜色）、使用的纹理、使用的Shader，是否透明等；</p>
</li>
<li><p>物理解算部分（如布料解算、人物碰撞、水体模拟等等）由于其复杂的计算难度，也由CPU完成；</p>
</li>
</ul>
</li>
<li><p>把数据加载到显存中</p>
</li>
<li><p>设置渲染状态：设置使用哪个顶点着色器(Vertex Shader)&#x2F;片元着色器(Fragment Shader)、光源属性、材质等</p>
</li>
<li><p>调用Draw Call</p>
</li>
</ul>
</li>
<li><p>几何阶段：绘制图元，进行逐顶点、逐多边形的操作。这一阶段将会输出<strong>屏幕空间的二维顶点坐标</strong>、每个顶点对应的深度值、着色等相关信息</p>
</li>
<li><p>光栅化阶段：决定每个渲染图元中的哪些像素应该被绘制在屏幕上。它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等）进行插值，然后再进行逐像素处理。</p>
</li>
</ul>
<h4 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h4><p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330205429385.png" alt="GPU流水线"></p>
<p>步骤</p>
<ul>
<li>**顶点着色器(Vertex Shader)**：可编程，通常用于实现顶点的空间（坐标）变换、顶点着色等功能。</li>
<li>曲面细分着色器(Tessellation Shader)：可选，用于细分图元。</li>
<li>几何着色器(Geometry Shader)：可选，用于执行逐图元(Per-Primitive)的着色操作，或者被用于产生更多的图元。</li>
<li>裁剪(Clipping)：可配置，这一阶段的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。</li>
<li>屏幕映射(Screen Mapping)：这不可配置和编程，它负责把每个图元的坐标转换到屏幕坐标系中。</li>
<li>三角形设置(Triangle Setup)和三角形遍历(Triangle Traversal)阶段也都是固定函数(Fixed-Function)的阶段。</li>
<li><strong>片元着色器</strong>(Fragment Shader)：可编程，它用于实现逐片元(Per-Fragment)的着色操作。</li>
<li>逐片元操作(Per-Fragment Operations)：不可编程，可配置。负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等。</li>
</ul>
<p>重点</p>
<p><strong>顶点着色器(Vertex Shader)</strong></p>
<ul>
<li>实现顶点的空间（坐标）变换、顶点着色等功能</li>
</ul>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330210653926.png"></p>
<ul>
<li><p>可以改变顶点位置（模拟水面，布料等）</p>
</li>
<li><p>基本任务：<strong>把顶点坐标从模型空间转换到齐次裁剪空间</strong></p>
<ul>
<li>所有的物体都以相同的方式进行投影和裁剪，然后进行<strong>透视除法</strong>（参照系变为屏幕）</li>
</ul>
<p>  <img src="/images/%E5%85%AB%E8%82%A1/image-20230330211958286.png" alt="image-20230330211958286"></p>
</li>
</ul>
<p>裁剪</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330212100375.png" alt="image-20230330212100375"></p>
<p>屏幕映射</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330212223439.png" alt="image-20230330212223439"></p>
<ul>
<li>但是要注意不同API的区别</li>
</ul>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330212326112.png" alt="image-20230330212326112"></p>
<p>三角形设置&#x2F;遍历</p>
<p>将顶点连成三角形，然后把每个被三角形覆盖的像素生成一个片元（fragment）</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330215039592.png" alt="image-20230330215039592"></p>
<p><strong>片元（像素）着色器(Fragment Shader)</strong></p>
<p>根据前面的数据插值计算输出颜色值</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330215645807.png" alt="image-20230330215645807"></p>
<p><strong>逐片元操作(Per-Fragment Operations)</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20230330234445873.png" alt="image-20230330234445873"></p>
<ul>
<li>模板测试：模板测试是一种选择性地绘制像素的技术。每个像素都有一个对应的模板值，渲染过程中可以根据模板值进行筛选。常用于实现抠图等功能。</li>
<li>深度测试：深度测试是通过比较像素的深度值来确定是否需要绘制该像素的技术。深度值表示像素距离屏幕的远近程度。深度测试通常用于实现遮挡效果，确保被遮挡的物体不会被渲染。</li>
<li>混合：混合是将新像素的颜色与已经渲染的像素颜色进行混合的过程。在混合过程中，需要考虑每个像素的透明度和颜色值。它可以用于实现透明、半透明、光照等效果。</li>
<li>颜色缓冲区采用<strong>双重缓冲</strong>，后置的渲染完与前置的交换，达到看到的内容是连续的<ul>
<li>有时我们会刻意让某些顶点通过测试以达到特殊效果</li>
</ul>
</li>
</ul>
<h4 id="mvp矩阵"><a href="#mvp矩阵" class="headerlink" title="mvp矩阵"></a>mvp矩阵</h4><p><img src="/images/%E5%85%AB%E8%82%A1/image-20240327233657183.png" alt="image-20240327233657183"></p>
<h4 id="渲染队列"><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h4><p><strong>深度</strong></p>
<p>深度其实就是该像素点在3d世界中<strong>距离摄像机的距离</strong>。离摄像机越远，则深度值（Z值）越大。</p>
<p><strong>深度缓存</strong></p>
<p>深度缓存中存储着准备要绘制在屏幕上的像素点的<strong>深度值</strong>。如果启用了深度缓冲区，在绘制每个像素之前，OpenGL会把该像素的深度值和深度缓存的深度值进行比较。如果<strong>新像素深度值&lt;深度缓存深度值（通过深度测试）</strong>，则新像素值会取代原先的；反之，新像素值被遮挡，其颜色值和深度将被丢弃。(深度主要起的是比较的作用)</p>
<p><strong>深度测试</strong></p>
<p>在深度测试中，默认情况是将要绘制的<strong>新像素的深度值与深度缓冲区中对应位置的深度值</strong>进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新深度缓存中对应像素的颜色值。</p>
<ul>
<li><p>ZWrite可以取的值为：On&#x2F;Off，默认值为On，代表是否要将像素的深度写入深度缓存中(同时还要看ZTest是否通过)。</p>
</li>
<li><p>ZTest可以取的值为：Greater&#x2F;GEqual&#x2F;Less&#x2F;LEqual&#x2F;Equal&#x2F;NotEqual&#x2F;Always&#x2F;Never&#x2F;Off，默认值为LEqual，代表通过比较深度来更改颜色缓存的值。例如当取默认值的情况下，如果将要绘制的新像素的z值小于等于深度缓存中的值，则将用新像素的颜色值更新深度缓存中对应像素的颜色值。需要注意的是，当ZTest取值为Off时，表示的是关闭深度测试，<strong>等价于取值为Always</strong>，而不是Never！Always指的是直接将当前像素颜色(不是深度)写进颜色缓冲区中；而Never指的是不要将当前像素颜色写进颜色缓冲区中，相当于消失。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>ZWrite</th>
<th>ZTest</th>
<th>深度值</th>
<th>颜色值</th>
</tr>
</thead>
<tbody><tr>
<td>On</td>
<td>通过</td>
<td>写入</td>
<td>写入</td>
</tr>
<tr>
<td>On</td>
<td>不通过</td>
<td>不写入</td>
<td>不写入</td>
</tr>
<tr>
<td>Off</td>
<td>通过</td>
<td>不写入</td>
<td>写入</td>
</tr>
<tr>
<td>Off</td>
<td>不通过</td>
<td>不写入</td>
<td>不写入</td>
</tr>
</tbody></table>
<h4 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h4><p>几何着色器（Geometry Shader）是计算机图形学中的一个可编程着色器阶段，它位于顶点着色器和片段着色器之间。几何着色器主要用于处理图元级别的操作和几何变换，并且可以生成新的几何图元。</p>
<p>几何着色器接收输入的几何图元，例如点、线或三角形，然后可以对它们进行各种操作，如几何变换、创建新的图元、删除图元或修改图元的顶点属性。几何着色器运行一次处理一个输入的图元，因此它可以在图元级别上进行操作，而不是单个顶点。</p>
<p>几何着色器的主要功能包括：</p>
<ol>
<li>几何图元扩展（Geometry Primitive Assembly）：几何着色器可以接收输入的图元，并根据一定的规则和条件生成新的图元。例如，它可以接收一组输入的顶点，并生成相应的三角形带或线带。</li>
<li>几何图元的变换（Geometry Transformations）：几何着色器可以对输入的图元进行几何变换，例如旋转、缩放、平移等。这样可以在图元级别上对几何形状进行操作，而不必在顶点着色器中处理。</li>
<li>几何图元的剔除（Geometry Culling）：几何着色器可以根据一定的条件剔除或丢弃输入的图元。例如，可以根据距离、视锥体裁剪或可见性等条件来决定是否保留或丢弃某个图元。</li>
<li>几何图元的细分（Geometry Tessellation）：几何着色器可以在运行时对输入的图元进行细分，生成更多的细分图元。这可以用于创建曲面细分效果或增加几何的细节层次。</li>
</ol>
<h4 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h4><p>延迟渲染（Deferred Rendering）是一种在计算机图形学中使用的渲染技术，与传统的即时渲染（Immediate Rendering）相对。延迟渲染的主要目的是提高渲染效率和灵活性，特别适用于处理大量光源和复杂的场景。</p>
<p>在传统的即时渲染中，图形渲染是一次性完成的，即顶点着色器、几何着色器和片段着色器依次处理每个顶点和片段。这种方式在处理大量光源和复杂的材质时效率较低，因为每个像素都需要进行完整的光照计算和材质着色。</p>
<p>而延迟渲染将渲染过程分为两个主要阶段：几何阶段和光照阶段。在几何阶段中，只进行几何数据的处理，生成并存储一些与光照相关的附加信息，如法线、位置、颜色等，而不进行光照计算。然后，在光照阶段中，使用之前存储的附加信息进行光照计算和材质着色。</p>
<p>延迟渲染的主要优势包括：</p>
<ol>
<li><p>大量光源处理：延迟渲染可以有效地处理大量光源，因为光照计算只在光照阶段进行，而不是每个像素都进行。这减少了重复的计算量，提高了效率。</p>
</li>
<li><p>灵活的材质和效果：延迟渲染将材质属性存储在附加信息中，使得可以在光照阶段对不同的材质属性进行灵活的处理，例如镜面反射、折射等效果。</p>
</li>
<li><p>后期处理和抗锯齿：由于延迟渲染将光照计算与几何分离，因此可以在光照阶段之后应用各种后期处理效果，如景深、运动模糊、环境遮挡等。此外，延迟渲染还可以与抗锯齿技术结合，提供更平滑的图像。</p>
</li>
</ol>
<p>尽管延迟渲染可以提高渲染效率和灵活性，但它也存在一些限制，如对透明物体的处理相对复杂、对内存需求较高等。因此，在特定的应用场景下需要权衡使用延迟渲染的利弊。</p>
<h4 id="剔除"><a href="#剔除" class="headerlink" title="剔除"></a>剔除</h4><p>在Unity和渲染管线中，常见的几种裁剪（Culling）技术包括：</p>
<ol>
<li>视锥体剔除（View Frustum Culling）：根据相机的视锥体（View Frustum）来裁剪不在相机视野范围内的物体。这样可以排除那些完全位于相机视野之外的物体，减少不必要的渲染计算。</li>
<li>背面剔除（Backface Culling）：根据物体的法线方向和相机的视角，剔除背面朝向相机的多边形。因为背面朝向相机的多边形在渲染过程中无法被看到，所以可以提前剔除，减少渲染开销。</li>
<li>遮挡剔除（Occlusion Culling）：根据场景中物体之间的遮挡关系，在渲染之前预先计算哪些物体是被其他物体遮挡的，从而避免渲染被遮挡的物体。这种技术可以大幅提升渲染性能，特别是在复杂的场景中。</li>
<li>LOD剔除（Level of Detail Culling）：通过使用多个不同级别的细节模型，根据相机与物体之间的距离选择适当的细节级别来渲染物体。这样可以在物体远离相机时使用较低细节级别的模型，节省渲染开销。</li>
<li>基于距离的剔除（Distance-Based Culling）：根据物体与相机之间的距离来决定是否渲染该物体。通常会设置一个阈值，只有当物体与相机的距离在阈值范围内时才进行渲染，否则进行剔除。</li>
</ol>
<h4 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h4><p>Physically Based Rendering 基于物理的渲染</p>
<p>PBR的工作流程主要分为两种，一种是基于金属的工作流，一种是基于镜面反射的工作流，它们都遵循着PBR的核心原理，最大的区别是如何识别反射与漫反射。两种工作流传统材质的贴图为法线（Normal）、环境光遮蔽（Ambient Occlusion）、高度（Height）贴图。</p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421103853404.png" alt="image-20240421103853404"></p>
<ul>
<li><p>法线（Normal）贴图：用于模拟表面细节，在非PBR流程中用法相同</p>
</li>
<li><p>环境光遮蔽（Ambient Occlusion）：用于计算因遮蔽而造成的光线衰减的效果，模拟模型的各个面之间的距离</p>
</li>
<li><p>高度（Height）贴图：用于视差映射，为凹凸&#x2F;法线贴图额外提供了更明显的深度，增强真实性。</p>
</li>
<li><p>基于金属的工作流Metal &#x2F; Roughness</p>
<ul>
<li>M-R工作流的特定贴图有基色（BaseColor）、金属度（Metallic）和粗糙度（Roughness）贴图。<ul>
<li>基色（BaseColor）贴图保存了金属的反射率和非金属的反射颜色，包含RGB三通道。不包含其他光照信息。</li>
<li>金属度（Metallic）贴图 描述哪些区域是金属，那些是非金属。黑色区域为非金属，白色区域为金属。</li>
<li>粗糙度（Roughness）贴图描述表面引起光纤漫反射的不规则程度。在粗糙度贴图中，黑色表示光滑表面，白色表示粗糙表面</li>
</ul>
</li>
</ul>
</li>
<li><p>基于镜面反射的工作流Specular &#x2F; Glossiness</p>
<ul>
<li>S-G工作流的特定贴图有漫反射（diffuse）、镜面反射（specular）、光泽度（glossiness）贴图。<ul>
<li>漫反射（diffuse）贴图保存非金属的反射颜色，包含RGB三通道。但它不包含任何反射值，因此金属区域将是黑色。</li>
<li>镜面反射（specular）贴图，定义了金属的反射率值，用来表现当光线照射到模型表面时,其表面属性。俗称高光贴图。</li>
<li>光泽度（glossiness）贴图，和M-R工作流中粗糙度相反，白色表示光滑表面，黑色表示粗糙表面。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>M-R工作流因为其更容易制作和纹理暂用内存少的贴图使用得更多。</p>
<p><strong>基于金属的详细说明</strong></p>
<ul>
<li><strong>灯光属性</strong>：直接照明、间接照明、直接高光、间接高光、阴影、环境光闭塞</li>
<li><strong>表面属性</strong>：基础色、法线、高光、粗糙度、金属度</li>
</ul>
<p><strong>1、光线类型</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/v2-bc3859883c4469f524a9add59e02264e_720w.webp" alt="img"></p>
<p><strong>入射光</strong></p>
<ul>
<li>直接照明：直接从光源发射阴影物体表面的光</li>
<li>间接照明：环境光和直接光经过反弹第二次进入的光</li>
</ul>
<p><strong>反射光</strong></p>
<ul>
<li>镜面光：在经过表面反射聚焦在同一方向上进入人眼的高亮光</li>
<li>漫发射：光被散射并沿着各个方向离开表面</li>
</ul>
<p><strong>光与表面相互作用类型</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/v2-c0e39c006e20d5f7d6859dc916c57daf_720w.webp" alt="img"></p>
<ul>
<li><strong>直接漫反射</strong>：从源头到四面八方散发出来的直接高光<ul>
<li>直接来自光源的光</li>
<li>撞击表面后散落在各个方向</li>
<li>在着色器中使用简单的数学计算</li>
</ul>
</li>
<li><strong>直接高光</strong>：直接来自光源并被集中反射的光<ul>
<li>直接来自光源的光</li>
<li>反射在一个更集中的方向上</li>
<li>在着色器中使用简单的数学计算</li>
<li>计算成本比漫反射低很多</li>
</ul>
</li>
<li><strong>间接漫反射</strong>：来自环境的光被表面散射的光<ul>
<li>来自环境中各个方向的光</li>
<li>撞击表面后散落在各个方向</li>
<li>因为计算昂贵，所以引擎的全局照明解决方案通常会离线渲染，并被烘培成灯光地图</li>
</ul>
</li>
<li><strong>间接高光</strong>：来自环境光并被集中反射的光<ul>
<li>来自环境中各个方向的光</li>
<li>反射在一个更集中的方向上</li>
<li>引擎中使用反射探头，平面反射，SSR，或射线追踪计算</li>
</ul>
</li>
</ul>
<p><strong>（1）基础色</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421105431523.png" alt="image-20240421105431523"></p>
<ul>
<li>定义表面的漫反射颜色</li>
<li>真实世界的材料不会比20暗或比240 sRGB亮</li>
<li>粗糙表面具有更高的最低~ 50srgb</li>
<li>超出范围的值不能正确发光，所以保持在范围内是至关重要的</li>
</ul>
<p><em><strong>基础色贴图制作注意点：</strong></em></p>
<ul>
<li>不包括任何照明或阴影</li>
<li>基本颜色纹理看起来应该非常平坦</li>
<li>使用真实世界的度量或获取最佳结果的数据</li>
</ul>
<p><strong>（2）法线</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421105516965.png" alt="image-20240421105516965"></p>
<ul>
<li>定义曲面的形状每个像素代表一个矢量</li>
<li>该矢量指示表面所面对的方向即使网格是完全平坦的</li>
<li>法线贴图会使表面显得凹凸不平</li>
<li>用于添加表面形状的细节，这里三角形是实现不了的</li>
<li>因为它们表示矢量数据，所以法线贴图是无法手工绘制的</li>
</ul>
<p><strong>（3）镜面</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421105527015.png" alt="image-20240421105527015"></p>
<ul>
<li>用于直接和间接镜面照明的叠加</li>
<li>当直视表面时，定义反射率</li>
<li>非金属表面反射约4%的光</li>
<li>0.5代表4%的反射</li>
<li>1.0代表8%的反射但对于大多数物体来说太高了</li>
<li>在掠射角下，所有表面都是100%反射的，内置于引擎中的菲涅耳项</li>
</ul>
<p><em><strong>镜面贴图制作注意点：</strong></em></p>
<ul>
<li>高光贴图应该大多在0.5</li>
<li>使用深色的阴影来遮盖不应该反光的裂缝</li>
<li>一个裂缝贴图乘以0.5就是一个很好的高光贴图</li>
</ul>
<p><strong>（4）粗糙度</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421105601069.png" alt="image-20240421105601069"></p>
<ul>
<li>表面在微观尺度上的粗糙度</li>
<li>白色是粗糙的</li>
<li>黑色是光滑的</li>
<li>控制反射的“焦点”</li>
<li>平滑&#x3D;强烈的反射</li>
<li>粗糙&#x3D;模糊的，漫反射</li>
</ul>
<p><em><strong>粗糙度贴图制作注意点：</strong></em></p>
<ul>
<li>没有技术限制-完全艺术的选择</li>
<li>艺术家可以使用这张地图来定义表面的“特征”，并展示它的历史</li>
<li>考虑一下被打磨光滑、磨损或老化的表面</li>
</ul>
<p><strong>（5）金属度</strong></p>
<p><img src="/images/%E5%85%AB%E8%82%A1/image-20240421105654487.png" alt="image-20240421105654487"></p>
<ul>
<li>两个不同的着色器通过金属度混合他们</li>
<li>基本色变成高光色而不是漫反射颜色</li>
<li>金属漫反射是黑色的</li>
<li>在底色下，镜面范围可达100%</li>
<li>大多数金属的反光性在60%到100%之间</li>
<li>确保对金属颜色值使用真实世界的测量值，并保持它们明亮</li>
<li>当金属为1时，镜面输入将被忽略</li>
</ul>
<p><em><strong>粗糙度贴图制作注意点：</strong></em></p>
<ul>
<li>将着色器切换到金属模式</li>
<li>灰度值会很奇怪，最好使用纯白色或黑色</li>
<li>当金属色为白色时，请确保使用正确的金属底色值</li>
<li>没有黑暗金属这回事</li>
<li>所有金属均为180srgb或更亮</li>
</ul>
<p><strong>非金属和金属对比</strong></p>
<p><strong>非金属</strong></p>
<ul>
<li>基础颜色&#x3D;漫反射</li>
<li>镜面反射&#x3D;0-8%</li>
</ul>
<p><strong>金属</strong></p>
<ul>
<li>基础颜色&#x3D;0-100%的镜面反射</li>
<li>镜面&#x3D;0%</li>
<li>漫反射总是黑色的</li>
</ul>
<h5 id="PBR高光"><a href="#PBR高光" class="headerlink" title="PBR高光"></a>PBR高光</h5><p>要实现PBR高光，通常需要以下步骤：</p>
<ol>
<li>使用PBR材质系统：PBR材质系统使用一组物理属性描述材质，包括反射率（Albedo）、金属度（Metalness）、粗糙度（Roughness）等。这些属性可以通过纹理贴图或手动输入来定义。</li>
<li>计算镜面反射：PBR高光考虑了材质表面的反射特性。通过计算反射向量，并结合观察者的位置和光源方向，可以计算出表面的镜面反射强度。</li>
<li>能量守恒：PBR高光模型还遵循能量守恒原则，确保镜面反射和漫反射之和不超过单位强度，以保持物理真实性。</li>
<li>使用BRDF函数：PBR高光使用BRDF（双向反射分布函数）来描述材质表面的光照反射特性。常用的BRDF函数有Cook-Torrance和GGX等。</li>
<li>使用环境光遮蔽：PBR高光通常还考虑了环境光遮蔽的影响，以模拟光线在物体表面的遮挡效果。这可以通过环境遮挡贴图（AO）来实现，或者使用屏幕空间环境遮蔽（SSAO）等技术。</li>
</ol>
<h4 id="BRDF函数"><a href="#BRDF函数" class="headerlink" title="BRDF函数"></a>BRDF函数</h4><p>BRDF（Bidirectional Reflectance Distribution Function）是计算机图形学中用于描述光线与材质表面交互的函数。它定义了入射光线方向、出射光线方向和表面法线之间的关系，描述了光线在材质表面上的反射特性。</p>
<p>BRDF函数可以看作是一个光照模型，它描述了在给定入射光线方向下，材质表面对该方向上的入射光线的反射行为。通常，BRDF函数的输入参数包括入射光线方向、出射光线方向和表面法线，并返回反射光线的能量（或颜色）。</p>
<p>BRDF函数的输出可以分为两个部分：漫反射和镜面反射。漫反射部分描述了光线在表面上均匀散射的情况，通常与材质表面的粗糙度和颜色有关。镜面反射部分描述了光线在表面上镜面反射的情况，通常与材质的光泽度和镜面高光效果相关。</p>
<p>BRDF函数的形式可以有多种，常见的包括Lambertian、Phong、Blinn-Phong、Cook-Torrance、GGX等。每种BRDF函数都有不同的数学表达式和参数，用于模拟不同类型的材质和光照效果。</p>
<h4 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h4><p>路径追踪的基本原理如下：</p>
<ol>
<li>发射光线：从图像平面上的每个像素点发射一条主光线，通常以摄像机位置为起点，根据像素位置计算出光线的方向。</li>
<li>光线与物体相交：主光线与场景中的物体进行相交测试。通过光线与物体之间的相交计算，确定光线是否与物体相交，并找到最近的相交点。</li>
<li>光线与材质交互：如果光线与物体相交，根据相交点的材质属性，计算光线在该点的反射、折射、散射等行为。这通常涉及计算反射光线和折射光线的方向、颜色以及散射的采样方向等。</li>
<li>递归追踪：对于反射光线和折射光线，需要继续追踪它们的路径，以模拟光线在场景中的传播。此过程通过递归调用路径追踪算法来实现。每次追踪时，根据光线的方向和场景中的物体，继续计算光线的相交和交互。</li>
<li>能量衰减与采样：在每次光线与物体相交后，需要考虑光线的能量衰减和采样。通过材质的反射率、透射率等属性，调整光线的能量，并使用随机采样技术来模拟光线与物体表面的微小变化，以增加真实感。</li>
<li>光源采样：当光线与场景中的光源相交时，需要计算光源的辐射能量，并将其贡献到最终的像素颜色中。这可以通过计算光源上的采样点，并根据光照模型计算光源的辐射能量。</li>
<li>递归终止条件：递归追踪的终止条件通常是达到最大递归深度或能量衰减到一定阈值以下，以避免无限递归和过度计算。</li>
<li>颜色累积与最终输出：在路径追踪的过程中，收集每个光线的贡献，并将其累积到最终的像素颜色中。最终，将得到每个像素的逼真颜色，形成最终的渲染图像。</li>
</ol>
<p>当光线追踪中的光线反弹次数过多时，会导致以下问题：</p>
<ol>
<li>计算开销增加：每次光线反弹都需要执行相交测试、材质交互和递归追踪等计算操作，过多的反弹次数会增加计算开销，导致渲染时间增加。</li>
<li>噪点和噪声增加：递归追踪过多的反弹次数可能会引入更多的随机采样噪点，导致图像中出现噪点和噪声，影响图像质量。</li>
</ol>
<p>为了解决光线追踪中过多的反弹次数带来的问题，可以采取以下方法：</p>
<ol>
<li>最大反弹次数限制：设置一个合理的最大反弹次数限制，超过该限制的光线将不再进行递归追踪。这样可以控制计算开销，并避免过多的反弹次数导致的噪点增加。</li>
<li>俄罗斯轮盘赌终止条件：在光线追踪的递归过程中，可以使用俄罗斯轮盘赌（Russian Roulette）技术来决定是否终止递归。在每次递归追踪时，根据一定的概率决定是否终止递归，从而控制反弹次数。这样可以在保证图像质量的前提下，减少计算开销。</li>
<li>自适应采样和重要性采样：通过自适应采样和重要性采样技术，可以根据场景中的光照条件和材质属性，智能地选择采样点和方向，从而减少噪点的产生，提高渲染效果。例如，可以根据材质的反射率、光源的强度等信息，有选择地采样具有较高能量贡献的路径。</li>
<li>加速数据结构优化：使用加速数据结构（如包围盒层次结构、kd树、BVH等）来加速相交测试的计算，可以提高光线追踪的效率，从而在有限的反弹次数内获得更好的结果。</li>
</ol>
<h4 id="八叉树、BVH"><a href="#八叉树、BVH" class="headerlink" title="八叉树、BVH"></a>八叉树、BVH</h4><ol>
<li>八叉树（Octree）：<br> 八叉树是一种基于递归分割的空间划分数据结构。它将三维空间划分为八个等分的子空间，每个子空间又可以继续划分为八个子空间，以此类推，直到达到预设的终止条件。八叉树的原理如下：</li>
</ol>
<ul>
<li>初始状态：将整个场景的边界框作为根节点，划分为八个等分的子边界框。</li>
<li>递归划分：对每个非空子边界框，重复以下步骤：<ul>
<li>检查子边界框内的物体，根据物体的位置将其插入到相应的子节点中。</li>
<li>如果子边界框内的物体数量超过某个预设的阈值，或者达到了树的最大深度，则停止划分。</li>
<li>否则，对当前子边界框递归执行划分步骤。</li>
</ul>
</li>
</ul>
<p>八叉树的优点是能够根据场景的几何复杂性自适应地划分空间，提供了一种空间局部性的表示方式。它可以有效地减少相交测试的计算量，并提高光线追踪的效率。</p>
<ol>
<li>包围盒层次结构（Bounding Volume Hierarchy，BVH）：<br> 包围盒层次结构是一种层次化的包围体结构，用于加速相交测试和遍历操作。BVH的原理如下：</li>
</ol>
<ul>
<li>初始状态：将场景中的物体构建成一个树状结构，其中每个节点表示一个包围体（如轴对齐包围盒）。</li>
<li>构建阶段：使用一种构建算法（如重叠最小化算法）对物体进行递归划分，将它们放入合适的包围盒中。这个过程会创建一个层次结构，其中每个节点都有两个子节点，直到达到叶节点。</li>
<li>建立层次结构：根据物体的位置和包围盒之间的相交关系，将节点组成一个层次结构。通常使用二叉树进行表示，其中每个节点都有左右两个子节点。</li>
</ul>
<p>BVH的优点是在遍历过程中能够快速剔除与光线无关的物体，减少相交测试的数量。通过适当的构建算法和节点排序策略，可以使得BVH具有更好的空间局部性和加速效果。</p>
<h4 id="常见的抗锯齿技术"><a href="#常见的抗锯齿技术" class="headerlink" title="常见的抗锯齿技术"></a>常见的抗锯齿技术</h4><p><strong>多重采样抗锯齿（MSAA）</strong></p>
<p>超采，混合</p>
<p><strong>快速近似抗锯齿（FXAA）</strong></p>
<p>近似计算，比MSAA节省性能</p>
<p><strong>时间性抗锯齿（TXAA）</strong></p>
<p>基于前面的帧计算</p>
<h4 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/antchen88/article/details/78506770">https://blog.csdn.net/antchen88/article/details/78506770</a></p>
<p>正交、透视，todo</p>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="判断点是否在扇形范围内"><a href="#判断点是否在扇形范围内" class="headerlink" title="判断点是否在扇形范围内"></a>判断点是否在扇形范围内</h4><p>获取扇形的起始角度，与目标到起点的向量求夹角，判断夹角是否大于扇形角度与距离是否大于半径</p>
<h4 id="求点在向量上的投影"><a href="#求点在向量上的投影" class="headerlink" title="求点在向量上的投影"></a>求点在向量上的投影</h4><p>要求一个点在一个向量上的投影，可以使用向量的点积（内积）和向量的模（长度）进行计算。假设有一个向量A和一个点P。</p>
<ol>
<li>计算向量A的单位向量。将向量A除以其模（长度）得到单位向量 U_A &#x3D; A &#x2F; ||A||。</li>
<li>计算点P在向量A上的投影长度。投影长度可以通过点积的性质计算得到，即投影长度 &#x3D; P·U_A。</li>
<li>计算点P在向量A上的投影点坐标。投影点的坐标可以表示为 P’ &#x3D; 投影长度 * U_A。</li>
</ol>
<p>通过这个过程，可以获得点P在向量A上的投影点坐标 P’。</p>
<p>需要注意的是，投影点并不一定在线段的范围内，它可能超出线段的端点。如果需要确保投影点在线段内部，可以在计算投影长度时，限制其范围在 0 到 A 的长度之间。即投影长度 &#x3D; max(0, min(P·U_A, ||A||))。</p>
<p>此外，如果需要计算点P到向量A的距离，可以计算点P和投影点P’之间的欧氏距离，即距离 &#x3D; ||P - P’||。</p>
<p><strong>视锥剔除的计算过程</strong></p>
<ol>
<li>获取相机参数：首先需要获取相机的视角（Field of View），视口宽高比（Aspect Ratio），近剪裁面（Near Clipping Plane）和远剪裁面（Far Clipping Plane）等参数。</li>
<li>构建视锥体：利用相机参数构建视锥体。视锥体是一个可见体积，由相机位置、相机方向和剪裁面定义。通常，视锥体可以表示为一个六面体，包括近剪裁面、远剪裁面以及四个侧面。</li>
<li>确定物体位置：对于每个需要进行可见性测试的物体，获取其位置信息（通常为物体的包围盒或中心点）。</li>
<li>可见性测试：对于每个物体，将其位置与视锥体进行比较来确定其可见性。测试的方法可以是简单的包围盒与视锥体的相交测试，或者更精确的几何测试。<ul>
<li>简单包围盒测试：将物体的包围盒与视锥体进行相交测试，如果包围盒与视锥体相交，将物体标记为可见，否则标记为不可见。这种方法速度较快，但可能会有一定的误差。</li>
<li>几何测试：对于需要更精确的可见性测试，可以进行几何测试，如射线与物体碰撞检测、多边形与视锥体的相交测试等。这种方法更准确，但计算成本较高。</li>
</ul>
</li>
<li>可见物体渲染：将被标记为可见的物体进行渲染，而标记为不可见的物体则可以跳过渲染过程，以提高性能。</li>
</ol>
<h4 id="3D空间中射线与三角形的交叉检測算法"><a href="#3D空间中射线与三角形的交叉检測算法" class="headerlink" title="3D空间中射线与三角形的交叉检測算法"></a>3D空间中射线与三角形的交叉检測算法</h4><p> 假设一个点在三角形V0。 V1， V2上，那么这个点就能够用例如以下的方式来表示：</p>
<p>$T(u, v) &#x3D; (1 - u - v) * V0 + u * V1 + v * V2$ ;</p>
<p>这里u+v &lt;&#x3D; 1, u &gt;&#x3D; 0 , v &gt;&#x3D;0</p>
<p>而对于射线，我们一般使用例如以下的方程来表示它：</p>
<p>R (t)&#x3D; O + t * D ; (O为射线的起始点，D为射线的方向)</p>
<p>所以，既然他们要有交点。我们就行直接使用例如以下的方法来得出：</p>
<p>O + t * D &#x3D; (1 - u - v) * V0 + u * V1 + v * V2</p>
<p>然后在进行一系列的变换。终于得到结果。</p>
<h4 id="判断矩形是否相交"><a href="#判断矩形是否相交" class="headerlink" title="判断矩形是否相交"></a>判断矩形是否相交</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">is_rect_intersect</span><span class="params">(<span class="type">int</span> x01, <span class="type">int</span> x02, <span class="type">int</span> y01, <span class="type">int</span> y02,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> x11, <span class="type">int</span> x12, <span class="type">int</span> y11, <span class="type">int</span> y12)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> zx = <span class="built_in">abs</span>(x01 + x02 -x11 - x12);</span><br><span class="line">    <span class="type">int</span> x  = <span class="built_in">abs</span>(x01 - x02) + <span class="built_in">abs</span>(x11 - x12);</span><br><span class="line">    <span class="type">int</span> zy = <span class="built_in">abs</span>(y01 + y02 - y11 - y12);</span><br><span class="line">    <span class="type">int</span> y  = <span class="built_in">abs</span>(y01 - y02) + <span class="built_in">abs</span>(y11 - y12);</span><br><span class="line">    <span class="keyword">if</span>(zx &lt;= x &amp;&amp; zy &lt;= y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="Git和svn的区别"><a href="#Git和svn的区别" class="headerlink" title="Git和svn的区别"></a>Git和svn的区别</h4><p>分布vs集中</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/young_0609/article/details/108267204">https://blog.csdn.net/young_0609/article/details/108267204</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hellow__world/article/details/72529022">https://blog.csdn.net/hellow__world/article/details/72529022</a></p>
<h4 id="小鼠试毒"><a href="#小鼠试毒" class="headerlink" title="小鼠试毒"></a>小鼠试毒</h4><p><strong>1000瓶药水，1瓶有毒药，几只小白鼠能够找出？</strong></p>
<p>使用二进制判断，瓶子编号转二进制，每一位对应一只小白鼠</p>
<p>1轮N毒：log2(C（1000，N）</p>
<p>N轮1毒：log3(1000)</p>
<p><strong>测两轮，那么可以测多少瓶水中的一瓶毒药？</strong></p>
<p>首先是第一轮死掉的小鼠不能被replace的情况，小鼠有三种状态，第一轮死，第二轮死，和两轮都没死，那么三种状态可以类比为3进制，小鼠的量程为3^10即59049瓶，具体操作方式为对编码为2的位数，第二轮混合喂。</p>
<p>然后是第一轮死掉的小鼠可以被replace的情况，将每1024瓶混合为1滴做第一轮，选定组别后第二轮确定瓶子编码，量程为2^10 * 2^10即1048576瓶。</p>
<p>对不能replace的N轮，量程为（N+1）^10，能replace的N轮，量程为2^(10*N)。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag"># 游戏开发</a>
              <a href="/tags/Unity/" rel="tag"># Unity</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/" rel="prev" title="数据结构笔记">
                  <i class="fa fa-chevron-left"></i> 数据结构笔记
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fire Egg</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">235k</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
